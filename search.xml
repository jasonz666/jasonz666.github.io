<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>汇编：实验10三题</title>
    <url>/2021/06/06/assembly-experiment10.html</url>
    <content><![CDATA[<h2 id="1、显示字符串"><a href="#1、显示字符串" class="headerlink" title="1、显示字符串"></a>1、显示字符串</h2><p>题目：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E9%A2%98%E7%9B%AE1.png" alt=""></p>
<p>汇编源码：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 实验10.1</span><br><span class="line">; 屏幕指定位置显示指定颜色的字符串</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &#39;Welcome to masm!&#39;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov dh,8        ; 行号 0-24</span><br><span class="line">    mov dl,3        ; 列号 0-79</span><br><span class="line">    mov cl,2        ; 颜色 绿色</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0        ; ds:si指向字符串开头</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h      ; 函数相关栈</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    call show_str</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">; 参数为 行号dh 列号dl 颜色cl</span><br><span class="line">show_str:</span><br><span class="line">    ; 寄存器保存</span><br><span class="line">    push bp</span><br><span class="line">    mov bp,sp</span><br><span class="line">    push di</span><br><span class="line">    push si</span><br><span class="line">    push ax</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    ; 显存起始地址段地址</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    ; 显存中字符的开始地址</span><br><span class="line">    mov al,160      ; 每行字节数</span><br><span class="line">    mul byte ptr [bp+5]</span><br><span class="line">    mov dl,[bp+4]</span><br><span class="line">    mov dh,0</span><br><span class="line">    add ax,dx</span><br><span class="line">    add ax,dx</span><br><span class="line">    mov di,ax</span><br><span class="line"></span><br><span class="line">fill:</span><br><span class="line">    mov cl,[si]     ; 字符</span><br><span class="line">    mov ch,0</span><br><span class="line">    jcxz ok</span><br><span class="line">    mov ch,[bp+6]   ; 颜色</span><br><span class="line">    mov es:[di],cx</span><br><span class="line">    add di,2</span><br><span class="line">    inc si</span><br><span class="line">    jmp fill</span><br><span class="line">ok:</span><br><span class="line">    ; 寄存器恢复</span><br><span class="line">    pop es</span><br><span class="line">    pop ax</span><br><span class="line">    pop si</span><br><span class="line">    pop di</span><br><span class="line">    pop bp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>编译执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/2-%E9%A2%98%E7%9B%AE1%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="2、解决除法溢出问题"><a href="#2、解决除法溢出问题" class="headerlink" title="2、解决除法溢出问题"></a>2、解决除法溢出问题</h2><p>题目：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/3-%E9%A2%98%E7%9B%AE2.png" alt=""></p>
<p>汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 实验10.2</span><br><span class="line">; 解决除法的商的溢出问题</span><br><span class="line">; 公式：X&#x2F;N &#x3D; int(H&#x2F;N)*65536 + [rem(H&#x2F;N)*65536+L]&#x2F;N</span><br><span class="line">; 公式是二项式，第一项得出整个除法的商的高16位，65536不用真的乘</span><br><span class="line">; 第二项得出整个除法的商的低16位，而余数是整个除法的余数</span><br><span class="line">; 题目中除数0a，整个除法余数是0，不好验证，这里使用除数0b</span><br><span class="line">assume cs:code</span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line"></span><br><span class="line">    mov ax,4240h        ; 被除数低16</span><br><span class="line">    mov dx,000fh        ; 被除数高16</span><br><span class="line">    mov cx,0bh          ; 除数</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    push ax</span><br><span class="line">    call divdw</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">divdw:</span><br><span class="line">    push bp</span><br><span class="line">    mov bp,sp</span><br><span class="line">    push bx</span><br><span class="line"></span><br><span class="line">    ; int(H&#x2F;N)</span><br><span class="line">    mov dx,0</span><br><span class="line">    mov ax,[bp+6]</span><br><span class="line">    div word ptr [bp+8]</span><br><span class="line">    mov bx,ax           ; 商的高16位，dx里是余数，不用动</span><br><span class="line"></span><br><span class="line">    ; [rem(H&#x2F;N)*65536+L]&#x2F;N</span><br><span class="line">    ; rem(H&#x2F;N)*65536 表示余数放在高16位，刚好是dx</span><br><span class="line">    ; +L 则为被除数低16位，放到ax里，作为新除法被除数的低16位</span><br><span class="line">    mov ax,[bp+4]</span><br><span class="line">    div word ptr [bp+8]</span><br><span class="line">    mov cx,dx       ; cx为余数</span><br><span class="line">    mov dx,bx       ; dx为商的高16位，ax为商的低16位</span><br><span class="line"></span><br><span class="line">    pop bx</span><br><span class="line">    pop bp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">; 以上，在win2k的dos下用debug执行exe会无效指令，退出dos。可以用dosbox执行。</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/4-%E9%A2%98%E7%9B%AE2%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="3、数值显示"><a href="#3、数值显示" class="headerlink" title="3、数值显示"></a>3、数值显示</h2><p>题目：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/5-%E9%A2%98%E7%9B%AE3.png" alt=""></p>
<p>汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 将数据以十进制形式显示</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db 10 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">swap segment</span><br><span class="line">    dw 10 dup (0)</span><br><span class="line">swap ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,12666</span><br><span class="line">    mov bx,data</span><br><span class="line">    mov ds,bx</span><br><span class="line">    mov si,0</span><br><span class="line">    mov bx,stack</span><br><span class="line">    mov ss,bx</span><br><span class="line">    mov sp,10h</span><br><span class="line">    call dtoc</span><br><span class="line"></span><br><span class="line">    mov bx,swap</span><br><span class="line">    push ss</span><br><span class="line">    mov ss,bx</span><br><span class="line">    push sp</span><br><span class="line">    mov sp,20</span><br><span class="line">    call turn</span><br><span class="line">    pop sp</span><br><span class="line">    pop ss</span><br><span class="line"></span><br><span class="line">    mov dh,8</span><br><span class="line">    mov dl,3</span><br><span class="line">    mov cl,2</span><br><span class="line">    push cx</span><br><span class="line">    push dx</span><br><span class="line">    call show_str</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">dtoc:</span><br><span class="line">    push cx</span><br><span class="line">    push si</span><br><span class="line">    push bx</span><br><span class="line">s:</span><br><span class="line">    mov dx,0        ; 被除数dx:ax</span><br><span class="line">    mov bx,10</span><br><span class="line">    div bx</span><br><span class="line">    mov cx,ax       ; 商ax</span><br><span class="line">    add dx,30h      ; 余数+30h</span><br><span class="line">    mov [si],dl</span><br><span class="line">    jcxz oks</span><br><span class="line">    mov ax,cx</span><br><span class="line">    inc cx</span><br><span class="line">    inc si</span><br><span class="line">    jmp s</span><br><span class="line">oks:</span><br><span class="line">    pop bx</span><br><span class="line">    pop si</span><br><span class="line">    pop cx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 参数为 行号dh 列号dl 颜色cl</span><br><span class="line">show_str:</span><br><span class="line">    ; 寄存器保存</span><br><span class="line">    push bp</span><br><span class="line">    mov bp,sp</span><br><span class="line">    push di</span><br><span class="line">    push si</span><br><span class="line">    push ax</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    ; 显存起始地址段地址</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    ; 显存中字符的开始地址</span><br><span class="line">    mov al,160      ; 每行字节数</span><br><span class="line">    mul byte ptr [bp+5]</span><br><span class="line">    mov dl,[bp+4]</span><br><span class="line">    mov dh,0</span><br><span class="line">    add ax,dx</span><br><span class="line">    add ax,dx</span><br><span class="line">    mov di,ax</span><br><span class="line"></span><br><span class="line">fill:</span><br><span class="line">    mov cl,[si]     ; 字符</span><br><span class="line">    mov ch,0</span><br><span class="line">    jcxz okf</span><br><span class="line">    mov ch,[bp+6]   ; 颜色</span><br><span class="line">    mov es:[di],cx</span><br><span class="line">    add di,2</span><br><span class="line">    inc si</span><br><span class="line">    jmp fill</span><br><span class="line"></span><br><span class="line">okf:</span><br><span class="line">    ; 寄存器恢复</span><br><span class="line">    pop es</span><br><span class="line">    pop ax</span><br><span class="line">    pop si</span><br><span class="line">    pop di</span><br><span class="line">    pop bp</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 字符串顺序翻转</span><br><span class="line">turn:</span><br><span class="line">    push ax</span><br><span class="line">    push cx</span><br><span class="line">    push si</span><br><span class="line"></span><br><span class="line">turn_s:</span><br><span class="line">    mov cl,[si]</span><br><span class="line">    mov ch,0</span><br><span class="line">    jcxz oks2</span><br><span class="line">    push cx</span><br><span class="line">    inc si</span><br><span class="line">    mov cx,2</span><br><span class="line">    jmp turn_s</span><br><span class="line"></span><br><span class="line">oks2:</span><br><span class="line">    mov cx,si</span><br><span class="line">    mov si,0</span><br><span class="line">ok_s:</span><br><span class="line">    pop ax</span><br><span class="line">    mov [si],al</span><br><span class="line">    inc si</span><br><span class="line">    loop ok_s</span><br><span class="line"></span><br><span class="line">    pop si</span><br><span class="line">    pop cx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line">; 以上，在win2k的dos下用debug执行exe会无效指令，退出dos。可以用dosbox执行</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/6-%E9%A2%98%E7%9B%AE3-%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验11：字符串中小写转大写</title>
    <url>/2021/06/08/assembly-experiment11.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>写个汇编程序，将以0结尾的字符串中的小写字母转换为大写字母。</p>
<p>定义函数 letterc，用于转换，参数 ds:si 指向字符串的首地址。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p>汇编源码：</p>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 把字符串中的小写字母转换为大写</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &quot;Beginner&#39;s All-purpose Symbolic Instruction Code.&quot;,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">begin:</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,10h</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    call letterc</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">letterc:</span><br><span class="line">    push si</span><br><span class="line">s:</span><br><span class="line">    mov cl,[si]</span><br><span class="line">    mov ch,0</span><br><span class="line">    jcxz ok</span><br><span class="line">    cmp cx,&#39;a&#39;</span><br><span class="line">    jna s0</span><br><span class="line">    cmp cx,&#39;z&#39;</span><br><span class="line">    jnb s0</span><br><span class="line">    and byte ptr [si],11011111b</span><br><span class="line"></span><br><span class="line">s0:</span><br><span class="line">    inc si</span><br><span class="line">    jmp short s</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    pop si</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end begin</span><br></pre></td></tr></table></figure>

<h2 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h2><p>截图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E8%BD%AC%E5%A4%A7%E5%86%99%E6%88%AA%E5%9B%BE.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验12：自定义零号中断处理程序</title>
    <url>/2021/06/08/assembly-experiment12.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>自定义0号中断处理程序，使得除法溢出发生时，调用自定义的0号中断处理程序。</p>
<p>然后在屏幕中间显示红色字：”divide error!”</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 自定义0号中断处理程序</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset do0       ; ds:si指向中断程序代码的开始地址</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,200h              ; es:di指向中断程序存放处开始地址</span><br><span class="line">    mov cx,offset do0end - offset do0   ; 计算中断程序长度</span><br><span class="line">    cld                             ; 设置串传送方向为正</span><br><span class="line">    rep movsb                 ; 串传送，把中断程序代码复制到0:200h处</span><br><span class="line"></span><br><span class="line">    ; 设置中断向量</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word ptr es:[0*4],200h</span><br><span class="line">    mov word ptr es:[0*4+2],0</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">do0:</span><br><span class="line">    jmp short do0start     ; jmp指令长2字节</span><br><span class="line">    db &quot;divide error!&quot;      ; 显示内容放在中断程序自身内部</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">    mov ax,cs                ; 中断程序装载到0:200h后，被调用时，cs&#x3D;0,ip&#x3D;200</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,202h            ; ds:si指向中断程序中的字符串的开头</span><br><span class="line"></span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,12*160+36*2     ; es:di指向显存空间中间，即屏幕中间位置</span><br><span class="line"></span><br><span class="line">    mov ah,00000100b       ; 设为红色字</span><br><span class="line">    mov cx,13                      ; 字符串长度13</span><br><span class="line">s:</span><br><span class="line">    mov al,[si]</span><br><span class="line">    mov es:[di],ax</span><br><span class="line">    inc si</span><br><span class="line">    add di,2</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h           ; 中断程序中包含退出，执行中断程序后返回到系统</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">do0end:</span><br><span class="line">    nop                    ; 填充一个空字节，为了让do0end参与计算中断程序长度</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><p>截图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E7%BB%93%E6%9E%9C1.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/2-%E7%BB%93%E6%9E%9C2.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/3-%E7%BB%93%E6%9E%9C-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验7</title>
    <url>/2021/05/26/assembly-experiment7.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实验7题目：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%AE%9E%E9%AA%8C7-%E9%A2%98%E7%9B%AE.png" alt="题目"></p>
<p>具体数据在源码部分，见下文。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%AE%9E%E9%AA%8C7-%E8%A6%81%E6%B1%82.png" alt="要求"></p>
<p>汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 将每年信息按如下格式填充到table段：</span><br><span class="line">; 年份         收入       雇员      人均收入</span><br><span class="line">; 4B   空格    4B   空格  2B  空格  2B      空格 （共16字节）</span><br><span class="line">; &#39;1975&#39;      16         3        ??</span><br><span class="line">; 计算21年的人均收入</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    ; 21个 4字节 年份</span><br><span class="line">    db &#39;1975&#39;,&#39;1976&#39;,&#39;1977&#39;,&#39;1978&#39;,&#39;1979&#39;,&#39;1980&#39;,&#39;1981&#39;,&#39;1982&#39;,&#39;1983&#39;,&#39;1984&#39;</span><br><span class="line">    db &#39;1985&#39;,&#39;1986&#39;,&#39;1987&#39;,&#39;1988&#39;,&#39;1989&#39;,&#39;1990&#39;,&#39;1991&#39;,&#39;1992&#39;,&#39;1993&#39;,&#39;1994&#39;,&#39;1995&#39;</span><br><span class="line"></span><br><span class="line">    ; 21个 4字节 双字 年收入</span><br><span class="line">    dd 16,22,382,1356,2390,8000,16000,24486,50065,97479,140417,197514</span><br><span class="line">    dd 345980,590827,803530,1183000,1843000,2759000,3753000,4649000,5937000</span><br><span class="line"></span><br><span class="line">    ; 21个 2字节 字 雇员数</span><br><span class="line">    dw 3,7,9,13,28,38,130,220,476,778,1001,1442,2258,2793,4037,5635,8226</span><br><span class="line">    dw 11542,14430,15257,17800</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">table segment</span><br><span class="line">    ; 每行长16字节</span><br><span class="line">    db 21 dup (&#39;year summ ne ?? &#39;)</span><br><span class="line">table ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax ; 数据段地址</span><br><span class="line"></span><br><span class="line">    mov ax,table</span><br><span class="line">    mov ss,ax ; table段地址</span><br><span class="line">    mov bp,0</span><br><span class="line"></span><br><span class="line">    mov cx,21 ; 循环21次</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">    mov bx,0  ; 数据段偏移</span><br><span class="line">    mov si,21 ; 根据当前循环计算位置</span><br><span class="line">    sub si,cx ; 计算21个数据中所处位置</span><br><span class="line">    add si,si ; 字的偏移要x2</span><br><span class="line"></span><br><span class="line">    mov di,si ; 计算双字偏移量</span><br><span class="line">    add di,di ; 双字要x4</span><br><span class="line"></span><br><span class="line">    mov ax,[bx+di]   ; 年份前2字符</span><br><span class="line">    mov [bp],ax</span><br><span class="line">    add bp,2</span><br><span class="line">    mov ax,[bx+di+2] ; 年份后2字符</span><br><span class="line">    mov [bp],ax</span><br><span class="line">    add bp,2</span><br><span class="line">    mov byte ptr [bp],&#39; &#39;</span><br><span class="line">    inc bp</span><br><span class="line"></span><br><span class="line">    add bx,84</span><br><span class="line">    mov ax,[bx+di]      ; 收入低字</span><br><span class="line">    mov [bp],ax</span><br><span class="line">    add bp,2</span><br><span class="line">    mov dx,[bx+di+2]    ; 收入高16位，ax里存放32位除法的商</span><br><span class="line">    mov [bp],dx</span><br><span class="line">    add bp,2</span><br><span class="line">    mov byte ptr [bp],&#39; &#39;</span><br><span class="line">    inc bp</span><br><span class="line"></span><br><span class="line">    add bx,84</span><br><span class="line">    div word ptr [bx+si] ; 年收入除以雇员，ax里有商，是人均收入</span><br><span class="line">    mov dx,[bx+si]   ; 雇员</span><br><span class="line">    mov [bp],dx</span><br><span class="line">    add bp,2</span><br><span class="line">    mov byte ptr [bp],&#39; &#39;</span><br><span class="line">    inc bp</span><br><span class="line">    mov [bp],ax      ; 人均收入</span><br><span class="line">    add bp,2</span><br><span class="line">    mov byte ptr [bp],&#39; &#39;</span><br><span class="line">    inc bp</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="编译调试与执行结果"><a href="#编译调试与执行结果" class="headerlink" title="编译调试与执行结果"></a>编译调试与执行结果</h2><p>编译：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%AE%9E%E9%AA%8C7-%E7%BC%96%E8%AF%91.png" alt=""></p>
<p>调试：直接执行到 <code>int 21h</code> 指令之前。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%AE%9E%E9%AA%8C7-%E8%B0%83%E8%AF%95.png" alt=""></p>
<p><strong>执行结果截图：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%AE%9E%E9%AA%8C7-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验9：在屏幕中间显示彩色字符串</title>
    <url>/2021/05/28/assembly-experiment9.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在屏幕中间分别显示绿色、绿底红色、白底蓝色的字符串 <code>welcome to masm!</code>。</p>
<p>这里的屏幕指的是，显卡文本模式下的屏幕，屏幕尺寸 80x25，可以显示彩色、高亮、闪烁的ASCII字符。</p>
<p>文本模式下一个字符由2个字节组成，即 ASCII+属性 = 2字节。属性字节的格式：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E5%B1%9E%E6%80%A7%E5%AD%97%E8%8A%82.png" alt="属性字节格式"></p>
<a id="more"></a>

<p>内存地址空间中，b8000h～bffffh 共32KB，是80x25彩色字符模式的显示缓冲区。</p>
<p>显示缓冲区分位8页，每页4KB，每页80x25=2000个字符，2000x2字节=4KB，共8页x4KB=32KB。</p>
<h2 id="汇编程序"><a href="#汇编程序" class="headerlink" title="汇编程序"></a>汇编程序</h2><p>绿字属性字节：00000010b</p>
<p>绿底红色：00100100b</p>
<p>白底蓝色：01110001b</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 屏幕中间显示三行彩色字</span><br><span class="line">; sy9.asm</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">    db &#39;welcome to masm!&#39; ; 16字节</span><br><span class="line">    db 00000010b          ; 绿字</span><br><span class="line">    db 00100100b          ; 绿底红字</span><br><span class="line">    db 01110001b          ; 白底蓝字</span><br><span class="line">    db 11,12,13,64 ; 三行的位置 (25-3)&#x2F;2&#x3D;11 每行开始位置 (80-16)&#x2F;2*2&#x3D;64</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    dw 8 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,16</span><br><span class="line">    mov cx,3</span><br><span class="line">row:</span><br><span class="line">    mov dx,cx</span><br><span class="line">    mov si,3</span><br><span class="line">    sub si,cx</span><br><span class="line">    mov ch,0</span><br><span class="line">    mov cl,19[si]</span><br><span class="line">    mov bp,0</span><br><span class="line">col:</span><br><span class="line">    add bp,160</span><br><span class="line">    loop col</span><br><span class="line"></span><br><span class="line">    mov ah,0</span><br><span class="line">    mov al,ds:[22]</span><br><span class="line">    add bp,ax       ; 每行字符起始位置</span><br><span class="line">    mov si,3</span><br><span class="line">    sub si,dx</span><br><span class="line">    mov ah,16[si]</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,16</span><br><span class="line">fill:</span><br><span class="line">    mov al,[bx]</span><br><span class="line">    push ds</span><br><span class="line">    mov si,0b800h</span><br><span class="line">    mov ds,si</span><br><span class="line">    mov ds:[bp],ax</span><br><span class="line">    pop ds</span><br><span class="line">    inc bx</span><br><span class="line">    add bp,2</span><br><span class="line">    loop fill</span><br><span class="line"></span><br><span class="line">    mov cx,dx</span><br><span class="line">    loop row</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h2><ol>
<li>编译连接</li>
</ol>
<p>masm sy9.asm;<br>link sy9.obj;</p>
<ol start="2">
<li>执行</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/2-%E7%BB%93%E6%9E%9C.png" alt="显示结果"></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：8086转移指令汇总</title>
    <url>/2021/06/08/assembly-jump-instruction-collect.html</url>
    <content><![CDATA[<p><strong>可以修改IP，或者同时修改CS与IP的指令统称为转移指令</strong>。</p>
<p>因为CS:IP是指令寄存器，比较特殊，且CS无法用其他寄存器直接赋值，如：mov cs,ax。</p>
<p>所以需要jmp，call，ret，loop等指令来修改IP或同时修改CS与IP。</p>
<p>CS:IP的组合用来实现8086CPU的20位寻址（虽然8086的寄存器是16位的，但8086内部有20位地址加法器）。</p>
<p>另外，8086CPU是<code>小端模式</code>。内存高地址存放数据高位，内存低地址存放数据低位。</p>
<h2 id="转移指令种类"><a href="#转移指令种类" class="headerlink" title="转移指令种类"></a>转移指令种类</h2><p>8086转移指令种类：</p>
<ul>
<li><p>无条件转移指令（如 jmp）</p>
</li>
<li><p>条件转移指令（如 jcxz）</p>
</li>
<li><p>循环指令（如 loop）</p>
</li>
<li><p>过程（如 call、ret、retf）</p>
</li>
<li><p>中断</p>
</li>
</ul>
<h2 id="伪指令offset"><a href="#伪指令offset" class="headerlink" title="伪指令offset"></a>伪指令offset</h2><p>offset 是伪指令，由汇编器识别并处理，用于取得标号的偏移地址。如：</p>
<a id="more"></a>

<p>start: mov ax,offset start     ; 相当于mov ax,0</p>
<p>s: mov ax,offset s               ; 相当于mov ax,3（因为 mov ax,0 指令占3字节）</p>
<h2 id="jmp无条件转移"><a href="#jmp无条件转移" class="headerlink" title="jmp无条件转移"></a>jmp无条件转移</h2><h3 id="根据位移来转移的jmp指令"><a href="#根据位移来转移的jmp指令" class="headerlink" title="根据位移来转移的jmp指令"></a>根据位移来转移的jmp指令</h3><p><strong>jmp short 标号，段内短转移</strong></p>
<p>功能：</p>
<p>jmp short 标号 功能为：IP=IP+8位位移</p>
<ol>
<li>8位位移=标号处的地址 - jmp指令后的第一个字节的地址；</li>
<li>short 指明此处的位移为8位位移；</li>
<li>8位位移的范围是 <code>-128～127</code>，用补码表示 [注1]；</li>
<li>8位位移由编译程序在编译时算出。</li>
</ol>
<p>注1：</p>
<p>正数的原码与反码、补码相同。负数的反码为绝对值相同的正数按位取反，补码为反码+1。</p>
<p><strong>jmp near ptr 标号，段内近转移</strong></p>
<p>功能：</p>
<p>jmp near ptr 标号 功能为：IP=IP+16位位移</p>
<ol>
<li>16位位移=标号处的地址 - jmp指令后的第一个字节的地址；</li>
<li>near ptr 指明此处的位移为16位位移；</li>
<li>16位位移的范围是 <code>-32768~32767</code> ，用补码表示；</li>
<li>16位位移由编译程序再编译时算出。</li>
</ol>
<h3 id="段间转移、远转移jmp"><a href="#段间转移、远转移jmp" class="headerlink" title="段间转移、远转移jmp"></a>段间转移、远转移jmp</h3><p><strong>jmp far ptr 标号</strong></p>
<p>功能：</p>
<p>CS=标号所在段的段地址；IP=标号所在段的偏移地址。</p>
<p>如：</p>
<p>start: mov ax,0  ; 假设标号处段地址=0123h、偏移地址=10h</p>
<p>mov bx,0</p>
<p>jmp far ptr start  ; 执行完后，CS=0123h，IP=10h</p>
<h3 id="转移地址在寄存器中的jmp"><a href="#转移地址在寄存器中的jmp" class="headerlink" title="转移地址在寄存器中的jmp"></a>转移地址在寄存器中的jmp</h3><p><strong>jmp 16位寄存器</strong></p>
<p>如：jmp ax，功能：IP=AX。</p>
<h3 id="转移地址在内存中的jmp"><a href="#转移地址在内存中的jmp" class="headerlink" title="转移地址在内存中的jmp"></a>转移地址在内存中的jmp</h3><p><strong>jmp word ptr 内存单元地址</strong></p>
<p>功能：</p>
<p>段内转移，使得 IP=内存单元地址处的一个字（占2字节）</p>
<p>如：</p>
<p>mov ax,0123h</p>
<p>mov ds:[0],ax</p>
<p>jmp word ptr [0]  ; 执行后，IP=0123h</p>
<p><strong>jmp dword ptr 内存单元地址</strong></p>
<p>功能：</p>
<p>段间转移，使得 <code>CS=内存单元地址+2 处的一个字</code>（2字节）、<code>IP=内存单元地址 处的一个字</code>（2字节）</p>
<p>也就是说，内存高位的一个字给CS寄存器，内存低位的一个字给IP寄存器。</p>
<p>如：</p>
<p>mov ax,0123h</p>
<p>mov [bx],ax</p>
<p>mov word ptr [bx+2],0</p>
<p>jmp dword ptr [bx] ; 执行后，CS=0，IP=0123h</p>
<h2 id="jcxz条件转移指令"><a href="#jcxz条件转移指令" class="headerlink" title="jcxz条件转移指令"></a>jcxz条件转移指令</h2><p>jcxz可以理解为：<strong>J</strong>ump if <strong>CX</strong> equal <strong>Z</strong>ero。</p>
<p><strong>语法：jcxz 标号（如果 cx=0，转移到标号处执行）</strong></p>
<p>功能：</p>
<p>jcxz 指令为有条件转移指令，所有有条件转移指令都是<strong>短转移</strong>，指令机器码中包含位移而不是目的地址。</p>
<ol>
<li>当 cx=0 时，IP=IP+8位位移；</li>
<li>8位位移=标号处的地址 - jcxz指令后的第一个字节的地址；</li>
<li>8位位移的范围是 <code>-128~127</code>，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
<li>当 cx ≠ 0 时，什么也不做，程序继续向下执行。</li>
</ol>
<p>jcxz 标号 的功能相当于：</p>
<p><code>if (cx == 0) jmp short 标号</code></p>
<h2 id="loop转移指令"><a href="#loop转移指令" class="headerlink" title="loop转移指令"></a>loop转移指令</h2><p><strong>语法：loop 标号（cx–，如果cx ≠ 0，转移到标号处执行）</strong></p>
<p>功能：</p>
<p>loop 指令位循环指令，所有循环指令都是<strong>短转移</strong>，指令机器码中包含位移而不是目的地址。</p>
<p>操作：</p>
<p>cx=cx-1<br>如果 cx ≠ 0，IP=IP+8位位移</p>
<ol>
<li>8位位移=标号处的地址 - loop指令后的第一个字节的地址；</li>
<li>8位位移的范围是 <code>-128～127</code>，用补码表示；</li>
<li>8位位移由编译程序在编译时算出。</li>
<li>当 cx = 0 时，什么也不做，程序继续向下执行。</li>
</ol>
<p>loop 标号 的功能相当于：</p>
<p><code>cx--;</code><br><code>if (cx != 0) jmp short 标号</code></p>
<h2 id="ret和retf转移指令"><a href="#ret和retf转移指令" class="headerlink" title="ret和retf转移指令"></a>ret和retf转移指令</h2><h3 id="ret与retf指令"><a href="#ret与retf指令" class="headerlink" title="ret与retf指令"></a>ret与retf指令</h3><p>ret 指令用栈中的一个字的数据（ss:sp指向的栈），修改IP寄存器，实现近转移（段内转移）。</p>
<p>retf 指令用栈中的二个字的数据（ss:sp指向的栈），修改CS和IP，实现远转移（段间转移）。</p>
<p>功能：</p>
<p>ret 指令，进行如下两步操作：</p>
<ol>
<li>IP=SS*16 + SP      出栈，令IP=栈顶的2个字节</li>
<li>SP=SP+2              栈指针指向栈中下一个字节</li>
</ol>
<p>retf 指令，进行如下4步操作：</p>
<ol>
<li>IP=SS*16 + SP      栈顶2字节给IP</li>
<li>SP=SP+2</li>
<li>CS=SS*16 + SP     栈中接下来2字节CS</li>
<li>SP= SP+2</li>
</ol>
<p>如果用汇编语法来解释 ret 相当于：</p>
<p>pop IP</p>
<p>如果用汇编语法来解释 retf 相当于：</p>
<p>pop IP</p>
<p>pop CS</p>
<h3 id="ret-n-指令"><a href="#ret-n-指令" class="headerlink" title="ret n 指令"></a>ret n 指令</h3><p>ret n 的含义相当于：</p>
<p>pop ip<br>add sp,n</p>
<h2 id="call转移指令"><a href="#call转移指令" class="headerlink" title="call转移指令"></a>call转移指令</h2><h3 id="call-标号（将当前IP压栈，转到标号处执行指令）"><a href="#call-标号（将当前IP压栈，转到标号处执行指令）" class="headerlink" title="call 标号（将当前IP压栈，转到标号处执行指令）"></a>call 标号（将当前IP压栈，转到标号处执行指令）</h3><p>操作：</p>
<ol>
<li>SP=SP-2                   修改栈顶指针</li>
<li>SS*16+SP=IP            当前IP的值压栈</li>
<li>IP=IP+16位位移       IP加上根据标号计算出的16位位移（即段内近转移，call指令没有段内短转移）</li>
</ol>
<p>说明：</p>
<ol>
<li>16位位移=标号处的地址 - call指令后的第一个字节的地址；</li>
<li>16位位移的范围是 <code>-32768~32767</code>，用补码表示；</li>
<li>16位位移由编译程序在编译时算出。</li>
</ol>
<p>call 标号 相当于：</p>
<p><code>push IP</code></p>
<p><code>jmp near ptr 标号</code></p>
<h3 id="call-far-ptr-标号（将当前CS和IP依次压栈，转到标号处执行指令）"><a href="#call-far-ptr-标号（将当前CS和IP依次压栈，转到标号处执行指令）" class="headerlink" title="call far ptr 标号（将当前CS和IP依次压栈，转到标号处执行指令）"></a>call far ptr 标号（将当前CS和IP依次压栈，转到标号处执行指令）</h3><p>call far ptr 标号 实现段间转移，操作：</p>
<ol>
<li>sp=sp-2<br>ss*16+sp=CS<br>sp=sp-2<br>ss*16+sp=IP</li>
<li>CS=标号所在段地址<br>IP=标号所在段的偏移地址</li>
</ol>
<p>call far ptr 标号，相当于：</p>
<p><code>push CS</code></p>
<p><code>push IP</code></p>
<p><code>jmp far ptr 标号</code></p>
<h3 id="call-16位寄存器（将当前IP压栈，从寄存器获得偏移地址给IP）"><a href="#call-16位寄存器（将当前IP压栈，从寄存器获得偏移地址给IP）" class="headerlink" title="call 16位寄存器（将当前IP压栈，从寄存器获得偏移地址给IP）"></a>call 16位寄存器（将当前IP压栈，从寄存器获得偏移地址给IP）</h3><p>功能：</p>
<p>sp=sp-2<br>ss*16+sp=IP<br>IP=16位寄存器</p>
<p>call 16位寄存器 相当于执行：</p>
<p><code>push IP</code></p>
<p><code>jmp 16位reg</code></p>
<h3 id="call-word-ptr-内存单元地址"><a href="#call-word-ptr-内存单元地址" class="headerlink" title="call word ptr 内存单元地址"></a>call word ptr 内存单元地址</h3><p>此指令相当于执行：</p>
<p><code>push IP</code></p>
<p><code>jmp word ptr 内存单元地址</code></p>
<p>如：</p>
<p>mov sp,10h</p>
<p>mov ax,0123h</p>
<p>mov ds:[0],ax</p>
<p>call word ptr ds:[0]</p>
<p>最后，IP=0123h，栈指针SP=0eh</p>
<h3 id="call-dword-ptr-内存单元地址"><a href="#call-dword-ptr-内存单元地址" class="headerlink" title="call dword ptr 内存单元地址"></a>call dword ptr 内存单元地址</h3><p>此指令相当于执行：</p>
<p><code>push CS</code></p>
<p><code>push IP</code></p>
<p><code>jmp dword ptr 内存单元地址</code></p>
<p>如：</p>
<p>mov sp,10h</p>
<p>mov ax,0123h</p>
<p>mov ds:[0],ax</p>
<p>mov word ptr ds:[2],0</p>
<p>call dword ptr ds:[0]</p>
<p>最后，CS=0，IP=0123h，栈指针SP=0ch</p>
<h2 id="cmp与根据比较结果转移的指令"><a href="#cmp与根据比较结果转移的指令" class="headerlink" title="cmp与根据比较结果转移的指令"></a>cmp与根据比较结果转移的指令</h2><h3 id="先说说8086标志寄存器结构"><a href="#先说说8086标志寄存器结构" class="headerlink" title="先说说8086标志寄存器结构"></a>先说说8086标志寄存器结构</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/10-flag%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A81.png" alt=""></p>
<p><strong>标志寄存器在Debug程序中的表示：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/13-debug%E4%B8%ADflag%E7%9A%84%E8%A1%A8%E7%A4%BA.png" alt=""></p>
<p><strong>算术逻辑运算相关指令：</strong></p>
<p>add, sub, mul, div, inc, dec, or, and 等</p>
<p><strong>传送相关指令：</strong></p>
<p>mov, push, pop 等</p>
<p><strong>修改标志寄存器的指令：</strong></p>
<p>pushf，把标志寄存器的值入栈</p>
<p>popf，从栈中弹出数据放入标志寄存器</p>
<h3 id="标志位含义"><a href="#标志位含义" class="headerlink" title="标志位含义"></a>标志位含义</h3><p>ZF：执行算数逻辑运算指令后，保存结果的寄存器中，结果是0，zf=1，反之zf=0</p>
<p>PF：执行算数逻辑运算指令后，保存结果的寄存器中，有偶数个1（0个1也是偶数）时，pf=1，奇数个1时，pf=0</p>
<p>SF：执行算数逻辑运算指令后，保存结果的寄存器中，符号位是1，sf=1，符号位是0，sf=0</p>
<p>CF：执行<strong>无符号数</strong>运算后，加法有进位或减法有借位时，cf=1，反之，cf=0</p>
<p>OF：执行<strong>有符号数</strong>运算后，如果有溢出（运算结果超出结果寄存器的有符号数表示范围称为溢出），of=1，否则of=0</p>
<h3 id="cmp指令"><a href="#cmp指令" class="headerlink" title="cmp指令"></a>cmp指令</h3><p>cmp 是比较指令，相当于减法指令，但不会保存结果。cmp 执行后会对标志寄存器产生影响。</p>
<p>格式：cmp 操作对象1, 操作对象2</p>
<p><strong>无符号数的cmp（涉及到标志位 ZF、CF）：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/10-cmp%E6%8C%87%E4%BB%A4.png" alt=""></p>
<p><strong>有符号数的cmp（涉及到标志位 SF、OF、ZF）：</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/14-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89.png" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/11-%E6%9C%89%E7%AC%A6%E5%8F%B7%E6%95%B0cmp%E6%8C%87%E4%BB%A4.png" alt=""></p>
<h3 id="根据比较结果转移的指令"><a href="#根据比较结果转移的指令" class="headerlink" title="根据比较结果转移的指令"></a>根据比较结果转移的指令</h3><p>这些指令与cmp配合使用，这些指令就是检测cmp执行后影响到的标志位：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/12-%E6%A0%B9%E6%8D%AE%E6%AF%94%E8%BE%83%E7%BB%93%E6%9E%9C%E7%9A%84%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.png" alt=""></p>
<p>根据有符号数的比较结果进行转移的条件转移指令与无符号数的原理相同，只是检查的标志位有所不同。</p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：8086CPU寻址模式、Debug程序用法</title>
    <url>/2021/05/21/assembly-preparing.html</url>
    <content><![CDATA[<p>为了配合《操作系统实战45讲》，还是得重学一下汇编。所以就有了这个系列。</p>
<p>本系列文章算是《汇编语言第4版》的笔记，也有自己的一些心得～</p>
<p>然后这个系列的文章标题是这样的：<code>汇编：吧啦吧啦吧啦</code></p>
<p>老师的教学思想镇楼：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/01-%E6%95%99%E5%AD%A6%E6%80%9D%E6%83%B3.png" alt=""></p>
<p>我并不完全赞同这个思想，因为会有客观条件限制。</p>
<h2 id="看看计算机的逻辑结构"><a href="#看看计算机的逻辑结构" class="headerlink" title="看看计算机的逻辑结构"></a>看看计算机的逻辑结构</h2><h3 id="计算机中各类存储器的逻辑连接"><a href="#计算机中各类存储器的逻辑连接" class="headerlink" title="计算机中各类存储器的逻辑连接"></a>计算机中各类存储器的逻辑连接</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E5%90%84%E7%B1%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E8%BF%9E%E6%8E%A5.png" alt=""></p>
<a id="more"></a>

<h3 id="把各类存储器看作一个逻辑存储器"><a href="#把各类存储器看作一个逻辑存储器" class="headerlink" title="把各类存储器看作一个逻辑存储器"></a>把各类存储器看作一个逻辑存储器</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E4%B8%80%E4%B8%AA%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E5%99%A8.png" alt=""></p>
<h3 id="8086合成20位地址（8086实模式寻址方式）"><a href="#8086合成20位地址（8086实模式寻址方式）" class="headerlink" title="8086合成20位地址（8086实模式寻址方式）"></a>8086合成20位地址（8086实模式寻址方式）</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/8086CPU%E5%90%88%E6%88%9020%E4%BD%8D%E5%9C%B0%E5%9D%80.png" alt=""></p>
<h2 id="搭建实验环境"><a href="#搭建实验环境" class="headerlink" title="搭建实验环境"></a>搭建实验环境</h2><p>《汇编语言》这本书用的是8086CPU的实模式来讲汇编的，然后用DOS系统做实验。</p>
<p>可是，DOS系统也太古老了。那我们就在虚拟机VMware中装一个Win2k，然后进命令行，再用Debug程序做实验。</p>
<p>虚拟机安装Win2k的教程太多了，这里不在赘述。下面是安装过程的一些截图：</p>
<h3 id="Win2k安装过程"><a href="#Win2k安装过程" class="headerlink" title="Win2k安装过程"></a>Win2k安装过程</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/Win2k%E5%AE%89%E8%A3%85%E6%88%AA%E5%9B%BE.png" alt=""></p>
<h3 id="来看看Win2k系统，00后的朋友们不一定见过"><a href="#来看看Win2k系统，00后的朋友们不一定见过" class="headerlink" title="来看看Win2k系统，00后的朋友们不一定见过"></a>来看看Win2k系统，00后的朋友们不一定见过</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/WIn2k%E7%B3%BB%E7%BB%9F%E6%88%AA%E5%9B%BE.png" alt=""></p>
<h3 id="重点来了，进入虚拟8086模式的DOS"><a href="#重点来了，进入虚拟8086模式的DOS" class="headerlink" title="重点来了，进入虚拟8086模式的DOS"></a>重点来了，进入虚拟8086模式的DOS</h3><p>在Win2k中进入的DOS，是虚拟8086模式的DOS。要用实模式的DOS，在虚拟机直接装个DOS系统比较好。</p>
<p>Win2k进入DOS的方法：开始菜单 ⟶ 运行 ⟶ 输入 command ⟶ 按Alt+Enter进入全屏DOS</p>
<p><code>exit</code> 输入此命令退出DOS，回到Win2k</p>
<p><code>debug</code> 进入Debug程序，做汇编实验就靠它了</p>
<p><code>quit</code> 退出Debug程序，回到DOS</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/Win2k%E8%BF%9B%E5%85%A5DOS%E5%86%99%E6%B1%87%E7%BC%96.png" alt=""></p>
<h3 id="Debug程序的常用操作按键"><a href="#Debug程序的常用操作按键" class="headerlink" title="Debug程序的常用操作按键"></a>Debug程序的常用操作按键</h3><p>Debug常用功能一览。包括查看、修改寄存器或内存的命令。机器码翻译成汇编，输入汇编指令，执行汇编指令等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/DOS%E7%9A%84Debug%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.png" alt=""></p>
<p>好了，环境搭好，后面就可以学习汇编了。</p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>计科B站学习视频</title>
    <url>/2021/04/26/cs-learn-in-bilibili.html</url>
    <content><![CDATA[<p><strong>计算机科学入门：</strong></p>
<p>《计算机科学速成课》，<a href="https://www.bilibili.com/video/av21376839/?p=1" target="_blank" rel="noopener">B站</a><a href="https://www.bilibili.com/video/av21376839/?p=1" target="_blank" rel="noopener">中文字幕版</a>，共40集</p>
<p>《CS50 哈佛计算机科学导论》，非常经典，<a href="https://www.bilibili.com/video/BV1cE411j7in?from=search&seid=10548244881245554190" target="_blank" rel="noopener">B站地址</a></p>
<p>《算法导论-MIT麻省理工》，<a href="https://www.bilibili.com/video/BV1Kx411f7bL?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《物理学十分钟速成课》，<a href="https://www.bilibili.com/video/BV1Nb411L7fQ?from=search&seid=17238245196463281490" target="_blank" rel="noopener">B站地址</a></p>
<p><strong>计算机组成原理：</strong></p>
<p>《计算机组成原理 快速复习》，<a href="https://www.bilibili.com/video/BV1rV411k7Xf?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《计算机组成原理 唐朔飞》，哈工大，<a href="https://www.bilibili.com/video/BV1WW411Q7PF?p=1" target="_blank" rel="noopener">B站</a></p>
<p><strong>操作系统：</strong></p>
<p>《操作系统 清华大学》，向勇、陈渝，<a href="https://www.bilibili.com/video/BV1js411b7vg?from=search&seid=10033970866122426678" target="_blank" rel="noopener">B站地址</a></p>
<p>《操作系统 哈工大》，李治军，内容比清华的更详细，<a href="https://www.bilibili.com/video/BV1d4411v7u7?p=1" target="_blank" rel="noopener">B站地址</a></p>
<a id="more"></a>

<p><strong>计算机网络：</strong></p>
<p>《计算机网络微课堂》，湖南科技大学，<a href="https://www.bilibili.com/video/BV1c4411d7jb?from=search&seid=12426748443173359886" target="_blank" rel="noopener">B站地址</a></p>
<p>《计算机网络 谢希仁第七版》，方老师讲解，<a href="https://www.bilibili.com/video/BV1yE411G7Ma?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《Wireshark抓包 从入门到入坟》，<a href="https://www.bilibili.com/video/BV1X5411x7R4?p=1" target="_blank" rel="noopener">B站</a></p>
<p><strong>数据库：</strong></p>
<p>《SQL进阶教程》，<a href="https://www.bilibili.com/video/BV1UE41147KC?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《MySQL高级教程》，涉及底层原理，<a href="https://www.bilibili.com/video/BV1CZ4y1M7MQ?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《Redis教程》，<a href="https://www.bilibili.com/video/BV1S54y1R7SB?p=1" target="_blank" rel="noopener">B站</a></p>
<p><strong>数据结构与算法：</strong></p>
<p>《数据结构 浙江大学》，讲的经典而系统，<a href="https://www.bilibili.com/video/BV1JW411i731?p=1" target="_blank" rel="noopener">B站</a></p>
<p>《LeetCode算法刷题解析》，左程云，<a href="https://www.bilibili.com/video/BV15D4y1X7Tt?p=1" target="_blank" rel="noopener">B站</a></p>
<p><strong>C/C++语言：</strong></p>
<p>《郝斌C语言自学教程》，<a href="https://www.bilibili.com/video/BV1os411h77o?from=search&seid=5426432897798417990" target="_blank" rel="noopener">B站地址</a></p>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Sh 和 Bash 之间的区别</title>
    <url>/2018/12/24/diff-between-sh-and-bash.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一般情况下，<code>sh</code> 是指向 <code>bash</code> 的链接。查看 bash 的手册页可知，bash 作为 sh 运行时，相当于 <code>bash --posix</code>，即 sh 以符合 POSIX 标准的方式来运行。</p>
<p>在一次使用脚本的过程中，发现脚本中 <code>alias</code> 命令设置的别名始终无效。后来查资料发现，<code>bash</code> 和 <code>sh</code> 运行脚本的结果是不同的。</p>
<p>默认情况下，bash 运行非交互式 shell 时，是关闭 <code>alias</code> 别名扩展功能的，而脚本就是非交互式 shell。但是，sh 同样的情况下是开启别名扩展功能的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>① 使用 sh 运行脚本。</p>
<p>② 在脚本文件中显式地指出开启别名扩展功能，方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在脚本的 alias 命令之前添加如下命令</span></span><br><span class="line"><span class="comment"># 最好是在脚本的开头位置添加</span></span><br><span class="line"><span class="built_in">shopt</span> -s expand_aliases</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>关于 <code>bash</code> 与 <code>sh</code> 的差别可能还有更多，写脚本后应该充分测试。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/liuxiangke0210/article/details/66476970" target="_blank" rel="noopener">https://blog.csdn.net/liuxiangke0210/article/details/66476970</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Shell</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用指定的 SSH 密钥克隆和提交</title>
    <url>/2018/12/23/git-commit-via-ssh-key.html</url>
    <content><![CDATA[<h2 id="Git-使用指定的密钥"><a href="#Git-使用指定的密钥" class="headerlink" title="Git 使用指定的密钥"></a>Git 使用指定的密钥</h2><p>默认情况，Git 会使用 <code>~/.ssh/id_ecdsa</code> 来登录远程仓库，比如登录 <code>github.com</code>。我这里使用的是 <code>ecdsa</code> 算法，所以是 <code>id_ecdsa</code>。</p>
<p>怎么样使用指定的密钥呢？比如使用 <code>id_ecdsa_123</code>。创建 ssh 配置文件 <code>config</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件内容</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ecdsa_github</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure>

<p>配置文件的含义：</p>
<ul>
<li><code>Host github.com</code>：指定一个主机</li>
<li><code>HostName github.com</code>：上面指定的主机的主机名</li>
<li><code>User git</code>：登录该主机的用户名，如果是登录 <code>github.com</code>，就必须是 <code>git</code></li>
<li><code>IdentityFile ~/.ssh/id_ecdsa_github</code>：关键配置，这里指定了使用哪个私钥文件</li>
<li><code>IdentitiesOnly yes</code>：它指示 ssh 仅使用在命令行上指定的私钥文件或在 <code>config</code> 文件中配置的私钥文件</li>
</ul>
<a id="more"></a>

<h2 id="使用密钥克隆"><a href="#使用密钥克隆" class="headerlink" title="使用密钥克隆"></a>使用密钥克隆</h2><p>配置完上面的 <code>config</code> 文件之后，就可以使用指定的私钥文件来克隆。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:jasonz666/shell-utils</span><br></pre></td></tr></table></figure>

<h2 id="使用密钥提交修改"><a href="#使用密钥提交修改" class="headerlink" title="使用密钥提交修改"></a>使用密钥提交修改</h2><p>如果我们使用 HTTPS 方式克隆了一个仓库，而不是像上面那样使用 SSH 密钥方式。先要将 SSH 密钥登录远程服务器 <code>github.com</code> 的方式关联到本地仓库。执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入本地仓库目录</span></span><br><span class="line">$ <span class="built_in">cd</span> shell-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已关联的远程仓库服务器</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (fetch)</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新的远程仓库服务器</span></span><br><span class="line">$ git remote add ssh git@github.com:jasonz666/shell-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看远程仓库服务器</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (fetch)</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (push)</span><br><span class="line">ssh	gitgit@github.com:jasonz666/shell-utils (fetch)</span><br><span class="line">ssh	gitgit@github.com:jasonz666/shell-utils (push)</span><br></pre></td></tr></table></figure>

<p>使用 SSH 密钥方式提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push ssh master</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/82aa1678411e" target="_blank" rel="noopener">https://www.jianshu.com/p/82aa1678411e</a><br><a href="https://www.howtoing.com/fix-ssh-too-many-authentication-failures-error" target="_blank" rel="noopener">https://www.howtoing.com/fix-ssh-too-many-authentication-failures-error</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/12/21/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用 GPG 学习非对称加密</title>
    <url>/2019/01/09/learn-asymmetric-encryption-by-gpg.html</url>
    <content><![CDATA[<h2 id="非对称加密需要公钥和私钥："><a href="#非对称加密需要公钥和私钥：" class="headerlink" title="非对称加密需要公钥和私钥："></a>非对称加密需要公钥和私钥：</h2><p>你的公钥的作用：别人用来给你发加密的信息(公钥加密)＆别人验证你的签名(公钥解密)，即加密&amp;验证（别人来做）<br>你的私钥的作用：你用来创建签名(私钥加密)＆解密别人发给你的信息的(私钥解密)，即解密&amp;签名（你来做）</p>
<p>具体而言，Alice要想发送加密信息到Bob，则：<br>Alice有Alice的签名私钥和Bob的加密公匙<br>Bob有Alice的签名公匙和Bob的解密私钥</p>
<h2 id="使用GPG可以很好的演示这一点："><a href="#使用GPG可以很好的演示这一点：" class="headerlink" title="使用GPG可以很好的演示这一点："></a>使用GPG可以很好的演示这一点：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg (GnuPG) 2.1.11</span><br><span class="line">libgcrypt 1.6.5</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>首先，我们在安装好GPG之后（<a href="https://www.gnupg.org/howtos/zh/index.html" target="_blank" rel="noopener">GnuPG官方文档</a>），可以使用 <code>gpg --gen-key</code> 生成属于我们自己的一对公钥和私钥（通常一个GPG密钥包含多个RSA密钥对，一对主密钥，若干对不同用途的子密钥，一对密钥包括一个公钥和一个私钥。一般 <code>gpg --gen-key</code> 得到的，就包括一对主密钥，可以用于签名与认证[SC]；一对子密钥用于加密[E]）。之后我们可以使用 <code>gpg --export [UID]</code> 来输出UID所对应的公钥，比如对于我来说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~ $ gpg --<span class="built_in">export</span> -a 刘海博</span><br><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">mQENBFbnwUkBCADtMQ73lZ1XEbcNbGyaF5IHQ1aoYBrIhj+BpXbV9Qz95OxqOoFP</span><br><span class="line">6s0n1/cBhpjhhqm2hlJFhwrKIDMkTKBY0rif3ZHdHVKK7k7xW0qYWa0HZDtRApao</span><br><span class="line">N3lZ3Ay2EyTSPj6SoFxleLm8LoftlDscp90kK/zGiXf95pslTmk4ziSolOtPTvP7</span><br><span class="line">FpSaYizOO3JfUKUDrTdXRcEx2p7KmXi8v1O33bY0YG6yRmff90DzMxYqQ2LUQBfl</span><br><span class="line">hVSu3mYKpP5IQ0tNgTCbUiyVqOX+TdxQoqMiTWiWvD5OJZf+7RqnbpQ9l6epmUEk</span><br><span class="line">HAJcvhcEfLeDslt2o+x2s7BXW1o71/Xa3Q/fABEBAAG0HuWImOa1t+WNmiA8c2hp</span><br><span class="line">bmluZ2xoYkAxNjMuY29tPokBNwQTAQgAIQUCVufBSQIbAwULCQgHAgYVCAkKCwIE</span><br><span class="line">FgIDAQIeAQIXgAAKCRBbDqAL2u3LWxkXB/96dBtELKkA6hc2BLBxLBxchakEeaMK</span><br><span class="line">lXDEiom6kwiqeI/H3KJchOtlTbBLGUmSdRAm3rX5UkVtaDvxW6iWuNzcbDZN6oCe</span><br><span class="line">YCFqOvmzLZ+YWh48tRBJOTEzrkZrT/OpTGRtRI0cAIAJ68rMc5Vpxl1Vqknp/BzI</span><br><span class="line">z84qPGBWgThy/UlgcFnbkZVLh37FLmIhtTMIbA1whum570/a/bnKP6xWnB4P5ryn</span><br><span class="line">6lXLBMDMA2a0jtgzmywXm60nI6M77lzfd6UXGX0NQOU/AP+v0hNzkl4+KapEOONC</span><br><span class="line">x7MjoL09b946Tqysly5u6gJpK/YmD0UUnVrH2OW6YQy/UmXQk7mKjG/7uQENBFbn</span><br><span class="line">wUkBCACx3kvVDVjuo/LQrODb0wZig7NrsLasQ+dAOo/9UXY53wjrnLPiZLRbtYm1</span><br><span class="line">tPFMykAv/23+vLXmLFW7gd0PjGOPZE4Q0/vR/Re+vJjonH3Z6E+DidE7T9vQmuB4</span><br><span class="line">aLIvDpEcAWKSRN75/zLKzAysqHwEBXeSVD89bSMdH4rPpC70hABZZuVYC3rEkrdZ</span><br><span class="line">6EcW7jca71eKVTKQRznuTZKzpHG8XwcgTt5qtmbZmWxIT4SMdxyI//fpAUjDc913</span><br><span class="line">qN9i/ZY668g8URQLxCUTdFy04p1Vft1yCByZF9Pie5paVO28kgegZf1O6+k1rR42</span><br><span class="line">WHbtLFq7xYgW3vOG9I9yQdA8oOUHABEBAAGJAR8EGAEIAAkFAlbnwUkCGwwACgkQ</span><br><span class="line">Ww6gC9rty1vt+ggAza5faR5AeHgIOnUyI3j28GxFey3E7CbVRO0ubO7Iq5qy+P1z</span><br><span class="line">EQPmnpeQ/FpDabvP4P7qds77U2wFbvsa/Ar4ZuznmNuL9r8fGJn6BrmPLAMxfwOo</span><br><span class="line">c+w6qN0iYp+kl6pRTYYolICyZfq/CLrDKxUaAHlSpZoEI5CUIs/tntcLJRSei/1S</span><br><span class="line">GUjXS7sqlVafNM2Vqxy3XBqVffXGsUNXr1zRGz/Dia9Kt3sztDYDjo3csHlEPVTw</span><br><span class="line">v1gRxVTnsrmoQlJ7+S2tT6hocuD5k6Ye11vyCMYny6BxCYz5CW6HtvAWs9kXT6E3</span><br><span class="line">hTFS5THpkuu+uZLPM2CGJuFLdwNrBzMXHrqRaQ==</span><br><span class="line">=Eh6b</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure>

<p>以上就是我的公钥，其中 <code>-a</code> 是为了让字符以ASCII形式输出，而不是二进制。隐含地，结果将输出到标准输出（stdout）去，可以用 <code>-o</code> 选项把它放到一个文件里去。<br>之后，我们需要得到别人的公钥，才能用他的公钥加密我们想要发给他的数据。<code>gpg --import [filename]</code> 即可导入别人的公钥，这个存放公钥的文件可以使用 <code>-o</code> 选项导出。<br>我们可以通过 <code>gpg --list-keys</code> 查看当前所有的公钥，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --list-keys</span><br><span class="line">/home/lgl/.gnupg/pubring.kbx</span><br><span class="line">----------------------------</span><br><span class="line">pub   rsa2048/DAEDCB5B 2016-03-15 [SC]</span><br><span class="line">uid         [ 绝对 ] 刘海博 &lt;shininglhb@163.com&gt;</span><br><span class="line">sub   rsa2048/7D6453AF 2016-03-15 [E]</span><br><span class="line"></span><br><span class="line">pub   dsa1024/C9C40C31 2001-05-25 [SCA]</span><br><span class="line">uid         [ 未知 ] Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">uid         [ 未知 ] Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">sub   elg1024/59FAB546 2001-05-25 [E]</span><br></pre></td></tr></table></figure>

<p>说明我现在有两个公钥，一个是我自己的，另一个是Justin的。钥匙号分别为 <code>DAEDCB5B</code> 和 <code>C9C40C31</code> ，说到钥匙号，我们也可以使用别人的公钥钥匙号导入公钥 <code>gpg --recv-keys 0xC9C40C31</code> 。<br>如果此时Justin用自己的私钥给文件签名（假设签名后的文件为sample.txt.asc，关于签名的内容我们会在最后再说）然后发给我，那么我就可以用公钥去验证文件签名的真伪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --verify sample.txt.asc</span><br><span class="line">gpg: 于 Fri 17 Aug 2001 06:56:01 AM CST 创建的签名，使用 DSA，钥匙号 C9C40C31</span><br><span class="line">gpg: 完好的签名，来自于“Justin R. Miller &lt;justin@solidlinux.com&gt;” [未知]</span><br><span class="line">gpg:               亦即“Justin R. Miller &lt;justin@voxel.net&gt;” [未知]</span><br><span class="line">gpg: 警告：这把密钥未经受信任的签名认证！</span><br><span class="line">gpg:       没有证据表明这个签名属于它所声称的持有者。</span><br><span class="line">主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br></pre></td></tr></table></figure>

<p>以上信息可以看出，我们使用Justin的公钥可以认证这个文件，且文件的内容未曾被更改。但是有警告信息，这些信息是在告诉我们：如果这把公钥真的是Justin的，那么这个文件就是Justin的，但是这把公钥的真伪并没有的到验证，可能存在我们当初得到的公钥是被别人替换过的公钥的情况。为此，我们应当跟Justin本人确认此公钥的正确性，如果确认无误，我们可以对这个公钥进行信任程度设置（稍后再讲信任度的设置）。<br>如果使用了 <code>--detach-sign</code> 选项（下文会讲到此选项的含义）将签名保存到单独的文件里，那么完整的验证命令是这样的 <code>gpg --verify signfile [datafile]</code>。比如 <code>gpg --verify sample.txt.asc sample.txt</code> (如果 sample.txt.asc 是单独的签名文件，sample.txt 是原始数据文件的话)。</p>
<h2 id="接下来看使用GPG加密与解密的过程："><a href="#接下来看使用GPG加密与解密的过程：" class="headerlink" title="接下来看使用GPG加密与解密的过程："></a>接下来看使用GPG加密与解密的过程：</h2><p>首先，我们写一些话，想要发给Justin（Hello.txt）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br></pre></td></tr></table></figure>

<p>既然我们想发给Justin，那么我们自然需要用Justin的公钥对其进行加密（然后Justin再用自己的私钥对我发过去的加密内容进行解密），加密使用到的命令是 <code>gpg -e 要加密的文件名</code> 或者是 <code>gpg --encrypt 要加密的文件名</code> ，我们可以再加 <code>-r</code> 参数直接指定要发送的人的UID（即选用指定的公钥），如果此处不使用 <code>-r</code> ，在执行加密的过程中也会要求填写接收人的UID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r justin -e Hello.txt</span><br><span class="line">gpg: 59FAB546：没有证据表明这把密钥真的属于它所声称的持有者</span><br><span class="line">sub  elg1024/59FAB546 2001-05-25 Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"> 子钥指纹： 5B6A 9C4D 7C54 5936 B9F5  4D8B EDD4 CD22 59FA B546</span><br><span class="line"></span><br><span class="line">这把密钥并不一定属于用户标识声称的那个人。如果您真的知道自</span><br><span class="line">己在做什么，您可以在下一个问题回答 yes。</span><br><span class="line"></span><br><span class="line">无论如何还是使用这把密钥吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>以上可以看出，虽然我们对内容进行了加密，但是由于我们还没有对公钥进行信任度设置，gpg仍在提醒我们公钥本身有可能就是假的。<br>接下来看看加密后的内容（Hello.txt.gpg）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hello.txt.gpg</span><br><span class="line">����<span class="string">"Y��F�����re�5m�j ���</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>乱码，因为这是二进制文件。<br>试试在加密过程中加入 <code>--armor</code> 参数（以ASCII而不是二进制输出）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r justin -e --armor Hello.txt</span><br><span class="line">gpg: 59FAB546：没有证据表明这把密钥真的属于它所声称的持有者</span><br><span class="line">sub  elg1024/59FAB546 2001-05-25 Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"> 子钥指纹： 5B6A 9C4D 7C54 5936 B9F5  4D8B EDD4 CD22 59FA B546</span><br><span class="line"></span><br><span class="line">这把密钥并不一定属于用户标识声称的那个人。如果您真的知道自</span><br><span class="line">己在做什么，您可以在下一个问题回答 yes。</span><br><span class="line"></span><br><span class="line">无论如何还是使用这把密钥吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>接下来再查看加密后的文件（Hello.txt.asc）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hello.txt.asc</span><br><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQEOA+3UzSJZ+rVGEAP/YTDy4HcGP9PyvfKxH30fZtVJ/jqg/+NKJjTecuSdchSc</span><br><span class="line">RxDBwu0zEmpV0pdnllBteayfabPr1JDJdZ5UX6yCpsc/vON6nRVULGHSkACIXsmc</span><br><span class="line">m2vCTIMlbbnclu4bRSoXU5tI2tgWie6xFrZUMH7q4pRVUrL9wMYRyTUsP6wcJDYD</span><br><span class="line">/1ybF3IWEWjYiLWS+KDbiQUcvpLrJzXXNsiYsIUV4no1Uh14SOKraU3sz7zGq/Sy</span><br><span class="line">FuhdMALDENqVX2+tGhi9/u3qJq5NgSn1v+uUwJFqehYbO514LAxSczWSQGE7APUN</span><br><span class="line">vOPhLJURN7iHdN1cHnJvi2zvDHcvMssPwwPjUKtnnR3Z0oEBW8LuO7pICGZ5PDss</span><br><span class="line">4ItACKwNQYPcNGukYvO+LuRbE7uxMegROeqpLPOjVNsNOiCQVHl4pI9KSV+WLFXl</span><br><span class="line">xgurX4Up1uUi1rW1mPZEaXbnMT+rcenY508Dj6ayYAN07XP5/wg5HDQF0S2+OIhW</span><br><span class="line">VQEkj6DiqZfbIEUSz2SDm5zIZiU=</span><br><span class="line">=IMgg</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>虽然是字符，但显然内容已经被加密了，无法看懂。<br>我们把加密后的信息发给Justin之后，他直接用自己的私钥解密就可以阅读我们想给他传达的信息了（但是我无法演示解密过程，因为我没有Justin的私钥啊，现在这个世界上只有他可以解密这封密信了）。</p>
<h2 id="为了演示解密过程，我们再举一个例子："><a href="#为了演示解密过程，我们再举一个例子：" class="headerlink" title="为了演示解密过程，我们再举一个例子："></a>为了演示解密过程，我们再举一个例子：</h2><p>还是刚刚那个文件，命名为Hi.txt，这次我们用自己的公钥加密（这样我就可以用自己的私钥解密了）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r 刘海博 -e Hi.txt</span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hi.txt.gpg</span><br><span class="line">�`����5��<span class="comment">#MU\���˧4%</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>显然这个生成的Hi.txt.gpg是二进制的，我们再生成一个ASCII的，名称默认为Hi.txt.asc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r 刘海博 -e --armor Hi.txt</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hi.txt.asc</span><br><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQEMA9RdjQJ9ZFOvAQgAhZ0OTp/AVjE+8eLxFUt5W4UM1ZbsiJ0KMB8gAPm+5Lqx</span><br><span class="line">ewOGtRXN2jWkRIuYXi0UKQmv/uTOUXQFDGpmeBtm2dkX+TV54GCdrarxq32soZzk</span><br><span class="line">Kxbvj0ucpiSP/EUsWtNacuThhzgiibxGZq6LlD71t6UZhVC8MtQ7AOi1yeh9cZV9</span><br><span class="line">KCJLH8a81yU6hL+uk8OnOn6RJW6jMaITNpN36k4kbwLbrYAzSkD/m9zEatVE/Jpm</span><br><span class="line">ozYyV9NznAETLZ3i+RcmTAMzP4Ka1R9luwSvNKdHbdEq/jboJZaS2Ye+JLfW38ID</span><br><span class="line">4P00Z91U0JoM64lqVlskzH2zIfZJpj+uLJiskQDw+NKCAbanCIfDqAn/2LYlDoMI</span><br><span class="line">oHRI6Qq58OSYj4iw2OVmzUYQQVLg0s4RsrMKHtLRWc8KR5wcw8pWxD0gdQrTqUEi</span><br><span class="line">tvv9y2c3afhn7AQzDvtIxrQIt/7MS37e4A6Y6f9Ax43rWLmL0198tRuojrwpk6UR</span><br><span class="line">uTF5oyUpJx2VFYUDtVh2JKCzjQ==</span><br><span class="line">=zvVm</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>对于这两个加密的文件（一个Hi.txt.gpg，一个Hi.txt.asc），分别对其进行解密，使用 <code>gpg -d 密文文件名</code> 或者 <code>gpg --decrypt 密文文件名</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hi.txt.asc</span><br><span class="line">gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 7D6453AF、生成于 2016-03-15</span><br><span class="line">  “刘海博 &lt;shininglhb@163.com&gt;”</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hi.txt.gpg</span><br><span class="line">gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 7D6453AF、生成于 2016-03-15</span><br><span class="line">  “刘海博 &lt;shininglhb@163.com&gt;”</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br></pre></td></tr></table></figure>

<p>均成功解密，显示了加密之前的信息。<br>此时，如果我们去解密刚刚用Justin的公钥加密过的文件Hello.txt.asc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hello.txt.asc</span><br><span class="line">gpg: 由 1024 位的 ELG 密钥加密，钥匙号为 59FAB546、生成于 2001-05-25</span><br><span class="line">  “Justin R. Miller &lt;justin@solidlinux.com&gt;”</span><br><span class="line">gpg: 解密失败：没有秘匙</span><br></pre></td></tr></table></figure>

<p>显然失败了，因为我们只有属于自己的私钥，不可能解开别的公钥加密过的文件。<br>现在我们再来考虑一下信任度的设置。之前由于我们未对Justin的公钥进行信任度设置，每次用到Justin的公钥的时候，gpg都会友善的提醒我们，在我们获取此公钥的时候，有可能公钥已经被篡改了，因此此公钥有可能不是Justin本人的。但是如果我们确信这就是Justin的公钥，我们可以对其设置信任度，使用 <code>gpg --edit-key</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --edit-key justin@solidlinux.com</span><br><span class="line">gpg (GnuPG) 2.1.11; Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">gpg&gt; sign</span><br><span class="line">Really sign all text user IDs? (y/N) y</span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"></span><br><span class="line"> Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line"> Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">您真的确定要签名这把密钥，使用您的密钥</span><br><span class="line">“刘海博 &lt;shininglhb@163.com&gt;”(DAEDCB5B)</span><br><span class="line"></span><br><span class="line">真的要签名吗？(y/N)y</span><br><span class="line"></span><br><span class="line">gpg&gt; trust</span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">您是否相信这位用户有能力验证其他用户密钥的有效性(查对身份证、通过不同的渠道检查</span><br><span class="line">指纹等)？</span><br><span class="line"></span><br><span class="line">  1 = 我不知道或我不作答</span><br><span class="line">  2 = 我不相信</span><br><span class="line">  3 = 我勉强相信</span><br><span class="line">  4 = 我完全相信</span><br><span class="line">  5 = 我绝对相信</span><br><span class="line">  m = 回到主菜单</span><br><span class="line"></span><br><span class="line">您的决定是什么？5</span><br><span class="line">您真的要把这把密钥设成绝对信任？(y/N)n</span><br><span class="line">您的决定是什么？4</span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：完全        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">请注意，在您重启程序之前，显示的密钥有效性未必正确，</span><br><span class="line"></span><br><span class="line">gpg&gt; quit</span><br><span class="line">要保存变动吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>之后再查看公钥列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --list-keys</span><br><span class="line">gpg: 正在检查信任度数据库</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: PGP</span><br><span class="line">gpg: 深度：0 有效性：  1 已签名：  1 信任度：0-，0q，0n，0m，0f，1u</span><br><span class="line">gpg: 深度：1 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，1f，0u</span><br><span class="line">/home/lgl/.gnupg/pubring.kbx</span><br><span class="line">----------------------------</span><br><span class="line">pub   rsa2048/DAEDCB5B 2016-03-15 [SC]</span><br><span class="line">uid         [ 绝对 ] 刘海博 &lt;shininglhb@163.com&gt;</span><br><span class="line">sub   rsa2048/7D6453AF 2016-03-15 [E]</span><br><span class="line"></span><br><span class="line">pub   dsa1024/C9C40C31 2001-05-25 [SCA]</span><br><span class="line">uid         [ 完全 ] Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">uid         [ 完全 ] Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">sub   elg1024/59FAB546 2001-05-25 [E]</span><br></pre></td></tr></table></figure>

<p>原来Justin的公钥之前显示的[未知]已经变成我们设置的[完全]了。我们可以发现我们自己的公钥被默认设置为绝对信任，这显然是必须的，也是肯定正确的。我们还可以发现修改完信任度之后再查询公钥时，gpg会先查询信任度数据库，这说明这些信任信息不是存在储存钥匙的文件里，而是存在另一个文件里的。</p>
<h2 id="最后，我们说一下签名："><a href="#最后，我们说一下签名：" class="headerlink" title="最后，我们说一下签名："></a>最后，我们说一下签名：</h2><p>为避免 “别人宣称是你” 这样的风险，对所有你加密的东西签名是有用的。签名的意义在于两个方面：Authenticity(身份认证)和Integrity(数据完整性)。即数字签名可以证明数据是你发送的，并同时证明发送的内容未曾被别人修改过。<br>签名的命令为 <code>gpg -s [Data]</code> 或者 <code>gpg --sign [Data]</code> 。这样做的时候，同时数据也被压缩。也就是说，最终结果是无法直接读懂的。若你想要一个能直接读懂的结果，你可以用 <code>gpg --clearsign [Data]</code> ，这样就能保证结果是清晰可读的。同时它也照样对数据签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -s Hi.txt</span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --clearsign Hi.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实也可以对加密后的信息进行签名</span></span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --clearsign Hi.txt.asc</span><br></pre></td></tr></table></figure>

<p>上面两条命令分别生成了Hi.txt.gpg和Hi.txt.asc两个文件。<br>需要注意的是，刚刚的签名自然是签的我们自己的名，所以用的是我们自己的私钥，需要用我们自己的公钥认证签名 <code>gpg --verify 签名文件</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.asc</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.gpg</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:18 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>两个文件均验证为正确，说明这两个文件是“刘海博”签的名。<br>用 <code>gpg -b (--detach-sign) [Data]</code>，还可以将签名写进另一个文件。我们高度推荐这种用法，尤其是对二进制文件（如文档）签名的时候。另外，<code>--armor</code> 选项在这儿也非常有用。<br>签名后的文件，我们还可以使用解密来读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -d Hi.txt.asc</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>可以看到区别就在与 <code>verify</code> 只显示认证的结果，而 <code>decrypt</code> 同时也显示出了原数据的内容。<br>如果这个时候我们对认证后的动动手脚，修改一些内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.asc</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 已损坏的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -d Hi.txt.asc</span><br><span class="line">Hello, I am Liu Haibdddddo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 已损坏的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>可以看出签名的第二个功能生效了，我们可以根据签名验证文件内容是否被修改。<br>有趣的是，如果再把修改过后的内容修改回去，则认证又会再次通过。这也说明了签名的确就是对整个文件的内容进行Hash产生的。<br>而且，不管什么样的文件，签名的时候只是单纯的在文件内容前后添加头尾，即以下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA256</span><br><span class="line"></span><br><span class="line">// 此处为原文件内容或者是加密后的密文</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line">// 此处为加密后的签名信息</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure>

<h2 id="为什么要先签名后加密？"><a href="#为什么要先签名后加密？" class="headerlink" title="为什么要先签名后加密？"></a>为什么要先签名后加密？</h2><p>答：<br>主要是为了抵御中间人攻击和公钥伪造。<br>比如Alice要发送信息给Bob。</p>
<p>1）如果Alice与Bob之间交换公钥没有其他任何人截获，那先加密再签名也没事。因为Bob明确地知道Alice的公钥只有自己才有，只要有人篡改信息，Bob这边验证就会失败。<br>2）如果Alice与Bob通过网络传递公钥，可能中间人Eve会截获他们的公钥。此时Eve有Alice的公钥，他可以解密文件中的签名信息，然后用自己的私钥签名文件内容来冒充Alice（从上文的内容可看到先加密后签名生成的文件签名部分与原文内容部分是分开的），Eve很容易用自己的假签名替换Alice的签名。然后Eve再把自己的公钥传递给Bob，在Bob收到文件后，用假公钥进行了验证却把假公钥误认为是Alice。</p>
<p>但是，如果先签名后加密，那么原文内容和签名信息是合在一起被加密的。即使Eve截获文件，也无法解密内容来替换成假签名。因为只有Bob才有私钥可以解密文件。但这样还是无法避免Alice和Bob交换公钥时被Eve截获然后冒充。</p>
<p>因此，更安全的办法是：<br>Alice对自己的公钥也进行签名，GnuPG默认就是这么做的。签名后就会有一个公钥的指纹。Alice把自己公钥的指纹放在一个十分安全且无法被篡改的地方。Bob拿到Alice的公钥后，读取公钥指纹，然后去这个十分安全的地方对照指纹是不是一样，从而确定这个公钥是不是真的属于Alice。</p>
<p>要做到既加密又签名，完整的命令行大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg [-u Sender] [-r Recipient] [--armor] --sign --encrypt [Data]</span><br></pre></td></tr></table></figure>

<h2 id="最后说一下密钥迁移的问题："><a href="#最后说一下密钥迁移的问题：" class="headerlink" title="最后说一下密钥迁移的问题："></a>最后说一下密钥迁移的问题：</h2><p>如果我们现在想换电脑，无疑我们需要把之前的公钥和自己的私钥全部都导出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span> puppylpg &gt; puppylpg.public</span><br><span class="line">gpg --<span class="built_in">export</span>-secret-key puppylpg &gt; puppylpg.private</span><br></pre></td></tr></table></figure>

<p>我们将puppylpg的两个密钥导出成为两个文件，之后再导入另一个电脑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import puppylpg.public</span><br><span class="line">gpg --allow-secret-key-import --import puppylpg.private</span><br></pre></td></tr></table></figure>

<p>注意导入私钥的时候需要添加 <code>--allow-secret-key-import</code> 给予允许添加私钥的权限，并且也不能遗漏 <code>--import</code> 参数。</p>
<p>即便用导出密钥的方式来备份密钥，主机系统上的 GPG 密钥仍有被盗的风险。为了获得最佳安全性，可以使用 USB 类型的智能卡配合 GPG 从而保护密钥。这样的智能卡有 <code>Nitrokey Pro</code> 和 <code>Yubikey 4</code> 等等。查看下面链接获取这些智能卡的使用详情：</p>
<p><a href="https://zh.wikipedia.org/wiki/YubiKey" target="_blank" rel="noopener">Yubikey Wiki</a><br><a href="https://www.jebbs.co/2017/01/20/use-gpg-with-smart-card/" target="_blank" rel="noopener">在 GPG 中使用智能卡</a><br><a href="http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html" target="_blank" rel="noopener">Yubikey 4 简介与配置</a><br><a href="https://mechanus.io/ke-neng-shi-zui-hao-de-yubikey-gpg-ssh-zhi-neng-qia-jiao-cheng/" target="_blank" rel="noopener">可能是最好的 Yubikey + GPG/SSH 智能卡教程</a></p>
<p>参考：</p>
<blockquote>
<p>原文：<a href="https://blog.csdn.net/puppylpg/article/details/50901779" target="_blank" rel="noopener">https://blog.csdn.net/puppylpg/article/details/50901779</a><br>参考：<a href="http://blog.csdn.net/puppylpg/article/details/50899484" target="_blank" rel="noopener">http://blog.csdn.net/puppylpg/article/details/50899484</a><br>参考：<a href="http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html" target="_blank" rel="noopener">http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Gpg</tag>
        <tag>Encryption</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GPG 密钥登录 SSH</title>
    <url>/2019/02/03/login-ssh-via-gpg-key.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SSH 通常有密码登录和密钥登录两种方式。密钥登录时使用的是 SSH 的密钥，由 ssh-agent 来处理。这里介绍使用 GnuPG 生成的 PGP 密钥来登录 SSH。此时使用 gpg-agent 来处理登录过程。</p>
<p>使用 GPG 密钥登录的好处是便于管理服务器。只要把 GPG 密钥的公钥放到服务器上面，用同一个密钥可以登录所有这些服务器。还有，GnuPG 可以使用智能卡来保存密钥，使 SSH 密钥更加安全。</p>
<p><strong>注意：</strong></p>
<p>这篇文章使用 Ubuntu 18.04，并使用 GnuPG v2.2.X 来演示，小于 v2.2.X 的版本下文某些命令可能是无效的。运行如下命令查看版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --version</span><br></pre></td></tr></table></figure>

<h2 id="生成-GnuPG-密钥并添加认证密钥"><a href="#生成-GnuPG-密钥并添加认证密钥" class="headerlink" title="生成 GnuPG 密钥并添加认证密钥"></a>生成 GnuPG 密钥并添加认证密钥</h2><p>快速生成 GnuPG 密钥的方法详见 <a href="https://he.izhaojie.com/2019/01/09/learn-asymmetric-encryption-by-gpg.html" target="_blank" rel="noopener">这里</a></p>
<p>分步生成 GnuPG 密钥的方法详见：</p>
<ol>
<li><a href="https://linux.cn/article-9529-1.html" target="_blank" rel="noopener">生成主密钥</a></li>
<li><a href="https://linux.cn/article-9607-1.html" target="_blank" rel="noopener">生成认证密钥等子密钥</a></li>
</ol>
<p>生成属于自己的一对密钥后，再向这个密钥中添加一个认证密钥[A]。</p>
<a id="more"></a>

<p>最后，密钥看起来像下面这样。[A] 子密钥用于认证，即用于 SSH 登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --list-key 0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">pub   rsa4096 2019-XX-XX [C] [有效至：20XX-XX-XX]</span><br><span class="line">      0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">uid           [ 绝对 ] Jason &lt;example@example.com&gt;</span><br><span class="line">sub   rsa4096 2019-01-15 [E]</span><br><span class="line">sub   rsa4096 2019-01-15 [A]</span><br><span class="line">sub   rsa4096 2019-01-15 [S]</span><br></pre></td></tr></table></figure>

<h2 id="设置用于-SSH-登录"><a href="#设置用于-SSH-登录" class="headerlink" title="设置用于 SSH 登录"></a>设置用于 SSH 登录</h2><h3 id="配置-gpg-agent-选项"><a href="#配置-gpg-agent-选项" class="headerlink" title="配置 gpg-agent 选项"></a>配置 gpg-agent 选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.gnupg/gpg-agent.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入下面三行</span></span><br><span class="line"><span class="comment"># 三行分别表示</span></span><br><span class="line"><span class="comment"># 输入一次 GPG 密码后，600 秒内不用重复输入，600 秒内再次使用密码会重置这个时间</span></span><br><span class="line"><span class="comment"># 从首次输入密码算起，不管最近一次使用密码是什么时间，只要最大 TTL 过期，就需要重新输入密码</span></span><br><span class="line"><span class="comment"># 启用 SSH 支持</span></span><br><span class="line"></span><br><span class="line">default-cache-ttl 600</span><br><span class="line">max-cache-ttl 7200</span><br><span class="line"><span class="built_in">enable</span>-ssh-support</span><br></pre></td></tr></table></figure>

<h3 id="修改-bashrc-文件"><a href="#修改-bashrc-文件" class="headerlink" title="修改 .bashrc 文件"></a>修改 .bashrc 文件</h3><p>让 ssh 与 gpg-agent 通信，而不是 ssh-agent。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 .bashrc 文件末尾添加如下一行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)</span><br></pre></td></tr></table></figure>

<p>为了使更改生效，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall gpg-agent</span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<h3 id="获取认证密钥的-keygrip"><a href="#获取认证密钥的-keygrip" class="headerlink" title="获取认证密钥的 keygrip"></a>获取认证密钥的 keygrip</h3><p>为了告诉 gpg-agent 应该使用哪个认证子密钥，需要先获取认证子密钥的 keygrip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录下认证子密钥的 keygrip</span></span><br><span class="line"><span class="comment"># 下面的结果中 keygrip 就是</span></span><br><span class="line"><span class="comment"># 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC</span></span><br><span class="line"></span><br><span class="line">$ gpg --with-keygrip --list-key 0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">...</span><br><span class="line">sub   rsa4096 2019-01-15 [A]</span><br><span class="line">      Keygrip = 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 keygrip</span></span><br><span class="line"><span class="built_in">echo</span> 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC &gt;&gt; ~/.gnupg/sshcontrol</span><br></pre></td></tr></table></figure>

<h3 id="列出-SSH-格式的-GPG-认证密钥的公钥"><a href="#列出-SSH-格式的-GPG-认证密钥的公钥" class="headerlink" title="列出 SSH 格式的 GPG 认证密钥的公钥"></a>列出 SSH 格式的 GPG 认证密钥的公钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面命令会列出 GPG 认证密钥的公钥</span></span><br><span class="line">ssh-add -L</span><br></pre></td></tr></table></figure>

<p>把列出的公钥，放到服务器上的文件 ~/.ssh/authorized_keys 里，就能通过 GPG 来使用 SSH 登录远程主机了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行如下命令测试是否能成功登入远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p port username@remote_ip</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Gpg</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统实战：实验环境搭建、热门问题解答</title>
    <url>/2021/05/18/os-experiment-environment-and-faq.html</url>
    <content><![CDATA[<p>本系列文章是《操作系统实战45讲》课程学习过程中的心得体会与问题汇总。</p>
<p>系列文章放入「<strong>操作系统实战</strong>」分类里。如果对你有帮助，欢迎关注我。</p>
<p><strong>如果你也想一起写一个属于自己的操作系统，直接翻到文末查看</strong>。</p>
<p>话不多说，现在进入正题。本文分为两个部分：一、实验环境搭建。二、前4节课遇到的问题与解答。</p>
<h2 id="实验环境搭建"><a href="#实验环境搭建" class="headerlink" title="实验环境搭建"></a>实验环境搭建</h2><p>1、一台电脑。电脑上装有Windows或MacOS系统。我用的是MacOS系统。</p>
<p>2、虚拟机。我选择的是VMware Fusion 12（若是Windows，装个最新版VMware即可）。</p>
<p>3、Ubuntu/CentOS系统。我选择的是Ubuntu，作为虚拟机系统，用来实现自己的操作系统。</p>
<h3 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h3><ol>
<li><p>安装好虚拟机软件VMware，基本都是点下一步，下一步，直到安装完成。</p>
</li>
<li><p>从 <a href="http://mirrors.ustc.edu.cn/ubuntu-releases/20.04/ubuntu-20.04.2.0-desktop-amd64.iso" target="_blank" rel="noopener">这里</a>[1] 下载Ubuntu 20.04系统安装文件，是一个iso文件。</p>
</li>
<li><p>在VMware里创建一个新的虚拟机，用来安装Ubuntu 20.04系统：</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/vmware-new-os.png" alt="新建虚拟机"></p>
<p>选择新建，后面的步骤比较简单，跟着提示做就可以了。</p>
<a id="more"></a>

<p><strong>记得Ubuntu需要分配至少1G的内存，不然可能无法正常启动Ubuntu。</strong></p>
<ol start="4">
<li>安装完Ubuntu 20.04后，登录系统，在Ubuntu系统里安装工具（以后我们自己写的系统就叫HelloOS）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 按下 Control+Option+T 组合键打开一个终端（Windows下是 Control+Alt+T）</span></span><br><span class="line"><span class="comment"># 在终端里输入如下命令行，并按 回车，开始执行</span></span><br><span class="line"><span class="comment"># gcc是编译工具集，包含了C语言编译器等。nasm是Ubuntu下的汇编器。</span></span><br><span class="line">sudo apt install -y gcc nasm</span><br></pre></td></tr></table></figure>

<p>截图如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E4%B9%8C%E7%8F%AD%E5%9B%BE%E4%B8%AD%E5%AE%89%E8%A3%85%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7.png" alt="安装编译工具"></p>
<ol start="5">
<li>克隆HelloOS的源代码并编译（下面的命令继续在Ubuntu终端里执行）：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install -y git  <span class="comment"># 安装git工具</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/lmos/cosmos  <span class="comment"># 克隆源代码</span></span><br><span class="line"><span class="built_in">cd</span> cosmos/lesson02/HelloOS/  <span class="comment"># 进入源码目录</span></span><br><span class="line">make  <span class="comment"># 编译HelloOS内核文件HelloOS.bin</span></span><br><span class="line">sudo cp HelloOS.bin /boot/HelloOS.bin  <span class="comment"># 拷贝内核文件到grub的引导分区里</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>添加grub启动项，用来启动我们的HelloOS：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编辑grub的配置文件</span></span><br><span class="line">sudo vim /boot/grub/grub.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在键盘上依次按下：</span></span><br><span class="line"><span class="built_in">shift</span> + g + o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把下面内容粘贴到文末</span></span><br><span class="line"><span class="comment">#### BEGIN HelloOS.bin ####</span></span><br><span class="line">menuentry <span class="string">'HelloOS'</span> &#123;</span><br><span class="line">     insmod part_msdos <span class="comment">#GRUB加载分区模块识别分区</span></span><br><span class="line">     insmod ext2 <span class="comment">#GRUB加载ext文件系统模块识别ext文件系统</span></span><br><span class="line">     <span class="built_in">set</span> root=<span class="string">'hd0,msdos1'</span> <span class="comment">#注意boot目录挂载的分区，这是我机器上的情况</span></span><br><span class="line">     multiboot2 /boot/HelloOS.bin <span class="comment">#GRUB以multiboot2协议加载HelloOS.bin</span></span><br><span class="line">     boot <span class="comment">#GRUB启动HelloOS.bin</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#### End /boot/HelloOS.bin ####</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在键盘上依次按下，然后回车，添加的内容就保存好了：</span></span><br><span class="line">esc + <span class="built_in">shift</span> + ; + wq!</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在终端重启系统，输入：</span></span><br><span class="line">reboot</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>重启Ubuntu系统后，在系统启动项菜单里选择 HelloOS（上下箭头选择HelloOS，然后按回车启动它）：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E9%80%89%E6%8B%A9HelloOS%E5%90%AF%E5%8A%A8.png" alt="启动HelloOS"></p>
<ol start="8">
<li>启动成功后，如下图所示（HelloOS还没重启代码，要回到Ubuntu，直接重启虚拟机，选上图的第一项来启动）：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/HelloOS%E5%90%AF%E5%8A%A8%E6%88%90%E5%8A%9F.png" alt="启动成功"></p>
<h2 id="问题与解答"><a href="#问题与解答" class="headerlink" title="问题与解答"></a>问题与解答</h2><h3 id="1、为什么没有出现引导菜单，让我选择HelloOS来启动？"><a href="#1、为什么没有出现引导菜单，让我选择HelloOS来启动？" class="headerlink" title="1、为什么没有出现引导菜单，让我选择HelloOS来启动？"></a>1、为什么没有出现引导菜单，让我选择HelloOS来启动？</h3><p>首先，什么是引导菜单？请看上文步骤7中的截图。</p>
<p>答：这与grub的设置有关，菜单项可能隐藏了，按如下操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入Ubuntu系统后，进入终端（还记得吗，可以按 Ctrl+Opt+T/Ctrl+Alt+T启动终端）</span></span><br><span class="line"><span class="comment"># 输入命令编辑grub配置文件</span></span><br><span class="line">sudo vim /etc/default/grub</span><br></pre></td></tr></table></figure>

<p>把红框的3行，修改成如下图所示（没有的行就加上）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E8%AE%BE%E7%BD%AEgrub%E9%85%8D%E7%BD%AE.png" alt="设置grub"></p>
<p>然后更新grub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行命令</span></span><br><span class="line">sudo update-grub2</span><br></pre></td></tr></table></figure>

<p>更新后，需要重新添加HelloOS的引导项到grub.cfg文件。见上文步骤6、步骤7。</p>
<h3 id="2、重启选择HelloOS启动后显示-error-file-boot-HelloOS-bin’-not-found"><a href="#2、重启选择HelloOS启动后显示-error-file-boot-HelloOS-bin’-not-found" class="headerlink" title="2、重启选择HelloOS启动后显示 error: file `/boot/HelloOS.bin’ not found."></a>2、重启选择HelloOS启动后显示 error: file `/boot/HelloOS.bin’ not found.</h3><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/HelloOS.bin%E6%9C%AA%E6%89%BE%E5%88%B0.png" alt="HelloOS.bin未找到"></p>
<p>答：这与boot分区是否独立有关。重新进入Ubuntu系统，打开终端（步骤见上文），执行命令：df /boot /</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/boot%E7%8B%AC%E7%AB%8B%E5%88%86%E5%8C%BA.png" alt="boot独立分区"></p>
<p>如上，文件系统（Filesystem）一列，两行内容不一样，/boot在/dev/sda1，那就把/boot/grub/grub.cfg文件里的 <code>multiboot2 /boot/HelloOS.bin</code> 改成 <code>multiboot2 /HelloOS.bin</code>，保存文件。然后重启系统，选择HelloOS启动。</p>
<h3 id="3、重启选择HelloOS启动后显示-error-disk-hd0-msdos2’-not-found-之类的错误"><a href="#3、重启选择HelloOS启动后显示-error-disk-hd0-msdos2’-not-found-之类的错误" class="headerlink" title="3、重启选择HelloOS启动后显示 error: disk `hd0,msdos2’ not found. 之类的错误"></a>3、重启选择HelloOS启动后显示 error: disk `hd0,msdos2’ not found. 之类的错误</h3><p>答：可能是在你的Ubuntu系统上，msdos2这个分区不存在。或者你用了gpt分区，如何查看？执行如下命令：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E6%9F%A5%E7%9C%8Bgpt%E5%88%86%E5%8C%BA.png" alt="查看是否为gpt分区方案"></p>
<p>如果是gpt分区，那就修改grub.cfg文件，把 <code>insmod part_msdos</code> 改为 <code>insmod part_gpt</code>，保存文件。然后重启选HelloOS启动。</p>
<h3 id="4、我用的是CentOS7，为什么没有成功？"><a href="#4、我用的是CentOS7，为什么没有成功？" class="headerlink" title="4、我用的是CentOS7，为什么没有成功？"></a>4、我用的是CentOS7，为什么没有成功？</h3><p>答：基本步骤与Ubuntu一样，几乎无差别。但有的人开机遇到了黑屏，没有显示<code>Hello OS!</code>。还有的人，虚拟机显示了CPU禁止。我是这么做的：修改 <code>grub.cfg</code> 文件，把HelloOS启动项里的 <code>multiboot2</code> 改为 <code>multiboot</code>，保存文件。重启系统，再进入HelloOS看看。</p>
<hr>
<p>本文源自 <strong>极客时间《操作系统实战45讲》</strong> 学习过程中的心得与问题汇总，欢迎扫码加入。</p>
<p>此课程的一系列文章，我都会放到「操作系统实战」分类。<strong>如果对你有帮助，可以关注我，一起学习进步</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-OS%E5%AE%9E%E6%88%98%E5%88%86%E4%BA%AB.jpeg" alt="操作系统实战45讲"></p>
<p>参考：</p>
<p>[1] <a href="http://mirrors.ustc.edu.cn/ubuntu-releases/20.04/ubuntu-20.04.2.0-desktop-amd64.iso" target="_blank" rel="noopener">http://mirrors.ustc.edu.cn/ubuntu-releases/20.04/ubuntu-20.04.2.0-desktop-amd64.iso</a></p>
]]></content>
      <categories>
        <category>操作系统实战</category>
      </categories>
      <tags>
        <tag>操作系统实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用总结 01</title>
    <url>/2018/12/21/pro-git-summary-1.html</url>
    <content><![CDATA[<h2 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h2><blockquote>
<p>下文的所有命令都在普通用户下执行，因此有些命令前会有 <code>$</code> 号，系统是 <code>Debian 9.6</code>，Git 版本是 <code>git version 2.11.0</code>。本文参考：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git v2 CHS</a> 的第1章，第2章。</p>
</blockquote>
<h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>已提交（committed）、已修改（modified）、已暂存（staged）</p>
<h3 id="工作区的三个概念"><a href="#工作区的三个概念" class="headerlink" title="工作区的三个概念"></a>工作区的三个概念</h3><p>有三种状态，相应的就有三个概念：Git 仓库、工作目录、暂存区域</p>
<p>已提交对应 Git 仓库，已修改对应工作目录，已暂存对应暂存区域。</p>
<h3 id="Git-的基本工作流程"><a href="#Git-的基本工作流程" class="headerlink" title="Git 的基本工作流程"></a>Git 的基本工作流程</h3><p>① 修改文件：在工作目录中修改文件。<br>② 暂存文件：将文件的快照放入暂存区域。<br>③ 提交更新：找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
<p>Git 不像其他版本管理系统，比较文件的差异并记录下来，Git 是直接记录文件的快照。因此 Git 更像是一个小型的文件系统，它把数据看作是对小型文件系统的一组快照。文件系统快照可以理解成是，对文件或目录的修改（不论是增，删，改）记录快照，下次就能恢复到原样。它恢复的信息是很全面的，不仅有文件的数据，还可以有文件或目录的元数据，比如创建时间，修改时间等等。</p>
<a id="more"></a>

<h2 id="在-Linux-上安装-Git"><a href="#在-Linux-上安装-Git" class="headerlink" title="在 Linux 上安装 Git"></a>在 Linux 上安装 Git</h2><p>Redhat 系或 Debian 系安装方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">sudo yum install git</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h2 id="Git-的三个配置文件"><a href="#Git-的三个配置文件" class="headerlink" title="Git 的三个配置文件"></a>Git 的三个配置文件</h2><p>① <code>/etc/gitconfig</code>：系统级全局配置文件，对所有用户有效。使用带有 <code>--system</code> 选项的 <code>git config</code> 时，会读写此配置文件。<br>② <code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：当前用户的配置文件。传递 <code>--global</code> 选项可以读写此文件。<br>③ <code>.git/config</code>：当前仓库 Git 目录中的配置文件，针对该仓库。传递 <code>--local</code> 选项可以读写此文件。</p>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<h2 id="设置-Git-的用户信息和文本编辑器"><a href="#设置-Git-的用户信息和文本编辑器" class="headerlink" title="设置 Git 的用户信息和文本编辑器"></a>设置 Git 的用户信息和文本编辑器</h2><p>相关命令：<code>git config</code></p>
<p>安装完 Git 的第一件事是设置用户名和邮件地址。每个 Git 提交都会使用这些信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置用户名和邮件地址</span></span><br><span class="line">git config --global user.name <span class="string">"JasonZh"</span></span><br><span class="line">git config --global user.email <span class="string">"example@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 git 默认使用的文本编辑器</span></span><br><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>

<p>查看 Git 的配置信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认会依次读取 /etc/ 下，~/ 下的配置文件</span></span><br><span class="line"><span class="comment"># 如果处于 Git 仓库目录中，还会读取 .git/ 下的配置文件</span></span><br><span class="line"><span class="comment"># 所以配置的生效优先级是 ".git/" &gt; "~/" &gt; "/etc/"</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某一项配置</span></span><br><span class="line">git config user.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定配置文件的配置项</span></span><br><span class="line"><span class="comment"># 仅查看全局配置项</span></span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅查看当前用户配置项</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处于特定仓库目录内时</span></span><br><span class="line"><span class="comment"># 仅查看特定仓库的配置项</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure>

<h2 id="获取-Git-帮助"><a href="#获取-Git-帮助" class="headerlink" title="获取 Git 帮助"></a>获取 Git 帮助</h2><p>有三种获取 Git 帮助的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> config</span><br><span class="line">git config --<span class="built_in">help</span></span><br><span class="line">man git-config</span><br></pre></td></tr></table></figure>

<h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>相关命令：<code>git init</code>, <code>git clone</code></p>
<p>有两种方法可以获取 Git 仓库：</p>
<p>① 初始化一个仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设把目录 test 当作 Git 仓库，先进入 test 目录，然后执行，完了会在目录里生成 .git 子目录，这是 Git 仓库的骨干目录</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>② 克隆现有仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库克隆</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆并且重命名仓库名为 mylibgit</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>

<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>命令：<code>git status</code></p>
<p>下面以 libgit2 仓库为例。如果克隆仓库后，进入该仓库目录，立即运行如下命令，会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新加一个文件，默认它处于 未跟踪（Untracked files） 状态，Git 不会自动跟踪新添加的文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次检查当前文件状态，新加的文件处于 未跟踪 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure>

<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>把新添加的文件加到 Git 跟踪，使用 <code>git add</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候文件会处于 被跟踪（Changes to be committed） 状态，并且处于暂存状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>

<h3 id="注意-和-的区别"><a href="#注意-和-的区别" class="headerlink" title="注意 * 和 . 的区别"></a>注意 <code>*</code> 和 <code>.</code> 的区别</h3><p>① <code>git add *</code>：</p>
<p>添加所有文件到暂存区域。包括当前工作目录内所有子孙目录内的 . 开头的隐藏文件。但是不包括当前工作目录下的 . 开头的隐藏文件。</p>
<p>② <code>git add .</code>：</p>
<p>添加所有文件到暂存区域。同时包括当前工作目录下的隐藏文件。也就是说，用 <code>.</code> 号可以包含所有未暂存的文件。</p>
<h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><p>如果修改一个已被跟踪的文件，怎么暂存它呢，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如修改文件 README.md，这个文件之前处于已跟踪状态</span></span><br><span class="line"><span class="comment"># 修改后，这个文件处于 未暂存（Changes not staged for commit） 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>

<p>暂存已经修改的被跟踪的文件，还是运行 <code>git add</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看状态，此时文件 README.md 处于 已暂存（Changes to be commited） 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>

<h2 id="Git-状态预览"><a href="#Git-状态预览" class="headerlink" title="Git 状态预览"></a>Git 状态预览</h2><p>上面用的 <code>git status</code> 命令会显示比较详细的信息，加 <code>-s</code> 或 <code>--short</code> 选项可以显示简短的文件状态：</p>
<img src="/2018/12/21/pro-git-summary-1/git-status-s.PNG" class="" title="git-status-s">

<h3 id="简短格式显示状态时，有6种情况"><a href="#简短格式显示状态时，有6种情况" class="headerlink" title="简短格式显示状态时，有6种情况"></a>简短格式显示状态时，有6种情况</h3><p>① <code>??</code> 开头：新添加的，但未跟踪的文件；或者是移出暂存区变成未跟踪状态的文件<br>② <code>A</code> 开头：新添加的，且已加到暂存区中的文件，即新添加且已跟踪的文件<br>③ <code>M_</code>：左侧的 M，已被跟踪的文件，修改过，且已加入到暂存区<br>④ <code>_M</code>：右侧的 M，已被跟踪的文件，修改过，但还未加到暂存区<br>⑤ <code>MM</code>：已被跟踪的文件，修改过并且已加到暂存区，但之后又修改了<br>⑥ <code>AM</code>：新添加的文件，已加到暂存区，但之后又修改了</p>
<p>正常格式 vs 简短格式：</p>
<img src="/2018/12/21/pro-git-summary-1/git-status.PNG" class="" title="git-status">

<h3 id="正常格式显示状态时，有-3-大类情况"><a href="#正常格式显示状态时，有-3-大类情况" class="headerlink" title="正常格式显示状态时，有 3 大类情况"></a>正常格式显示状态时，有 3 大类情况</h3><p>① Changes to be committed：已暂存正等待提交的（即已跟踪，已暂存，等待提交的）<br>② Changes not staged for commit：已跟踪，但未暂存的（这种情况不会提交）<br>③ Untracked files：未跟踪的文件（可以是新建的文件，或把已跟踪的文件设为未跟踪，这种情况不会提交）</p>
<p>注意：<br>1、一个文件可以同时处于 情况① 与 情况② 下面。<br>2、一个文件的三大类情况组合起来的所有情况就是简短格式的6种情况。</p>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>如果需要忽略一些文件，不想加入 Git 的管理，比如编译程序产生的一些中间文件，就没必要提交到 Git。可以创建 <code>.gitignore</code> 文件排除这些文件。Git 仓库创建之初，就创建一个 .gitignore 文件是个很好的习惯。</p>
<p>文件 <code>.gitignore</code> 的格式：<br>1、以 <code>#</code> 开头都是注释<br>2、可以使用通配符 <code>*</code>, <code>?</code>, <code>[]</code>, <code>**</code><br>3、以 <code>/</code> 开头防止递归<br>4、以 <code>/</code> 结尾用于指定目录<br>5、以 <code>!</code> 开头指定例外文件或目录，即强制不被忽略的文件或目录</p>
<p>看看 .gitignore 文件的实际例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 匹配零个或多个任意字符</span></span><br><span class="line"><span class="comment"># 即以 ~ 结尾的文件都被忽略</span></span><br><span class="line"><span class="comment"># 默认会递归地排除仓库目录内所有子孙目录内的文件</span></span><br><span class="line">*~</span><br><span class="line"></span><br><span class="line"><span class="comment"># [oa] 匹配字符 o 或者字符 a</span></span><br><span class="line"><span class="comment"># 即 *.o 或 *.a 文件都被忽略</span></span><br><span class="line">*.[oa]</span><br><span class="line"></span><br><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you're ignoring .a files above</span></span><br><span class="line"><span class="comment"># 添加例外，上面规则排除了 *.a，但 lib.a 不会被排除</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line"><span class="comment"># 仅排除直接子目录下的 TODO 文件，不递归子孙目录</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line"><span class="comment"># 这个目录是仓库目录内的直接子目录，这个目录被排除，则这个目录内的全部内容也就被排除了</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line"><span class="comment"># ** 表示任意中间目录，包括空字符串</span></span><br><span class="line"><span class="comment"># 比如 a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z 等文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看未暂存的文件修改的部分</span></span><br><span class="line"><span class="comment"># 此命令比较当前未暂存文件和暂存区域快照之间的差异</span></span><br><span class="line"><span class="comment"># 注意 diff 命令都是以 "行" 作为文件修改的最小单位</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前已暂存文件与已提交文件之间的差异</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他差异比较工具</span></span><br><span class="line">git difftool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统支持的 diff 工具</span></span><br><span class="line">git difftool --tool-help</span><br></pre></td></tr></table></figure>

<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意提交之前先把未暂存的文件暂存起来</span></span><br><span class="line"><span class="comment"># git add &lt;file&gt;</span></span><br><span class="line"><span class="comment"># 然后看看当前的文件状态</span></span><br><span class="line"><span class="comment"># git status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式提交</span></span><br><span class="line"><span class="comment"># 这种方式会启动文本编辑器以便输入本次提交的说明</span></span><br><span class="line"><span class="comment"># 执行 git config --global core.editor &lt;editor&gt; 设定文本编辑器</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接命令行提交</span></span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的提交命令会提交所有已暂存但未提交的文件</span></span><br><span class="line"><span class="comment"># 也可以提交指定的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意提交指定文件会跳过 git add 步骤</span></span><br><span class="line"><span class="comment"># 比如 README 是已跟踪但未提交的文件，就会把 README 文件也一并提交</span></span><br><span class="line">git commit -m <span class="string">"message"</span> COPYING README</span><br></pre></td></tr></table></figure>

<h2 id="跳过暂存步骤直接提交"><a href="#跳过暂存步骤直接提交" class="headerlink" title="跳过暂存步骤直接提交"></a>跳过暂存步骤直接提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -a 选项告诉 commit 命令自动把已跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span></span><br><span class="line">git commit -a -m <span class="string">'message'</span></span><br></pre></td></tr></table></figure>

<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>① 移除并删除：<br>移出暂存区域，并从当前仓库目录中删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除已暂存的文件，并从仓库目录中删除此文件，此文件就不会出现在未跟踪列表里了</span></span><br><span class="line">git rm README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果移除已暂存并且之后又修改过的文件，需要用 -f 强制删除</span></span><br><span class="line"><span class="comment"># 这样强制删除的数据不能被 Git 恢复，因为修改的部分没有提交，所以不建议这样做！</span></span><br><span class="line">git rm -f README.md</span><br></pre></td></tr></table></figure>

<p>② 仅移除：<br>仅仅移出暂存区域，但不删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅仅移出暂存区域，让文件变成未跟踪状态，但文件还留在当前工作目录中</span></span><br><span class="line">git rm --cached package.json</span><br></pre></td></tr></table></figure>

<p>③ 使用通配符：<br>注意 Git 有自己的模式扩展匹配方式，为了防止 shell 干扰，用反斜杠转义或用单引号括起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 log 目录下的所有 *.log 文件（递归地删除 log 目录内所有子孙目录内的 *.log）</span></span><br><span class="line">git rm <span class="string">'log/*.log'</span></span><br></pre></td></tr></table></figure>

<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。所以，应该用 Git 的移动命令 <code>git mv</code>。与 <code>git rm</code> 一样，<code>git mv</code> 只能操作（重命名）已暂存的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动已暂存的文件，实际上是重命名</span></span><br><span class="line">git mv COPYING COPYING1</span><br></pre></td></tr></table></figure>

<p>执行 <code>git mv</code> 等价于执行如下三个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv COPYING COPYING1</span><br><span class="line">git rm COPYING</span><br><span class="line">git add COPYING1</span><br></pre></td></tr></table></figure>

<p>你可能会奇怪，Git 是怎么知道文件被移动了，别忘了 Git 跟踪的是文件内容的哈希，不是简单的文件名，而且 Git 的工作原理更像是小型的文件系统。</p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>命令 <code>git log</code> 用于查看提交历史，接下来的例子用 simplegit-progit 项目演示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆演示仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史，不加任何选项的话，会列出项目的所有提交，最新的在最前面</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>命令 <code>git log</code> 有许多选项定制输出的内容，比如：<br>① <code>git log -p 2</code> 显示每次提交的内容差异（选项 <code>-p</code> 即 <code>--patch</code>），且仅仅显示最近两次提交<br>② <code>git log --stat</code> 显示每次提交的简略统计信息，比如几个文件被修改等等<br>③ <code>git log --pretty=OPT</code> 定制输出格式，OPT 可以是 <code>oneline</code>, <code>short</code>, <code>format</code> 等，详见 <code>git help log</code> 选项 <code>--pretty</code></p>
<p>定制输出格式举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span> -1</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span><br><span class="line">ca82a6d - Scott Chacon, 11 years ago : changed the verison number</span><br><span class="line">085bb3b - Scott Chacon, 11 years ago : removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef0 - Scott Chacon, 11 years ago : first commit</span><br></pre></td></tr></table></figure>

<p>选项 <code>--pretty=formt</code> 常用格式占位符如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; <code>Table 1. git log --pretty=format 常用的选项</code></p>
<p>命令 <code>git log</code> 常用选项如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; Table 2. git log 的常用选项</p>
<h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p>之前你已经看到过 -2 了，它只显示最近的两条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>使用 <code>--since</code> ( <code>--after</code> ) 和 <code>--until</code> ( <code>--before</code> ) 选项，基于时间来限制输出长度，查看提交内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示最近的 2条 提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定时间之后的提交</span></span><br><span class="line"><span class="comment"># --since= 后的时间格式可以是 "2008-01-15", "2 years 2 days 1 minute ago" 等等</span></span><br><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">"2008-03-17"</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配提交说明中有 version 关键字的所有提交</span></span><br><span class="line">git <span class="built_in">log</span> --grep=<span class="string">'version'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看特定目录或文件的历史提交</span></span><br><span class="line"><span class="comment"># 特定目录或文件名放在最后，并用 -- 隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定文件的提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">'%h - %cd'</span> -- README</span><br><span class="line">a11bef0 - Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定目录的提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">'%h - %cd'</span> -- lib/</span><br><span class="line">085bb3b - Fri Apr 17 21:55:53 2009 -0700</span><br><span class="line">a11bef0 - Sat Mar 15 10:31:28 2008 -0700</span><br></pre></td></tr></table></figure>

<p>命令 <code>git log</code> 的限制输出的常用选项如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; Table 3. 限制 git log 输出的选项</p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个命令会把暂存区中的文件提交</span></span><br><span class="line"><span class="comment"># 如果这次提交与上次提交之间没有修改过文件，那么快照保持不变，仅仅是最后一次提交的提交说明发生变化</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>如果提交后，忘记暂存修改过的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行如下命令提交</span></span><br><span class="line"><span class="comment"># 最终只会有一个提交，第二次提交将代替第一次提交的结果</span></span><br><span class="line">git commit -m <span class="string">'initial commit'</span></span><br><span class="line">git add another_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果不小心暂存了不需要的文件。应该如何取消暂存呢。使用命令 <code>git reset</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改文件并且暂存，然后查看当前文件状态</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line">$ git add README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态中已经有提示如何移除暂存状态了</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出暂存状态</span></span><br><span class="line">$ git reset HEAD README</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看状态</span></span><br><span class="line"><span class="comment"># 状态中给出了如何添加文件到暂存，以及如何撤销对文件的修改</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><p>如果不想保留对文件的修改，如何撤销呢。使用 <code>git checkout</code> 命令。</p>
<p>但是，注意，撤销操作是对已暂存（或者是对已提交，反正最低要求是已暂存）的文件而言的。如果文件已经暂存，之后又修改了，这个修改才可以被撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件状态为已暂存</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'NEW LINE'</span> &gt;&gt; NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的文件内容</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line">NEW LINE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的文件状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对已暂存文件的修改</span></span><br><span class="line">$ git checkout -- NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销后文件内容恢复原样</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销后文件状态恢复原样</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>命令 <code>git checkout -- &lt;file&gt;</code> 很危险。撤销后，你对那个文件的任何修改都会消失，Git 会拷贝另个文件来覆盖它。除非你十分清楚想要撤销的是什么，否则不要使用这个命令！</p>
<p>最后，如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 介绍保存进度与分支，这些通常是更好的做法。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code>，这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆远程仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span><br><span class="line">Cloning into <span class="string">'ticgit'</span>...</span><br><span class="line">remote: Enumerating objects: 1857, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857</span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 242.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (837/837), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> ticgit/</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -v 选项会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="comment"># 如果远程仓库不止一个，该命令会把他们全部列出来</span></span><br><span class="line"><span class="comment"># 这里的意思是 ticgit 仓库可以关联到多个远程 Git 仓库，这样就方便多人协作</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行命令 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还是以上面的 ticgit 仓库为例，进入 ticgit 目录，执行</span></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面 pb 是远程服务器的简写，后面是服务器 URL</span></span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br><span class="line">pb  https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb  https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>拉取新添加的远程仓库的内容，可以使用服务器简写 <code>pb</code> 代替 URL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取后，paulboone 的 master 分支就能在本地通过 pb/master 访问</span></span><br><span class="line"><span class="comment"># 注意这里的 pb/master 代表分支，不是本地的 pb/master 目录</span></span><br><span class="line">$ git fetch pb</span><br><span class="line">remote: Enumerating objects: 22, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (22/22), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21</span><br><span class="line">Unpacking objects: 100% (43/43), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>关于分支的内容，将在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍。</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>如上文所示，从远程仓库获取数据，执行命令 <code>git fetch [remote-name]</code>。</p>
<p>这个命令会访问远程仓库，从中拉取所有 <em>你还没有的</em> 数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动地抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或不管是什么名字的默认分支）。运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>推送命令 <code>git push [remote-name] [branch-name]</code>。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如你想要将 master 分支推送到 origin 服务器</span></span><br><span class="line"><span class="comment"># 再次说明，克隆时通常会自动帮你设置好那两个名字</span></span><br><span class="line"><span class="comment"># 即上文 git remote -v 命令显示的 origin 的 fetch 和 push</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库的更多信息"><a href="#查看远程仓库的更多信息" class="headerlink" title="查看远程仓库的更多信息"></a>查看远程仓库的更多信息</h3><p>使用命令 <code>git remote show [remote-name]</code>。</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">这里</a> –&gt; 查看远程仓库 小节 –&gt; 如果想要查看某一个远程仓库的更多信息 …</p>
<h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>使用命令 <code>git remote rename</code>。比如，想要把 <code>pb</code> 重命名为 <code>paul</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你的远程分支名字。那些过去引用 pb/master 的现在会引用 paul/master。</p>
<p>使用命令 <code>git remote rm</code> 移除远程仓库。比如，你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这次以 libgit2 仓库为例</span></span><br><span class="line"><span class="built_in">cd</span> libgit2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列标签</span></span><br><span class="line"><span class="comment"># 这个命令以字母顺序列出标签，但是它们出现的顺序并不重要</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.1.0</span><br><span class="line">v0.10.0</span><br><span class="line">v0.11.0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用特定模式查找标签</span></span><br><span class="line"><span class="comment"># 这个模式就是 shell 的通配符 *, ?, []</span></span><br><span class="line"><span class="comment"># 详见 git help tag 的 --list 选项</span></span><br><span class="line">$ git tag --list <span class="string">'v0.10*'</span></span><br><span class="line">v0.10.0</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>轻量标签很像一个不会改变的分支，它只是一个特定提交的引用。</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息（即标签说明，跟提交说明一个道理）；并且可以使用 <code>GnuPG</code> (GPG) 签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息，但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>运行命令 <code>git tag -a</code> 创建附注标签。<code>-s</code> 和 <code>-u</code> 可以打 GPG 签名标签，详见 <code>git help tag</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这次还是以 simplegit-progit 仓库为例</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> simplegit-progit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加附注标签</span></span><br><span class="line"><span class="comment"># 默认是给最后一次提交加标签</span></span><br><span class="line"><span class="comment"># 选项 -m 与 git commit 的类似</span></span><br><span class="line">$ git tag -a v1.4 -m <span class="string">'my version 1.4'</span></span><br></pre></td></tr></table></figure>

<p>运行命令 <code>git show</code> 查看标签信息与对应的提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看标签详细信息</span></span><br><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: JasonZh &lt;jasonz666@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 23 01:27:02 2018 +0800</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   <span class="string">"simplegit"</span></span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br><span class="line">     s.email     =   <span class="string">"schacon@gmail.com"</span></span><br><span class="line">     s.summary   =   <span class="string">"A simple gem for using Git in Ruby code."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认给最后一次提交打了附注标签</span></span><br><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br></pre></td></tr></table></figure>

<h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>直接运行命令 <code>git tag &lt;tag-name&gt;</code> 而不加选项可以添加轻量标签。轻量标签本质上是将提交校验和存储到一个文件中，并没有保存任何其他信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打轻量标签</span></span><br><span class="line">$ git tag v1.4-lw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这次的标签详情只是显示了提交信息</span></span><br><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   <span class="string">"simplegit"</span></span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br><span class="line">     s.email     =   <span class="string">"schacon@gmail.com"</span></span><br><span class="line">     s.summary   =   <span class="string">"A simple gem for using Git in Ruby code."</span></span><br></pre></td></tr></table></figure>

<h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>运行命令 <code>git tag -a &lt;tag-name&gt; &lt;commit-hash&gt;</code>。其中，<code>&lt;commit-hash&gt;</code> 表示提交的校验和（或部分校验和）。</p>
<p>也就是给指定的提交打标签。比如，之前的一个提交忘记打标签了，就属于这种情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the verison number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给第二个提交打标签</span></span><br><span class="line">$ git tag -a v1.2 085bb3b -m <span class="string">"my version 1.2"</span></span><br></pre></td></tr></table></figure>

<h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>运行命令 <code>git push origin [tagname]</code> 或命令 <code>git push origin --tags</code>。</p>
<p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>

<p>推送多个标签。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>

<h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">这里</a> –&gt; 检出标签 –&gt; 在 Git 中你并不能真的检出一个标签 …</p>
<h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><p>使用命令 <code>git config</code> 可以为 Git 设置别名，避免每次都输入长长的命令。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p>这样，使用 <code>git commit</code> 时只需要输入 <code>git ci</code>。Git 的子命令可以设置别名，当然也可以把选项包括进来。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage <span class="string">'reset HEAD --'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br></pre></td></tr></table></figure>

<p>这样，运行 <code>git unstage fileA</code> 就能取消暂存 fileA 文件了。第二个命令设置了查看最后一次提交的别名。</p>
<p>其实 Git 只是简单地将别名替换为对应的命令。所以为了方便，还可以把外部命令绑定成 <code>git &lt;command&gt;</code> 的形式，只需要在命令前加 <code>!</code>号。比如把 <code>git ls</code> 定义成 <code>ls -a</code> 的别名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.ls <span class="string">'!ls -a'</span></span><br></pre></td></tr></table></figure>

<p>(完毕)</p>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Ubuntu 18.04 夜灯的色温</title>
    <url>/2018/12/24/set-ubuntu-night-light-temperature.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Ubuntu 18.04 里，系统设置，设备，显示 里可以开启夜灯：</p>
<img src="/2018/12/24/set-ubuntu-night-light-temperature/2018-12-24%2022-01-58%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="">

<p>但是，没有调整夜灯色温的功能。</p>
<a id="more"></a>

<h2 id="设置夜灯色温"><a href="#设置夜灯色温" class="headerlink" title="设置夜灯色温"></a>设置夜灯色温</h2><ol>
<li>安装软件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开软件 <code>dconf-editor</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf-editor</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>鼠标点击找到如下路径：</li>
</ol>
<p><code>/org/gnome/settings-daemon/plugins/color/night-light-temperature</code></p>
<ol start="4">
<li>设置自定义值：</li>
</ol>
<p>关闭 <code>使用默认值</code>，然后输入一个 <code>自定义值</code>：</p>
<img src="/2018/12/24/set-ubuntu-night-light-temperature/2018-12-24%2022-11-12%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="">

<h2 id="色温值参考"><a href="#色温值参考" class="headerlink" title="色温值参考"></a>色温值参考</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1000  —  最低值（最暖色调/效果最红）</span><br><span class="line">4000  —  默认值</span><br><span class="line">5500  —  适中值</span><br><span class="line">6500  —  关闭夜灯时的色温值</span><br><span class="line">10000 —  最高值（最冷色调/效果最蓝）</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a href="https://www.omgubuntu.co.uk/2017/07/adjust-color-temperature-gnome-night-light" target="_blank" rel="noopener">https://www.omgubuntu.co.uk/2017/07/adjust-color-temperature-gnome-night-light</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash 的输入输出重定向详解</title>
    <url>/2019/01/02/stdin-stdout-and-redirection.html</url>
    <content><![CDATA[<p>Linux 中每个进程维护了一个文件描述符表，如 shell 终端，默认有三个文件已打开，他们的文件描述符和文件对应关系为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd 0: /dev/stdin -&gt; /proc/self/fd/0（前者是指向后者的软链接，下同）</span><br><span class="line">fd 1: /dev/stdout -&gt; /proc/self/fd/1</span><br><span class="line">fd 2: /dev/stderr -&gt; /proc/self/fd/2</span><br></pre></td></tr></table></figure>

<p>所以在该 shell 中创建新的的文件的描述符就从3开始。</p>
<p><strong>用于输入输出重定向使用的文件描述符大于9，所以安全可用的自定义文件描述符范围就是：3-9</strong></p>
<p>因为 Bash <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">文档</a> 里有这样一句话：</p>
<blockquote>
<p>Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.</p>
</blockquote>
<h2 id="下面的几个例子会分别演示"><a href="#下面的几个例子会分别演示" class="headerlink" title="下面的几个例子会分别演示"></a>下面的几个例子会分别演示</h2><p>1）输入输出重定向<br>2）复制输入输出文件描述符<br>3）移动输入输出文件描述符<br>4）关闭文件描述符和同时读写文件<br>5）将已重定向的输入/输出恢复到标准输入/标准输出</p>
<a id="more"></a>

<h3 id="脚本例子1"><a href="#脚本例子1" class="headerlink" title="脚本例子1"></a>脚本例子1</h3><p>这个例子讲的是 <code>输出重定向</code> 和 <code>复制输出文件描述符</code></p>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd4..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd4"</span> &gt;&amp;4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd5..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd5"</span> &gt;&amp;5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd6..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd6"</span> &gt;&amp;6</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh test.sh 3&gt;file3 4&gt;file4 5&gt;file5 6&gt;file6</span></span><br><span class="line">write to fd3...</span><br><span class="line">write to fd4...</span><br><span class="line">write to fd5...</span><br><span class="line">write to fd6...</span><br><span class="line">[root@jz ~]<span class="comment"># cat file*</span></span><br><span class="line">fd3</span><br><span class="line">fd4</span><br><span class="line">fd5</span><br><span class="line">fd6</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>创建自定义的文件描述符（fd）从 3 开始。test.sh 脚本中 &gt;&amp;n（n 表示文件描述符，为 3, 4, 5, 6）表示：<br>复制 fd n 作为 fd 1（1 即标准输出的文件描述符）的值（这里的复制可以理解为复制 fd n 指向的文件指针，fd n 的值 n 实际上是数组下标，数组元素才是指向文件的指针）<br>也就是说，fd 1 复制了 fd n 的值之后，fd 1 原本指向文件 /dev/stdout，而现在与 fd n 指向相同的文件，n 必须与实际文件关联，这个文件描述符 n 才是有效的<br>在上文的例子中，通过执行脚本 test.sh，fd 3 关联（重定向）到了实际文件 file3，fd 4 关联到了实际文件 file4 等等<br>fd 3, 4, 5, 6 关联了实际文件之后，脚本中的 echo “fdN” &gt;&amp;N 就可以依次把标准输出的内容保存到不同的文件了</p>
<h3 id="脚本例子2"><a href="#脚本例子2" class="headerlink" title="脚本例子2"></a>脚本例子2</h3><p>这个例子讲的是 <code>输入重定向</code> 和 <code>复制输入文件描述符</code></p>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"read from fd4..."</span></span><br><span class="line">cat &lt;&amp;4</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh test.sh 3&lt;file3 4&lt;file4</span></span><br><span class="line"><span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line"><span class="built_in">read</span> from fd4...</span><br><span class="line">fd4</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>和输出重定向差不多，例子2脚本中标准输入分别复制了：输入文件描述符3、输入文件描述符4，使得标准输入分别指向 file3、file4<br>执行脚本时，fd 3、fd 4 分别重定向到了 file3、file4，所以脚本中 cat &lt;&amp;N 就会依次从 file3、file4 读取内容（file3、file 4 是例子1脚本执行后创建的）<br>上面两个例子讲的是“<strong>复制文件描述符</strong>”和“<strong>输入输出重定向</strong>”，bash shell 也支持“<strong>移动文件描述符</strong>”，下面的脚本将实验移动文件描述符。</p>
<h3 id="脚本例子1-1"><a href="#脚本例子1-1" class="headerlink" title="脚本例子1"></a>脚本例子1</h3><p>这个例子讲的是 <code>移动输出文件描述符</code></p>
<p>脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&gt;file3</span></span><br><span class="line">1: write to fd3...</span><br><span class="line">2: write to fd3...</span><br><span class="line">3: write to fd3...</span><br><span class="line">move_fn.sh: line 8: 3: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）与复制文件描述符不同的是，脚本中 &gt;&amp;3- 表示在 fd 1 复制了 fd 3 的文件指针以后，fd 3 就会关闭，就好像 fd 3 移动到了 fd 1 一样<br>注意脚本执行结果，第1次写入内容到 fd 3 是正常的，第2次写入时也正常，但之后 fd 3 就被关闭，即 fd 3 不再重定向到文件 file3<br>所以第3次写入内容时，就会报错，显示坏掉的文件描述符</p>
<p><strong>2）还有，一开始 file3 只有一行，最后变成了二行，因为脚本中的 echo 操作的文件从始至终都是 file3，脚本执行时，因为输出文件 fd 3 重定向到 file3</strong><br>脚本开始执行，file3 被打开，直到脚本结束，file3 文件才被关闭，所以脚本中每次执行完 echo “fd3” &gt;&amp;3[-] 都是向 file3 新增一行<br>而不会像终端下直接执行：echo “fd3” &gt; file3，每次都是覆盖文件，因为终端下每次执行 echo 都会单独打开/关闭文件 file3</p>
<h3 id="脚本例子2-1"><a href="#脚本例子2-1" class="headerlink" title="脚本例子2"></a>脚本例子2</h3><p>这个例子讲的是 <code>移动输入文件描述符</code></p>
<p>脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3-; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&lt;file3</span></span><br><span class="line">1: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">2: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">3: <span class="built_in">read</span> from fd3...</span><br><span class="line">move_fd.sh: line 8: 3: Bad file descriptor</span><br><span class="line"></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>脚本中使用 read 命令而不是 cat，因为 read 可以逐行读取文件，而 cat 会一次把文件所有行都读取完<br>类似脚本例子1，这里 &lt;&amp;3- 把输入文件描述符3关闭之后，下次执行 read 命令就会报错</p>
<p><strong>如果脚本例子2内容如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&lt;file3</span></span><br><span class="line">1: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">2: <span class="built_in">read</span> from fd3...</span><br><span class="line">3: <span class="built_in">read</span> from fd3...</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，cat 并不会报错，可能是在 cat 一次读完文件后，cat 先判断文件是否读完，再判断文件描述符3是否可用（因为已读完就无需判断是否可用），所以不会报错</strong></p>
<h2 id="创建文件描述符来同时读写文件"><a href="#创建文件描述符来同时读写文件" class="headerlink" title="创建文件描述符来同时读写文件"></a>创建文件描述符来同时读写文件</h2><p>语法：<code>n&lt;&gt;filename</code></p>
<p>n 为文件描述符<br>filename 为实际文件名<br>n 不写时表示 fd 0</p>
<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="comment"># 如下命令行表示把输入/输出同时重定向到 inputfile 文件，而文件描述符是3</span></span><br><span class="line"><span class="comment"># 然后让标准输入指向 inputfile 文件，标准输出也指向 inputfile 文件</span></span><br><span class="line"><span class="comment"># 执行 exec 后，下面的命令标准输出都保存到 inputfile 文件，标准输入都读取自 inputfile</span></span><br><span class="line"><span class="comment"># 只有标准错误输出依旧是屏幕</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&gt;inputfile &lt;&amp;3 &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"1234"</span></span><br><span class="line">ls xxxx</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat inputfile</span></span><br><span class="line">abcde</span><br><span class="line">dsfsf</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh</span></span><br><span class="line">ls: cannot access xxxx: No such file or directory</span><br><span class="line">[root@jz ~]<span class="comment"># cat inputfile</span></span><br><span class="line">1234e</span><br><span class="line">dsfsf</span><br><span class="line">e</span><br><span class="line">dsfsf</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>以上输出结果很复杂，涉及到文件读写操作的实现细节，猜测如下：<br>脚本执行后，执行到 exec 命令行，文件 inputfile 被打开，文件读写指针应该是指向文件开头的<br>此时运行 echo 命令行，把 1234 写入到文件开头位置，覆盖掉 abcde 前4个字符变成 1234e，读写指针在字符 e 的位置<br>执行 ls 时因为文件不存在，信息输出到标准错误，所以文件 inputfile 读写指针位置不变<br>执行 cat 从字符 e 开始读取，直到文件结尾，读到的内容是：<br>e<br>dsfsf</p>
<p>因为文件被 exec 打开，cat 并不会关闭文件，cat 读取出来的内容会再次写入 inputfile 文件，此时读写指针在文件结尾<br>cat 读出的内容添加到文件结尾之后，变成：<br>1234e<br>dsfsf<br>e<br>dsfsf</p>
<h2 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&amp;- 关闭标准输入</span><br><span class="line">&gt;&amp;- 关闭标准输出</span><br><span class="line">n&lt;&amp;- 表示将 n 号输入关闭</span><br><span class="line">n&gt;&amp;- 表示将 n 号输出关闭</span><br></pre></td></tr></table></figure>

<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat &lt;&amp;-           # 关闭标准输入</span></span><br><span class="line">cat: -: Bad file descriptor</span><br><span class="line">cat: closing standard input: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># ls &gt;&amp;-            # 关闭标准输出</span></span><br><span class="line">ls: write error: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># ls xxxx 2&gt;&amp;-      # xxxx 文件不存在，关闭标准错误后，错误信息不会输出</span></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="最后，说说怎么恢复到标准输入-标准输出"><a href="#最后，说说怎么恢复到标准输入-标准输出" class="headerlink" title="最后，说说怎么恢复到标准输入/标准输出"></a>最后，说说怎么恢复到标准输入/标准输出</h2><p>其实很简单，上文已经讲了复制文件描述符，只需要把标准输入输出，或标准错误先复制保存，之后恢复即可。</p>
<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter to continue ..."</span></span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh</span></span><br><span class="line">Enter to <span class="built_in">continue</span> ...</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh &lt;file3    # 脚本的输入被重定向到 file3 后，read 命令直接读取了 file3 的行，不再显示 Enter ...</span></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>那么，怎么把 read 的输入恢复到标准输入，再次询问用户按回车继续呢？</strong></p>
<p>把脚本改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter to continue ..."</span> &lt;&amp;3</span><br></pre></td></tr></table></figure>

<p>然后用如下方式执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh test.sh 3&lt;&amp;0 &lt;file3</span><br></pre></td></tr></table></figure>

<p>执行脚本时，它的含义是先创建一个新的文件描述符3，fd 3 复制 fd 0 的值，就把 fd 0 保存到 fd 3 了，然后在脚本中 read 命令的标准输入文件描述符从 fd 3 复制回来即可。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+Github+jsDelivr+PicGo图床测试</title>
    <url>/2020/12/13/test-github-jsdelivr-pichost.html</url>
    <content><![CDATA[<p>Typora：MarkDown编辑器</p>
<p>PicGo：图床图片上传插件</p>
<p>Github：图床</p>
<p>jsDelivr：CDN</p>
<h3 id="图片测试："><a href="#图片测试：" class="headerlink" title="图片测试："></a>图片测试：</h3><p>复制粘贴：</p>
<img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/test_pichost_funny.jpeg" alt="test_pichost_funny" style="zoom:50%;" />

<a id="more"></a>

<p>插入(ctrl+cmd+I)：</p>
<img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/test_pichost_funny2.png" alt="test_pichost_funny2" style="zoom:50%;" />

<p>拖拽：</p>
<img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/test_pichost_cat.png" alt="test_pichost_cat" style="zoom:25%;" />

<p>完毕。</p>
]]></content>
  </entry>
  <entry>
    <title>Ubuntu 18.04 禁用 nouveau 安装 NVIDIA 显卡驱动</title>
    <url>/2019/01/28/ubuntu-install-nvidia-driver.html</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1）从 NVIDIA 官网下载对应显卡的驱动备用</p>
<p><a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p>
<p>我下载的驱动是：NVIDIA-Linux-x86_64-410.93.run<br>安装环境：华硕笔记本 Ubuntu 18.04</p>
<p><strong>注意</strong>：<br>主板 BIOS 必须关闭安全启动 (Secure Boot)，不然安装的 NVIDIA 驱动无法加载。<br>但此时，还是能正常进 Ubuntu 桌面，可能是此时使用的是 Intel 核显有关。</p>
<p>2）首次运行 NVIDIA 驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x NVIDIA-Linux-x86_64-410.93.run</span><br><span class="line">sudo ./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure>

<p>首次运行驱动程序，不会安装，因为系统中有 nouveau 驱动存在。<br>但是 NVIDIA-Linux-x86_64-410.93.run 会生成 <code>/etc/modprobe.d/nvidia-installer-disable-nouveau.conf</code> 文件。用于禁用系统自带的 nouveau 驱动。该文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/modprobe.d/nvidia-installer-disable-nouveau.conf</span><br><span class="line"><span class="comment"># generated by nvidia-installer</span></span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>

<p>3）使禁用生效</p>
<p>只有 blacklist 并不能真的禁用 nouveau 驱动。执行如下命令更新 initramfs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>

<p>然后，重启系统，禁用就成功了。执行如下命令验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出结果为空说明已经禁用 nouveau 驱动</span></span><br><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>1）开始安装 NVIDIA 驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure>

<p>安装完，重启系统</p>
<p>2）查看是否安装成功</p>
<p>运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行下面命令查看显卡驱动部分，如果有 Kernel driver in use: nvidia 则成功</span></span><br><span class="line">lspci -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以运行如下命令，看看 nvidia 模块是否加载成功</span></span><br><span class="line">lsmod | grep nvidia</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行 <code>glxgears</code>，如果帧数远大于 60 FPS，说明 nvidia 驱动已在使用，因为 NVIDIA 驱动安装后，默认不会开启垂直同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mesa-utils</span><br><span class="line">glxgears</span><br></pre></td></tr></table></figure>

<p>最后，笔记本盒盖睡眠，再打开，没有黑屏，唤醒成功。</p>
<h2 id="可选：开启垂直同步解决画面撕裂"><a href="#可选：开启垂直同步解决画面撕裂" class="headerlink" title="可选：开启垂直同步解决画面撕裂"></a>可选：开启垂直同步解决画面撕裂</h2><p>安装完 NVIDIA 驱动后，默认不开启同步，有可能出现画面撕裂。解决办法如下。</p>
<p>1）在终端运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/nvidia-drm-nomodeset.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入如下一行</span></span><br><span class="line">options nvidia-drm modeset=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新到 initramfs</span></span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>

<p>重启系统。</p>
<p>2）重启系统后查看结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面命令应该是输出 "Y" 而不是 "N"</span></span><br><span class="line">sudo cat /sys/module/nvidia_drm/parameters/modeset</span><br></pre></td></tr></table></figure>

<p>3）设置 NVIDIA 驱动</p>
<p>终端运行命令 <code>nvidia-settings</code> 打开驱动设置窗口。<br>在窗口左侧选择 <code>GPU 0-(xxx)</code> –&gt; <code>PowerMizer</code> –&gt; 设置 <code>PowerMizer Settings</code> 为 <code>Prefer Maximum Performance</code>。</p>
<p>4）让系统尽可能地使用物理内存而不是交换空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文末加入两行（默认值为 60）：</span></span><br><span class="line"><span class="comment"># User defines</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<p>然后，重启系统。运行 <code>cat /proc/sys/vm/swappiness</code> 查看结果。</p>
<h2 id="如果要卸载驱动"><a href="#如果要卸载驱动" class="headerlink" title="如果要卸载驱动"></a>如果要卸载驱动</h2><p>装完 NVIDIA 驱动后，如果要卸载，会有一个命令 <code>nvidia-uninstall</code> 用来卸载驱动。但是同时要删除文件 <code>/etc/modprobe.d/nvidia-installer-disable-nouveau.conf</code> 文件，然后运行 <code>sudo update-initramfs -u</code>，让 nouveau 驱动再次生效。</p>
<p>参考：<br><a href="https://blog.csdn.net/u012442845/article/details/78855573" target="_blank" rel="noopener">https://blog.csdn.net/u012442845/article/details/78855573</a><br><a href="https://askubuntu.com/questions/1031511/cant-disable-nouveau-drivers-in-ubuntu-18-04" target="_blank" rel="noopener">https://askubuntu.com/questions/1031511/cant-disable-nouveau-drivers-in-ubuntu-18-04</a><br><a href="https://askubuntu.com/questions/1056363/how-to-disable-gui-on-boot-in-18-04-bionic-beaver" target="_blank" rel="noopener">https://askubuntu.com/questions/1056363/how-to-disable-gui-on-boot-in-18-04-bionic-beaver</a><br><a href="http://ubuntuhandbook.org/index.php/2018/07/fix-screen-tearing-ubuntu-18-04-optimus-laptops/" target="_blank" rel="noopener">http://ubuntuhandbook.org/index.php/2018/07/fix-screen-tearing-ubuntu-18-04-optimus-laptops/</a></p>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI 启动：实际工作原理</title>
    <url>/2019/01/02/uefi-boot-principle.html</url>
    <content><![CDATA[<p>原文：<a href="https://www.cnblogs.com/mahocon/p/5691348.html" target="_blank" rel="noopener">https://www.cnblogs.com/mahocon/p/5691348.html</a><br>本文翻译自：<a href="https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/" target="_blank" rel="noopener">https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/</a></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>首先，我们了解一些术语。BIOS 和 UEFI 都是计算机的 <code>固件</code> 类型。BIOS 固件（主要）用于 IBM PC 兼容计算机。UEFI 的通用性更强，可用在非“IBM PC 兼容”系列的计算机上。</p>
<p>不存在“UEFI BIOS”。没有任何一台计算机会有“UEFI BIOS”。BIOS 不是所有 PC 固件的通用术语，它只是 PC 固件的一种特定类型。计算机中包含固件。如果你有一台 IBM PC 兼容计算机，那么固件几乎肯定就是 BIOS 或 UEFI。如果你运行的是 <code>Coreboot</code>，那么恭喜，你是个例外，引以为傲吧。</p>
<p>安全启动 (Secure Boot) 与 UEFI 不是同一个概念。请不要将这些术语混淆使用。安全启动 (Secure Boot) 实际上是 UEFI 规范的一项可选功能，于 UEFI 规范版本 2.2 引入。我们稍后会详细讨论安全启动 (Secure Boot) 到底是什么，但是目前而言，只需要记住它和 UEFI 不同即可。</p>
<p>UEFI 不是由微软开发的，也从来不受微软控制。它的前身和基础——EFI，是由 Intel 开发和发布的。UEFI 由 UEFI 论坛 进行管理。微软是 UEFI 论坛的成员之一。</p>
<a id="more"></a>

<h2 id="UEFI-启动：背景"><a href="#UEFI-启动：背景" class="headerlink" title="UEFI 启动：背景"></a>UEFI 启动：背景</h2><p>我们现在来看看 UEFI 计算机上的启动原理。即使未掌握本文的细节，也请记住这一点：UEFI 与 BIOS 完全不同。UEFI 启动原理与 BIOS 绝对不同。你不能把 BIOS 启动的原理直接套用到原生 UEFI 启动上。你不能把专为 BIOS 启动设计的工具应用到原生 UEFI 启动的系统上。</p>
<p>还需要了解一个重点：许多 UEFI 固件实现了某种 BIOS 兼容模式（有时候称为 <code>CSM</code>）。许多 UEFI 固件可以像 BIOS 固件一样启动系统，它们可以查找磁盘上的 MBR，然后从 MBR 中执行启动装载程序，接着将后续工作完全交给启动装载程序。有时候，其他人误将此功能称为“禁用 UEFI”，从语言学角度而言，这种说法是荒谬的。他们讨论的是通过 UEFI 固件的一项功能，以“BIOS 风格”启动系统，而不是采用原生 UEFI 方式启动系统。</p>
<p>我想解释一下原生 UEFI 启动。如果你有一台基于 UEFI 的计算机，其固件具有 BIOS 兼容功能，并且你打算一直使用这项兼容功能，在启动过程中，你的计算机看起来就是基于 BIOS 的。你只需要像 BIOS 启动一样进行所需操作即可。如果你确实有此打算，那么就不要中途变卦。对于你日常使用的操作系统，<strong>强烈建议不要混合使用原生 UEFI 启动和 BIOS 兼容启动</strong>，尤其不要在同一块磁盘上混用。这么做的话，你会痛不欲生。如果你决定混合使用原生 UEFI 启动和 BIOS 兼容启动，到时候就别找我哭诉。</p>
<p>为了理清头绪，我将假设磁盘采用 GPT ，并且包含用于 EFI 的 <code>FAT32 EFI 系统分区(ESP)</code>。根据你对这些知识的深入程度，你可能发现，在进行原生 UEFI 启动时，GPT 磁盘和 EFI FAT32 ESP 并不是必要条件。但是 UEFI 规范和 GPT 磁盘以及 <code>EFI FAT32 ESP</code> 的联系程度相当密切。在99%的情况下，你要处理的也正是这样的组合。除非你在使用 Mac（老实说，Mac 混乱不堪）。</p>
<h2 id="UEFI-原生启动：实际工作原理"><a href="#UEFI-原生启动：实际工作原理" class="headerlink" title="UEFI 原生启动：实际工作原理"></a>UEFI 原生启动：实际工作原理</h2><p>言归正传。本节将解释原生 UEFI 启动的实际工作原理。如果已掌握一定程度的背景知识，可能更容易深入理解本节内容。</p>
<p>在固件层，UEFI 的基础架构更丰富，可用于处理系统启动。UEFI 远不像 BIOS 那么简单。与 BIOS 不同，UEFI 确实可以（不同程度上）理解“磁盘分区”、“启动装载程序”以及“操作系统”的概念。你可以稍微看看 BIOS 启动过程，然后再看看 UEFI 启动过程，了解 UEFI 启动过程如何采用多种措施来解决特定问题。</p>
<p>在思考启动过程时，你会发现 BIOS/MBR 查找启动装载程序的方法实在不怎么样。BIOS/MBR 非常奇葩：位于磁盘起始位置的这一小段空间包含 <code>神奇代码 (magic code)</code>，而这段神奇代码只作用于系统固件和写入此神奇代码的工具。这种方法有许多问题。</p>
<ul>
<li><p>处理不便——你需要特殊工具来写入 MBR，如果要查看 MBR 中包含的内容，唯一的方法几乎就是把 MBR <code>dd</code> 出来，然后进行检查。</p>
</li>
<li><p>如上所述，MBR 本身不足以容纳许多现代启动装载程序。这些启动装载程序会将自身的一小部分安装在 MBR 中，而将其他部分安装到磁盘上的可用空间中。这段可用空间位于常规 MBR 末尾和第一个分区的起始位置之间。这就会造成很大的问题（其实这整个设计就是个大问题，不过无所谓）。对于第一个分区的起始位置，并没有成文的可靠规定，因此难以确保空间足够。只有一件事情是肯定的：这段空间不足以容纳某些启动装载程序的配置。</p>
</li>
<li><p>如果要选择其他启动目标（除磁盘以外），这种设计没有提供任何标准化层或标准化机制，但是用户希望选择除磁盘以外的启动目标。也就是说，他们希望实现多重可启动对象——通常是操作系统。在 BIOS/MBR 组合中，实现这种目的的唯一方法是由启动装载程序进行处理；至于如何实现，并没有进行获得广泛认可的规定。虽然实现的方法非常多，但是它们无法彼此协作，而且也都不是获得广泛认可的标准或规定。而在操作系统/操作系统安装层编写工具的难度很大，无法干净利落地处理多重启动。因此这种设计非常混乱。</p>
</li>
<li><p>这种设计没有提供标准方法，让用户可以从除磁盘以外的目标进行启动。本文不会就此问题进行详细讨论，但是请注意，UEFI 启动的另一优势为：它提供了进行启动（例如，从远程服务器进行启动）的标准方法。</p>
</li>
<li><p>固件层以上的其他层无法配置固件的启动行为，BIOS 没有提供相应机制。</p>
</li>
</ul>
<p>可以想象，在 UEFI 设计之初，开发人员思考过这些问题，并最终提出解决方案。UEFI 固件并不仅仅可以识别磁盘，它也知道启动装载程序代码在每个磁盘上所处的位置，而且在固件层，UEFI 的基础架构更丰富，可用于处理启动装载。接下来，我们讨论下 UEFI 规范中定义的相关内容。</p>
<h2 id="EFI-可执行文件"><a href="#EFI-可执行文件" class="headerlink" title="EFI 可执行文件"></a>EFI 可执行文件</h2><p>UEFI 规范定义了一种可执行文件格式，并要求所有 UEFI 固件能够执行此格式的代码。当开发人员为原生 UEFI 编写启动装载程序时，就必须按照这种格式编写。这种设计非常简洁直观，也无需进一步解释：对于固件可以执行的代码，固件规范真正定义了其通用格式，这是件好事。</p>
<h2 id="GPT（GUID-分区表）格式"><a href="#GPT（GUID-分区表）格式" class="headerlink" title="GPT（GUID 分区表）格式"></a>GPT（GUID 分区表）格式</h2><p>GUID 分区表格式与 UEFI 规范具有密切联系，而且，它并不特别复杂，无需多加解释。GPT 是 UEFI 规范提供的良好基础架构之一。GPT 仅仅是分区表的一种标准——磁盘起始位置的信息定义了磁盘所包含的分区。相比 MBR/MS-DOS 分区表，这种分区表对分区的定义要好得多，并且 UEFI 规范要求 UEFI 兼容固件必须能识别 GPT（也要求固件能识别 MBR，以保证向后兼容）。所有这些规范都是相当实用的基础架构：UEFI 规范正建立某些功能，固件层上的一切都可依靠固件本身来实现这些功能。</p>
<h2 id="EFI-系统分区"><a href="#EFI-系统分区" class="headerlink" title="EFI 系统分区"></a>EFI 系统分区</h2><p>在修订本文时，我才真正思考 EFI 系统分区的概念，让我有如醍醐灌顶。实际上，“EFI 系统分区”的概念可以解决“奇葩”的 MBR 空间所产生的问题。在磁盘起始位置留出自由空间，用于存放启动装载程序代码，但又不定义其容量，这种设计糟糕透顶。这一点在上文已经讨论过了。EFI 系统分区是 UEFI 用于解决这种问题的解决方案。</p>
<p>具体的解决方案如下：我们要求固件层能够读取某些特定的文件系统类型。UEFI 规范要求兼容固件必须能读取 FAT 格式的变种（包括 <code>FAT12</code>、<code>FAT16</code> 和 <code>FAT32</code>）。UEFI 规范实际扮演的角色就是编纂整理 FAT 文件系统格式的现有解释，确保在采用 UEFI 时可以使用那些格式，并规定 UEFI 兼容固件必须能够读取那些格式。UEFI 规范针对这方面的具体规定如下：</p>
<p>可扩展固件接口 (EFI) 支持的文件系统基于 FAT 文件系统。EFI 定义了可以明确记录和测试的具体 FAT 版本。FAT 的唯一定义必须符合 EFI 规范及关联参考文档，对 FAT 唯一定义的实现必须支持 EFI。为区分 EFI 文件系统与纯 FAT，定义了新的分区文件系统类型。</p>
<p>EFI 系统分区 是采用 FAT 变种（UEFI 规范定义的变种之一）格式化的任意分区，该分区被赋予特定 GPT 分区类型，以帮助固件识别该分区。此分区的目的如上所述：固件层确实可以读取“普通”磁盘分区中的数据。希望我已明确解释为何这种设计更佳：操作系统可以创建、格式化和挂载分区（采用广泛理解的格式），并将启动装载程序的代码和固件可能需要读取的所有其他内容放到这个分区中，而不用像 MBR 磁盘一样，将启动装载程序的代码写入磁盘的起始位置空间。</p>
<p>刚开始的时候，对我而言，整个 ESP 的设计看起来有点匪夷所思且令人困惑，因此我希望本节可以解释为何 ESP 实际上是非常优秀的设计——真正匪夷所思和令人困惑的设计是 BIOS/MBR。若要从操作系统层写入某些内容，唯一的方法是将这些内容写入磁盘起始位置的某部分（但不知道是多少）空间，而并没有具体规定其中的具体实现。如果回过头再看，这种设计并不明智，且难以理解。</p>
<p>正如我们稍后会强调的那样，UEFI 规范试图采用更直观严格的方法——它很少禁止固件执行其他操作。UEFI 规范并不反对编写固件，用于执行以其他格式写成的代码、读取其他类型的分区表，以及读取用 UEFI 变种文件系统（非 FAT）格式化的分区。但是 UEFI 兼容固件必须至少能够实现执行 EFI 可执行文件、读取 GPT 分区表、以及读取 ESP，因此如果你正编写操作系统或其他东西，并且想要在 UEFI 兼容固件上运行的话，你也得遵循 UEFI 规范，这就是 EFI 系统分区的概念非常重要的原因：它允许（至少理论上）将 EFI 可执行文件放在以 UEFI FAT 格式化且 GPT 分区类型正确无误的分区上，另外，系统固件要能够读取该分区。这种机制非常严谨，等价于 BIOS 中的“固件能够执行放置在 MBR 空间中的启动装载程序代码”。</p>
<p>UEFI 规范为我们提供了三大重要基础，这些重要基础是上层架构正常运行的立足之本：</p>
<ul>
<li><p>读取分区表</p>
</li>
<li><p>访问某些特定文件系统中的文件</p>
</li>
<li><p>执行特定格式的代码</p>
</li>
</ul>
<p>相比 BIOS 固件所提供的功能，UEFI 的功能要丰富得多。但是，为了完成固件层可以处理多重目标（而不仅仅是磁盘）启动的愿景，我们需要其他基础：需要建立一种机制，通过这种机制，固件可以查找各种可能的启动目标，并提供相应的配置方法。</p>
<h2 id="UEFI-启动管理器"><a href="#UEFI-启动管理器" class="headerlink" title="UEFI 启动管理器"></a>UEFI 启动管理器</h2><p>UEFI 规范定义了名为 UEFI 启动管理器的一项功能（Linux 发行版包含名为 <code>efibootmgr</code> 的工具，可用于更改 UEFI 启动管理器的配置）。如果你确实阅读过 UEFI 规范，那么就会发现，UEFI 规范对 UEFI 启动管理器作出了如下规定：</p>
<p>UEFI 启动管理器是一种固件策略引擎，可通过修改固件架构中定义的全局 NVRAM 变量来进行配置。启动管理器将尝试按全局 NVRAM 变量定义的顺序依次加载 UEFI 驱动和 UEFI 应用程序（包括 UEFI 操作系统启动装载程序）。</p>
<p>好，既然已经明确了这一概念，那我们就继续吧。不，先等等。我来先把那一项规定解释清楚，便于理解。<strong>简单来说，你可以把 UEFI 启动管理器视为启动菜单</strong>。在 BIOS 固件上，固件层的“启动菜单”（当然）是，启动时连接到计算机的各个磁盘——不多不少。但是对于 UEFI 固件而言，情况有所不同。</p>
<p>UEFI 启动管理器可以进行配置——简言之，你可以向“启动菜单”添加项或者从中删除项。固件也可以（事实上， UEFI 规范也有此要求）根据连接到计算机的磁盘或根据某些固件配置，在此启动菜单中“生成”有效项。你也可以检查启动菜单，确保正确无误。</p>
<p>UEFI 提供了一种非常优秀的机制，可以从上层架构执行此操作：你可以从已启动的操作系统中配置系统启动行为。如果已通过 UEFI 启动 Linux，就可以使用 <code>efibootmgr</code> 工具来完成所有这些操作。Windows 也有相应的工具，但是我对 Windows 下的工具非常不熟悉。我们不妨看一些典型的 efibootmgr 输出，这些是我从 Fedora 论坛转过来的，稍微进行了调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@system directory]<span class="comment"># efibootmgr -v</span></span><br><span class="line">BootCurrent: 0002</span><br><span class="line">Timeout: 3 seconds</span><br><span class="line">BootOrder: 0003,0002,0000,0004</span><br><span class="line">Boot0000* CD/DVD Drive BIOS(3,0,00)</span><br><span class="line">Boot0001* Hard Drive HD(2,0,00)</span><br><span class="line">Boot0002* Fedora HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\EFI\fedora\grubx64.efi)</span><br><span class="line">Boot0003* opensuse HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\EFI\opensuse\grubx64.efi)</span><br><span class="line">Boot0004* Hard Drive BIOS(2,0,00)P0: ST1500DM003-9YN16G .</span><br><span class="line">[root@system directory]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个示例非常清晰。我们可以从中观察细节。</p>
<p>第一行表示，目前你从“启动菜单”的哪个项进行了启动。第二行非常明显（如果固件的 UEFI 启动管理器显示了类似启动菜单的界面，那么这一行表示继续启动默认项之前的超时）。BootOrder 是列表中启动项的尝试顺序。其余输出显示了实际的启动项。我们稍后会说明每一个启动项具体作用。</p>
<p>如果完全正常启动 UEFI 固件，而不进行任何调整（我们稍后会讨论），UEFI 固件将按照BootOrder 中列出的顺序，尝试从“启动菜单”中的每个“项”进行启动。因此，在这台计算机上，UEFI 固件将尝试启动名为“opensuse”的项，如果启动失败，然后再尝试启动名为“Fedora”的项，然后再是“CD/DVD Drive”，接着是第二项“Hard Drive”。</p>
<h2 id="UEFI原生启动：启动管理器项"><a href="#UEFI原生启动：启动管理器项" class="headerlink" title="UEFI原生启动：启动管理器项"></a>UEFI原生启动：启动管理器项</h2><p>那么，这些项的实际含义是什么？实际上，UEFI 规范之所以显得复杂，很大程度上是因为其中的不确定因素太多。如果你正在阅读 UEFI 规范，那么先做好心理准备，然后前往 EFI_DEVICE_PATH_PROTOCOL 一节。但是请注意，这个协议是通用的，虽然这个协议不涉及启动过程，但是有其他作用——这实际上就是 UEFI 官方的设备标识方法，这种标识方法可用于启动管理器项以及各种其他用途。出于各种原因，并不是每一种潜在的 EFI 设备都像 UEFI 启动管理器项一样起作用（如果你想从视频适配器启动，很可能不会成功）。但是启动菜单中显然可以包含指向 PXE 服务器（而不是磁盘分区）的项。UEFI 规范进行了多项规定，可以向 UEFI 启动管理器配置中添加除磁盘以外的启动目标。</p>
<p>但是对我们而言，只需要考虑连接到计算机的一般磁盘即可。既然这样，我们来讨论下可能遇到的三种启动项类型。</p>
<h2 id="BIOS-兼容启动项"><a href="#BIOS-兼容启动项" class="headerlink" title="BIOS 兼容启动项"></a>BIOS 兼容启动项</h2><p>在本示例中，Boot0000 和 Boot0004 实际上是 BIOS 兼容模式启动项，而不是原生 UEFI 启动项。这些启动项不是通过外部工具添加到 UEFI 启动管理器配置中的，而是由固件本身生成的——这也是 UEFI 固件实现 BIOS 兼容启动的常见方式，通过生成 UEFI 启动管理器项，可触发指定设备的 BIOS 启动。至于 UEFI 启动管理器如何呈现给用户，这是另一个问题，我们稍后讨论。根据具体固件及其配置，其中有些项可能无法显示。每一项只会具有一个名称（“CD/DVD Drive”、“Hard Drive”），这表示“如果选中此项，那么就以 BIOS 兼容模式启动本磁盘”（其中，对于 Boot0000，“本磁盘”为 3,0,00，对于 Boot0004，“本磁盘”为 2,0,00）。</p>
<h2 id="回退路径-Fallback-path-UEFI-原生启动项"><a href="#回退路径-Fallback-path-UEFI-原生启动项" class="headerlink" title="回退路径 (Fallback path) UEFI 原生启动项"></a>回退路径 (Fallback path) UEFI 原生启动项</h2><p>Boot0001 项（我虚构的，实际操作中可能不存在，这里只是为了举例说明）用于通知固件尝试从特定磁盘启动（以 UEFI 模式而不是 BIOS 兼容模式），但是并没有向固件提供其他信息。它没有指定磁盘上的具体启动目标，而只是让固件启动磁盘。</p>
<p>UEFI 规范定义了一种“回退”路径 (Fallback path)，用于启动此类启动管理器项，其工作原理类似于 BIOS 驱动器启动：它会在标准位置查找某些启动装载程序代码。但是其中的细节和 BIOS 不同。</p>
<p>当尝试以这种方式启动时，固件真正执行的操作相当简单。固件会遍历磁盘上的每个 EFI 系统分区（按照磁盘上的分区顺序）。在 ESP 内，固件将查找位于特定位置的具有特定名称的文件。在 x86-64 PC 上，固件会查找文件 <code>\EFI\BOOT\BOOTx64.EFI</code>。固件实际查找的是 <code>\EFI\BOOT\BOOT{计算机类型简称}.EFI</code>，其中，“x64”是 x86-64 PC 的“计算机类型简称”。文件名还有可能是 <code>BOOTIA32.EFI</code> (x86-32)、<code>BOOTIA64.EFI</code> (Itanium)、<code>BOOTARM.EFI</code>（AArch32，即32位ARM）和 <code>BOOTAA64.EFI</code>（AArch64，即64位ARM）。然后，固件将执行找到的第一个有效文件（当然，文件需要符合UEFI规范中定义的可执行格式）。</p>
<p>这种机制的设计目的不在于启动日常使用的操作系统。它的设计目的更像是为了启动可热插拔、与设备无关的介质（如 Live 映像和操作系统介质）。这也是这种机制的常见用途。如果查看 Linux 或其他操作系统的 UEFI 兼容 Live 或安装介质，你会发现其中包含 GPT，以及位于（或靠近）设备起始位置的 FAT 分区，该分区的 GPT 分区类型标识为 EFI 系统分区。在那个分区中，会有一个 <code>\EFI\BOOT</code> 目录，目录中至少包含上述特殊命名的文件之一。当以原生 UEFI 模式启动 Fedora Live 或安装介质时，就会采用这种机制。BOOTx64.EFI（或其他）文件将处理剩余启动过程，从而启动介质上包含的真正操作系统。</p>
<h2 id="完全原生-UEFI-启动项"><a href="#完全原生-UEFI-启动项" class="headerlink" title="完全原生 UEFI 启动项"></a>完全原生 UEFI 启动项</h2><p>Boot0002 和 Boot0003 是存储设备上所安装操作系统的“典型”项。这些项显示了 UEFI 启动机制的全部优势，不仅仅是“从此磁盘启动”，而是“启动此特定磁盘上此特定位置中的这一特定启动装载程序”。</p>
<p>Boot0002 是由原生 UEFI Fedora 安装生成的启动项。Boot0003 是由原生 UEFI OpenSUSE安装生成的启动项。按照字面意思，这些启动项表示“从此分区加载这一文件”。分区指的是 HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d) 这个东西：表示某一特定分区（使用 EFI_DEVICE_PATH_PROTOCOL，我不打算对此进行详细介绍。如果你通过固件界面和 efibootmgr 与启动管理器进行交互，你也不需要知道其中的细节）。文件指的是 (\EFI\opensuse\grubx64.efi) 这个东西：它仅表示“加载所述分区上此位置中的文件”。这里所指的分区基本上始终指的就是充当 EFI 系统分区的那个分区，因此：可以放心地让固件访问 EFI 系统分区。</p>
<p>UEFI 规范提供这一机制，以便操作系统可启动：操作系统将启动装载程序（作用为加载操作系统内核等）安装到 EFI 系统分区中，并使用某一名称（显然，这一名称通常来源于操作系统名称）以及启动装载程序（EFI 可执行格式，用于加载操作系统）的位置向 UEFI 启动管理器配置中添加启动项。</p>
<p>Linux 发行版使用 <code>efibootmgr</code> 工具处理 UEFI 启动管理器。进行原生 UEFI 安装时，有关启动装载方面，Linux 发行版实际进行的操作相当简单：它会创建一个 EFI 系统分区（如果不存在此分区），使用相应配置将 EFI 启动装载程序（通常为 <code>grub2-efi</code>，但是也有例外）安装到 EFI 系统分区中的正确路径下，然后调用 efibootmgr 添加相应的 UEFI 启动管理器项（指向其启动装载程序）。如果已存在 EFI 系统分区，大部分发行版会使用现有分区（尽管完全可以创建新的 EFI 系统分区并使用这个新分区）：我们已经提到过，UEFI 是一种宽松规范，只要在逻辑上遵循其设计，那么有多少个 EFI 系统分区都没问题。</p>
<h2 id="配置启动过程（固件-UI）"><a href="#配置启动过程（固件-UI）" class="headerlink" title="配置启动过程（固件 UI）"></a>配置启动过程（固件 UI）</h2><p>上文描述了 UEFI 规范定义的基本机制，用于管理 UEFI 启动过程。固件用户界面可能不会明确遵循这一机制，了解这一点非常重要。不幸的是，UEFI 规范有意未限制启动过程的呈现方式或用户配置启动过程的方式，这表示——由于我们也从事 固件工程——每个固件会有不同的实现方法，并且其中某些固件的实现方法较疯狂。</p>
<p>许多固件的启动配置界面较直观。优秀的固件设计至少会显示启动顺序以及其中的各个启动项，允许用户添加/删除项、更改启动顺序或在某次特定启动中忽略原有启动顺序（仅针对那次启动生效，或直接让固件启动特定菜单项，甚至可以选择让固件以 <code>BIOS 兼容模式</code> 或 <code>UEFI“回退 (Fallback)”模式</code> “启动这块磁盘”，我的固件就可以这么操作）。此类界面通常可以仅按名称显示完整的原生 UEFI 启动项（例如我们上文提到的 Fedora 和 OpenSUSE 示例）；你需要检查 efibootmgr -v 的输出，以详细了解在调用这些项时，它们具体会尝试并执行哪些操作。</p>
<p>某些固件会尝试对配置进行抽象和简化，最终结果良莠不齐。例如，如果可以选择“启用或禁用”BIOS 兼容模式，固件很有可能会为已连接驱动器的 UEFI 启动管理器配置添加或删除 BIOS 兼容项。如果可以选择“启用或禁用”原生 UEFI 启动，那么在用户“禁用”原生 UEFI 启动时，固件很有可能更改 UEFI 启动管理器配置，从 BootOrder 中删除所有原生UEFI启动项。</p>
<p>请谨记，固件界面中的所有配置选项所执行的操作就是在后台配置 UEFI 启动管理器的行为。如果你能理解以上所有内容，那么当你更改固件界面中的选项时，你会更容易理解其背后的本质。</p>
<p>在 BIOS 中，系统不会始终尝试优先从可移动驱动器（CD、USB）进行启动，然后再从驱动器启动。根据实际情况，结果可能有所不同。有些 BIOS 固件会优先尝试从 CD 启动，然后再尝试从硬盘启动（而不是 USB）。试图安装新的操作系统时，用户已习惯于时常检查 BIOS 配置，以确保启动顺序“正确无误”。</p>
<p>UEFI 也是如此，但是由于 UEFI 启动管理器机制的灵活性/复杂性，这一过程看起来可能显得陌生而可怕。</p>
<p>在系统尝试启动固定启动项之前，如果想要确保系统使用“回退(Fallback)”机制优先从可移动设备启动（例如，在安装 Fedora 时），需要将可移动设备作为固件的默认启动项，或需要相应设置固件。根据具体固件界面，可能发现每个连接的可移动设备都有对应的“菜单项”，你只需要调整启动顺序，把你想要的可移动设备放在首位即可，有时候你也会发现可以直接请求“对此特定磁盘进行 UEFI 恢复启动”，另外你还可能发现固件会尝试将配置进行抽象。我们不知道具体的固件界面是什么样，因此难以编写说明。但是既然你已了解背后的工作原理，那么就可能更容易理解固件用户界面配置的含义。</p>
<h2 id="配置启动过程（通过操作系统）"><a href="#配置启动过程（通过操作系统）" class="headerlink" title="配置启动过程（通过操作系统）"></a>配置启动过程（通过操作系统）</h2><p>如上所述，与 BIOS 机制不同，你可以从操作系统层面配置 UEFI 启动过程。如果你的固件比较令人恶心，你可能需要执行此操作才能达成目的。</p>
<p>你可以使用之前提过的 efibootmgr 工具来添加、删除和修改 UEFI 启动管理器配置中的项，这一工具也具有其他丰富功能。你可以更改启动顺序。你可以更改下次启动时的首要启动项，而不需要使用 BootOrder 列表（如果你或其他某些工具已经进行过配置，efibootmgr -v 的输出将包括 BootNext 项，说明下一次启动将加载的菜单项）。Windows 下也有类似的工具。因此如果你难以从固件界面配置 UEFI 启动，但是你可以启动某种原生 UEFI 操作系统，那么你可以考虑从操作系统（而不是固件 UI）进行启动配置。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul>
<li><p>UEFI 固件包含某些非常类似于启动菜单的内容。</p>
</li>
<li><p>可以使用 <code>efibootmgr -v</code> 从任何原生 UEFI 启动的 Linux 操作系统中查询 UEFI 启动配置，也可以使用 efibootmgr 更改配置（有关详细信息，请参阅 man 页面）。</p>
</li>
<li><p>“启动菜单”可以包含表示“以 BIOS 兼容模式启动此磁盘”，“通过回退路径 (Fallback path) 以原生 UEFI 模式启动此磁盘”（将使用上文所述的“寻找 BOOT(某字符串).EFI”方式），或“启动此特定位置（几乎始终为 EFI 系统分区）中的特定 EFI 格式的可执行文件”等含义的项。</p>
</li>
<li><p>UEFI 规范尝试一种优秀、简洁的设计，让所有操作系统都将其自身的启动装载程序安装到 EFI 系统分区中，然后在“启动菜单”中添加指向这些启动装载程序的项，同时不得干涉其他目标的启动过程。</p>
</li>
<li><p>你的固件 UI 可以自由实现此机制，虽然具体的实现结果良莠不齐。</p>
</li>
</ul>
<h2 id="在-UEFI-计算机上安装操作系统"><a href="#在-UEFI-计算机上安装操作系统" class="headerlink" title="在 UEFI 计算机上安装操作系统"></a>在 UEFI 计算机上安装操作系统</h2><p>我们快速浏览下上文中与在 UEFI 计算机上安装操作系统相关的具体结果。</p>
<h3 id="原生-UEFI-启动和-BIOS-兼容启动"><a href="#原生-UEFI-启动和-BIOS-兼容启动" class="headerlink" title="原生 UEFI 启动和 BIOS 兼容启动"></a>原生 UEFI 启动和 BIOS 兼容启动</h3><p>用户有时会忽略以下事项：</p>
<ul>
<li><p>如果以“原生 UEFI”模式启动安装介质，安装介质将以原生 UEFI 模式安装操作系统：它将尝试向 EFI 系统分区写入 EFI 格式的启动装载程序，并尝试向 UEFI 启动管理器的“启动菜单”中添加启动项，用于启动该启动装载程序。</p>
</li>
<li><p>如果以“BIOS 兼容”模式启动安装介质，安装介质将以 BIOS 兼容模式安装操作系统：它将尝试向磁盘上的 MBR 空间写入 MBR 类型的启动装载程序。</p>
</li>
</ul>
<p>这适用于（现在暂时忽略其中的无关警告）我接触过的所有操作系统。因此你可能确实想了解，如何在固件层选择以原生 UEFI 模式启动可移动设备，以及如何在固件层选择以 BIOS 兼容模式启动可移动设备，确保在安装时可以随意选择需要使用的模式。</p>
<p>如果以 BIOS 兼容模式启动安装介质，那么你绝对无法成功进行操作系统的原生 UEFI 安装，因为安装程序无法配置 UEFI 启动管理器（除非以原生 UEFI 模式启动安装介质）。</p>
<p>理论上，在以原生 UEFI 模式启动之后，操作系统的安装程序可通过 BIOS 模式安装该操作系统，即，将启动装载程序写入磁盘 MBR，但是大部分安装程序无法执行此操作，这种做法比较可取。</p>
<h3 id="确定启动模式"><a href="#确定启动模式" class="headerlink" title="确定启动模式"></a>确定启动模式</h3><p>有时候，在启动操作系统安装程序之后，你不确定启动模式为原生 UEFI 模式还是 BIOS 兼容模式。别担心。有几种简单方法可以确定启动模式。最简单的方法之一是尝试读取 UEFI 启动管理器。如果你启动了 Linux 安装程序或环境，并且可以运行 shell（例如，在 Fedora 安装程序中是 Ctrl-Alt-F2），请运行 <code>efibootmgr -v</code>。如果你启动的是原生 UEFI 模式，那么就可以看到上文所示的 UEFI启动管理器配置。如果你启动的是 BIOS 兼容模式，那么会看到类似以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fatal: Couldn<span class="string">'t open either sysfs or procfs directories for accessing EFI variables.</span></span><br><span class="line"><span class="string">Try '</span>modprobe efivars<span class="string">' as root.</span></span><br></pre></td></tr></table></figure>

<p>如果启动了其他操作系统，你可以尝试运行该操作系统的内置实用程序，读取 UEFI 启动管理器，并查看是否显示了明确输出或类似错误。或者你可以检查系统日志并搜索“efi”和/或“uefi”，从中可能发现蛛丝马迹。</p>
<h3 id="启用原生-UEFI-启动"><a href="#启用原生-UEFI-启动" class="headerlink" title="启用原生 UEFI 启动"></a>启用原生 UEFI 启动</h3><p>若要启用原生 UEFI 模式的启动，那么操作系统安装介质必须明确符合我们刚刚说明的所有规范：具有 GUID 分区表，和 EFI 系统分区，启动装载程序位于正确的“回退”路径 (Fallback path) 中——\EFI\BOOT\BOOTx64.EFI（其他平台可能会有其他名称）。如果无法以原生 UEFI 模式启动安装介质，并且无法查出原因，那么请检查安装介质是否满足上述条件。显然，当使用 livecd-iso-to-disk 工具将 Fedora 映像写入 USB 存储器时，你必须传递 <code>--efi</code> 参数，才能将存储器配置为可用 UEFI 模式启动。</p>
<h3 id="强制使用-BIOS-兼容启动"><a href="#强制使用-BIOS-兼容启动" class="headerlink" title="强制使用 BIOS 兼容启动"></a>强制使用 BIOS 兼容启动</h3><p>如果你的固件难以通过 BIOS 兼容模式从可移动介质启动，但是你又确实想通过这种方式启动，那么可以使用一些小把戏：完全禁用该介质的原生 UEFI 启动模式。可以通过清除所有 EFI 系统分区来轻松执行此操作（或者，如果使用 livecd-iso-to-disk 从 Fedora 映像创建 USB存储器，那么只需去掉 <code>--efi</code> 参数，存储器就会变为不可通过 UEFI 模式启动）。如果执行完此操作以后，你的固件仍然无法以 BIOS 兼容模式启动介质，那么就去吐槽你的固件供应商吧（如果还没吐槽过）。</p>
<h3 id="磁盘格式（MBR-vs-GPT）"><a href="#磁盘格式（MBR-vs-GPT）" class="headerlink" title="磁盘格式（MBR vs. GPT）"></a>磁盘格式（MBR vs. GPT）</h3><p>其他注意事项如下：</p>
<ul>
<li><p>如果想执行“BIOS 兼容”类型的安装，那么需要安装到 MBR 格式的磁盘。</p>
</li>
<li><p>如果想执行原生 UEFI 安装，那么需要安装到 GPT 格式的磁盘。</p>
</li>
</ul>
<p>当然，为了给用户找不自在，许多固件可以通过 BIOS 模式从 GPT 格式的磁盘启动。事实上，从技术层面而言，也要求 UEFI 固件能从 MBR 格式的磁盘以 UEFI 模式启动（虽然无法保证）。但是你应当尽可能避免这种情况。这些注意事项非常重要，因为许多用户都曾深受其害。例如，以原生 UEFI 模式启动操作系统安装程序，然后试图直接安装到 MBR 格式的磁盘是非常不明智的。很有可能失败。多数现代操作系统安装程序将把磁盘自动重新格式化为正确格式（如果你允许安装程序彻底清除磁盘数据），但是，如果你尝试让安装程序“对此 MBR 格式的磁盘执行原生 UEFI 安装，并且不要重新格式化这块磁盘，因为上面有重要数据”，那么就很有可能失败，尽管技术层面而言，UEFI 规范提到了这种配置。具体而言，至少 Windows 和 Fedora 会明确禁止这种配置。</p>
<h3 id="检查磁盘格式"><a href="#检查磁盘格式" class="headerlink" title="检查磁盘格式"></a>检查磁盘格式</h3><p>你可以使用 parted 实用程序检查给定磁盘的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[adamw@adam Downloads]$ sudo parted /dev/sda</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">'help'</span> to view a list of commands.</span><br><span class="line">(parted) p</span><br><span class="line">Model: ATA C300-CTFDDAC128M (scsi)</span><br><span class="line">Disk /dev/sda: 128GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number Start End Size Type File system Flags</span><br><span class="line">1 1049kB 525MB 524MB primary ext4 boot</span><br><span class="line">2 525MB 128GB 128GB primary lvm</span><br><span class="line"></span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Partition table: msdos</code> 那一行了吗？这是一块 MBR/MS-DOS 格式的磁盘。如果是 GPT 格式的磁盘，会显示 gpt。你可以从 parted 中通过执行 mklabel gpt 或 mklabel msdos 将磁盘重新格式化为其他类型分区表。这会破坏磁盘内容。</p>
<p>对于多数操作系统的安装程序而言，如果你采用的磁盘配置会清空目标磁盘的所有内容，那么根据执行的安装类型，安装程序就会自动使用最合适的配置重新格式化磁盘。但是如果你想使用现有磁盘而不格式化，那么你需要检查该磁盘的格式并三思而后行。</p>
<h3 id="执行手动分区时处理-EFI-系统分区"><a href="#执行手动分区时处理-EFI-系统分区" class="headerlink" title="执行手动分区时处理 EFI 系统分区"></a>执行手动分区时处理 EFI 系统分区</h3><p>我只能针对 Fedora 给出权威建议，但是其中的主要内容可能也适用于其他发行版/操作系统。</p>
<p>执行原生 UEFI 安装，并且采用 GPT 格式的磁盘时，或者允许 Fedora 重新格式化磁盘（通过删除所有现有分区）时，如果允许 Fedora 自动处理分区，那么 Fedora 就会自动处理 EFI 系统分区。</p>
<p>但是，如果使用自定义分区，Fedora 会要求指定 EFI 系统分区，以供安装程序使用。如果不执行此步骤，安装程序会报错（错误消息的含义不明）并拒绝启动安装。</p>
<p>因此，如果执行原生 UEFI 安装并使用自定义分区，需要确保类型为“EFI 系统分区”的分区已挂载到 /boot/efi（这是 Fedora 查找 EFI 系统分区的路径）。如果系统上存在现有 EFI 系统分区，那么仅需将其挂载点设置为 /boot/efi 即可。如果还没有 EFI 系统分区，那么请创建一个分区，将其类型设置为 EFI 系统分区，大小至少为 <code>200MB</code>（建议 <code>500MB</code>），然后将其挂载点设置为 <code>/boot/efi</code>。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>上文解释了 UEFI 的启动原理(至少解释得差不多了)。我这种描述方法应该还可以吧？</p>
<p>但是，UEFI 并不完美，也有许多问题。</p>
<p>细心的读者可能已经留意，我曾经提到过，UEFI 规范提供了一种机制。这种说法很严谨，也很重要。由于 UEFI 规范是一种“广泛共识”，因此其主要缺点之一（就特定方面而言）是并未提供具体实现。</p>
<p>如果仔细阅读 UEFI 规范，就会发现 UEFI 规范的基本方式是定义 UEFI 兼容固件必须支持的一系列功能。但是 UEFI 规范并没有严格规定这些功能的具体实现方法。</p>
<p>因此，UEFI 规范只要求系统固件必须遵循其中描述的所有内容，以便满足 UEFI 兼容固件的要求。但是，规范本身未规定操作系统“应该”或“必须”怎么做，并且 UEFI 规范也没有规定固件不得支持（或者不期望支持）的功能。换言之，在制定 UEFI 固件时，需要支持 GPT 格式的磁盘和 FAT 格式的 EFI 系统分区，并且必须以标准格式读取 UEFI 启动管理器项等等——但是也可以随意添加其他未规定的功能。</p>
<p>从 UEFI 规范中不难发现其中的隐喻——UEFI 规范仔细设置了一种良好机制，用于在固件层处理操作系统（或其他启动项）选择。但是 UEFI 规范并不要求一定要这么做，其他广受赞誉的规范也没有类似规定。</p>
<p>因此，在实际使用时，我们可能遇到各种复杂情况。例如，Apple Mac 的 HFS+ 分区中随附了某些启动装载程序。UEFI 规范提到，UEFI 兼容固件必须支持特定 GPT 分区类型的 UEFI FAT 分区（标识为“EFI 系统分区”），但是 UEFI 规范并没有提到固件不能识别其他文件系统类型并从中加载启动装载程序。（此类分区是否应视为“EFI 系统分区”，这很难回答，在此不做探讨。）</p>
<p>要是所有厂商都能按照 UEFI 规范严格使用 EFI 系统分区，那就不会有这么多问题了。但是 Apple 毕竟是 Apple，它的产品设计领先于其他厂商，率先设计出了可以从 HFS+ 分区读取和加载代码的固件，导致现在其他厂商不得不紧随 Apple 的脚步，除非他们不打算支持 Mac。在启动过程设计中，Apple 进行的工作远超出 UEFI 规范的范围，因此，如果你想让其他操作系统以美观的图标或其他形式显示在 Mac 的图形启动菜单上，你所要做的操作将超出 UEFI 规范的建议范围。</p>
<h2 id="安全启动-Secure-Boot"><a href="#安全启动-Secure-Boot" class="headerlink" title="安全启动 (Secure Boot)"></a>安全启动 (Secure Boot)</h2><p>我们最后要介绍的，就是安全启动 (Secure Boot)。</p>
<p>安全启动 (Secure Boot) 并不神奇，也不复杂。才怪。安全启动 (Secure Boot) 复杂得要命，但是其理论并不复杂。安全启动 (Secure Boot) 本身也并不邪恶。事实就是如此，你也应当认同这一事实，除非你认为GPG也有恶意。</p>
<p>在 UEFI 规范（2.4A 版本）的第 28 章对安全启动 (Secure Boot) 进行了定义。这种机制事实上非常明智。但是其原理却非常简单。<code>UEFI 规范规定固件可以包含一系列签名，并拒绝运行未签名或签名与固件中包含的签名不一致的 EFI 可执行文件</code>。</p>
<h2 id="实际使用安全启动-Secure-Boot"><a href="#实际使用安全启动-Secure-Boot" class="headerlink" title="实际使用安全启动 (Secure Boot)"></a>实际使用安全启动 (Secure Boot)</h2><p>有关安全启动 (Secure Boot) 的所有不满并不针对安全启动 (Secure Boot) 机制本身——虽然发出这些不满的人可能不这么认为——而是针对安全启动 (Secure Boot) 在实际操作中的特定实现方式。</p>
<p>我们唯一在意的是，对于预装 Windows 8 或更高版本 Windows 的 PC 而言，安全启动 (Secure Boot) 是默认开启的。</p>
<p>微软将这些称为“Windows 硬件认证要求”。这些要求并不是什么绝密内容，所有人都可以在互联网上阅读。</p>
<p>你最好读一遍，但是我对其内容进行了总结。</p>
<p>符合微软认证要求的计算机必须满足以下条件：</p>
<ul>
<li><p>默认启用安全启动 (Secure Boot)（服务器除外）</p>
</li>
<li><p>在其信任密钥列表中包含微软的密钥</p>
</li>
<li><p>启用安全启动 (Secure Boot) 时，必须禁用 BIOS 兼容模式（如果没记错的话，UEFI 规范也有此要求）</p>
</li>
<li><p>支持签名黑名单</p>
</li>
</ul>
<p>符合微软认证要求的 x86 计算机 还必须满足以下附加条件：</p>
<ul>
<li><p>允许 自然人禁用安全启动 (Secure Boot)</p>
</li>
<li><p>允许 自然人启用自定义模式，以及修改固件的信任密钥列表</p>
</li>
</ul>
<p>符合微软认证要求的 ARM 计算机 还必须满足以下附加条件：</p>
<ul>
<li><p>不允许 自然人禁用安全启动 (Secure Boot)</p>
</li>
<li><p>不允许 自然人启用自定义模式，以及修改固件的信任密钥列表</p>
</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>以下内容是我在管理系统启动方面的一般建议，不保证其准确性、可靠性或安全性。</p>
<ul>
<li><p>如果可以的话，每台计算机只安装一个操作系统。如果你需要一个以上操作系统，那就多买几台计算机，或使用虚拟机。这么做的话，事情就简单多了，而且无论你的固件是 BIOS 或 UEFI，或在 UEFI 系统上使用 BIOS 兼容启动，都没什么关系了。你在使用计算机时也会轻松许多。</p>
</li>
<li><p>如果你确实需要在每台计算机上安装多个操作系统，那么请在每块磁盘上至少安装一个操作系统。如果你比较熟悉 BIOS 启动，而且也不需要安全启动 (Secure Boot) 功能，在这种情况下，对于 UEFI 系统，请优先使用 BIOS 兼容启动。这样一来，可能不会有那么多麻烦，也不会造成数据丢失。如果每块磁盘只安装一个操作系统，那么你也可以混合使用原生 UEFI 和 BIOS 兼容模式。</p>
</li>
<li><p>如果你坚持要在每块磁盘上安装多个操作系统，那么请先理解本文所写内容。这么做无异于自作孽，不可活，出了问题可别责怪操作系统供应商。另外，在这种情况下，也不要混用原生 UEFI 和 BIOS 兼容模式，否则就是雪上加霜。</p>
</li>
<li><p>如果你在使用 UEFI 原生启动，并且不打算自己编译内核/内核模块或在 Linux 上使用 NVIDIA/ATI 私有驱动程序，那么最好启用安全启动 (Secure Boot)。这不会有什么副作用，反而可以带来额外的安全性，用以应对某些卑鄙的攻击类型（尽管目前很少被利用）。</p>
</li>
<li><p>如果打算编译内核/内核模块或使用 NVIDIA/ATI 私有驱动程序，那就最好禁用安全启动 (Secure Boot)。或者你可以启用安全启动 (Secure Boot)，然后阅读有关配置信任链和对内核/内核模块签名的说明。但是这一过程至少需要好几天。</p>
</li>
<li><p>不要在 MBR 格式的磁盘上进行原生 UEFI 安装，也不要在 GPT 格式的磁盘上进行 BIOS 兼容安装（如果没记错的话，除非你的磁盘大小大于 2.2TB，因为 MBR 格式无法识别那么大的磁盘。如果想在那么大的磁盘上进行 BIOS 兼容安装，那么你可能会卡在 BIOS+GPT 的组合上。虽然这种组合可以正常运行，但是有点不靠谱，而且会牵涉到臭名昭著的“BIOS Boot 分区”）。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>UEFI</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：解决Win2k无法安装vm-tools、以及安装MASM汇编器连接器</title>
    <url>/2021/05/23/win2k-vm-tools-problem-and-install-masm.html</url>
    <content><![CDATA[<p>本文配合极客时间《操作系统实战45讲》，因而学习《汇编第四版》使用Win2k系统。</p>
<p>参考前一篇 <a href="https://izhaojie.com/2021/05/21/assembly-preparing.html">汇编：8086CPU寻址模式、Debug程序用法</a>。</p>
<h2 id="Win2k无法安装vm-tools"><a href="#Win2k无法安装vm-tools" class="headerlink" title="Win2k无法安装vm-tools"></a>Win2k无法安装vm-tools</h2><ol>
<li>下载补丁：</li>
</ol>
<p><a href="https://pan.baidu.com/s/1ztioEwh1CPF-ojsaXNvLIA" target="_blank" rel="noopener">补丁链接</a> 提取码：5640</p>
<ol start="2">
<li>无法安装vm-tools的错误提示：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-win2k-vm-tools%E5%AE%89%E8%A3%85%E9%94%99%E8%AF%AF.png" alt="win2k无法安装vm-tools"></p>
<a id="more"></a>

<ol start="3">
<li>把下载的补丁iso文件，放入虚拟机光驱：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/2-%E5%8A%A0%E8%BD%BD%E8%A1%A5%E4%B8%81%E6%96%87%E4%BB%B6.png" alt="加载补丁文件"></p>
<p>安装补丁：在Win2k系统里，点我的电脑，双击光驱，打开补丁安装程序：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/3-%E5%AE%89%E8%A3%85%E8%A1%A5%E4%B8%81.png" alt="安装补丁"></p>
<p>一直点下一步，直到点完成，会重启系统。</p>
<ol start="4">
<li>重启Win2k后，就可以装vm-tools了：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/4-%E5%BC%80%E5%A7%8B%E5%AE%89%E8%A3%85vm-tools.png" alt="重新安装vm-tools"></p>
<ol start="5">
<li>最后要打开虚拟机的<code>启用拷贝粘贴功能</code>，用来拷贝MASM编译器文件到Win2k系统：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/5-%E8%AE%BE%E7%BD%AE%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4.png" alt="设置拷贝粘贴"></p>
<h2 id="安装汇编器MASM5-0"><a href="#安装汇编器MASM5-0" class="headerlink" title="安装汇编器MASM5.0"></a>安装汇编器MASM5.0</h2><ol>
<li>汇编器与连接器下载地址：</li>
</ol>
<p><a href="https://pan.baidu.com/s/1oNQgtnHvuS_XRbE1zlXNuA" target="_blank" rel="noopener">汇编器链接</a> 提取码：gfr2</p>
<ol start="2">
<li>解压 <code>masm5.0_包含linker.rar</code>，把解压的文件夹复制一下，然后在Win2k的C盘下粘贴。</li>
<li>取出文件夹内的 <code>MASM</code> 目录放到 <code>C:\</code> 盘下，搞定！</li>
<li>Win2k开始菜单，运行，输入command，打开dos，然后输入 <code>cd c:\masm</code> 切换到汇编器目录。</li>
<li>在dos里输入 <code>masm</code> 或 <code>link</code> 就能使用汇编器与连接器了：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/6-%E6%B1%87%E7%BC%96%E5%99%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5%E5%99%A8.png" alt="汇编器与连接器"></p>
<p>[完毕]</p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验13三题</title>
    <url>/2021/06/11/assembly-experiment13.html</url>
    <content><![CDATA[<h2 id="1、编写安装7ch号中断例程，显示0结尾的字符串"><a href="#1、编写安装7ch号中断例程，显示0结尾的字符串" class="headerlink" title="1、编写安装7ch号中断例程，显示0结尾的字符串"></a>1、编写安装7ch号中断例程，显示0结尾的字符串</h2><p>中断例程装载程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 8086实模式 中断例程装载程序</span><br><span class="line">; 中断号 7ch</span><br><span class="line">; 装载位置 0:200h</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset handler ; ds:si指向中断例程的代码</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,200h ; es:di指向中断例程装载位置</span><br><span class="line">    mov cx,offset handlerend - offset handler ; 中断例程长度</span><br><span class="line">    cld</span><br><span class="line">    rep movsb ; 串传输</span><br><span class="line"></span><br><span class="line">    ; 设置 7ch 号中断向量</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word ptr es:[7ch*4],200h</span><br><span class="line">    mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">handler:</span><br><span class="line">    ; 注意！下文中断例程装载程序，只提供 handler 标号的部分，即，</span><br><span class="line">    ; 中断处理程序开始 与 中断处理程序结束 包裹的部分</span><br><span class="line"></span><br><span class="line">    ; 中断处理程序开始</span><br><span class="line">    ; 显示0结尾的字符串</span><br><span class="line">    ; dh 行号、dl 列号、cl 颜色、ds:si指向字符串首</span><br><span class="line">    push si</span><br><span class="line">    push es</span><br><span class="line">    push di</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line">    push cx</span><br><span class="line"></span><br><span class="line">    mov ax,0b800h ; 显存开始位置</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov al,dh</span><br><span class="line">    mov dh,160</span><br><span class="line">    mul dh ; ax&#x3D;行号*160</span><br><span class="line">    mov dh,0</span><br><span class="line">    add dx,dx ; dx&#x3D;列号*2</span><br><span class="line">    add ax,dx</span><br><span class="line">    mov di,ax ; di&#x3D;行号*160+列号*2</span><br><span class="line"></span><br><span class="line">s:</span><br><span class="line">    mov al,[si]</span><br><span class="line">    cmp al,0</span><br><span class="line">    je ok</span><br><span class="line">    mov ah,cl</span><br><span class="line">    mov es:[di],ax</span><br><span class="line">    add di,2</span><br><span class="line">    inc si</span><br><span class="line">    jmp s</span><br><span class="line"></span><br><span class="line">ok:</span><br><span class="line">    pop cx</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    pop di</span><br><span class="line">    pop es</span><br><span class="line">    pop si</span><br><span class="line">    iret</span><br><span class="line">    ; 中断处理程序结束</span><br><span class="line">handlerend:</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>调用者程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">    db &quot;welcome to masm! &quot;,0</span><br><span class="line">data ends</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov dh,10</span><br><span class="line">    mov dl,10</span><br><span class="line">    mov cl,2</span><br><span class="line">    mov ax,data</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,0</span><br><span class="line">    int 7ch</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E5%AE%9E%E9%AA%8C131%E8%A3%85%E8%BD%BD%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91.png" alt="装载程序的编译执行"></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/2-%E5%AE%9E%E9%AA%8C131-%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="调用者程序执行结果"></p>
<h2 id="2、编写安装7ch号中断例程，模拟loop指令"><a href="#2、编写安装7ch号中断例程，模拟loop指令" class="headerlink" title="2、编写安装7ch号中断例程，模拟loop指令"></a>2、编写安装7ch号中断例程，模拟loop指令</h2><p>中断例程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 中断处理程序开始</span><br><span class="line">lp:</span><br><span class="line">    push bp</span><br><span class="line">    mov bp,sp</span><br><span class="line">    dec cx</span><br><span class="line">    jcxz lpret</span><br><span class="line">    add [bp+2],bx ; bx是转移位移</span><br><span class="line">lpret:</span><br><span class="line">    pop bp</span><br><span class="line">    iret</span><br><span class="line">; 中断处理程序结束</span><br></pre></td></tr></table></figure>

<p>调用者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,160*12</span><br><span class="line">    mov bx,offset s - offset se ; 这里的结果必须是负数，bx即转移位移</span><br><span class="line">    mov cx,80</span><br><span class="line">s:</span><br><span class="line">    mov byte ptr es:[di],&#39;!&#39;</span><br><span class="line">    add di,2</span><br><span class="line">    int 7ch ; 如果cx≠0，转移到标号s处</span><br><span class="line">se:</span><br><span class="line">    nop</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/3-%E5%AE%9E%E9%AA%8C132%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="3、补全程序，在屏幕2、4、6、8行显示英文诗"><a href="#3、补全程序，在屏幕2、4、6、8行显示英文诗" class="headerlink" title="3、补全程序，在屏幕2、4、6、8行显示英文诗"></a>3、补全程序，在屏幕2、4、6、8行显示英文诗</h2><p>源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 在 2 4 6 8 行显示4句英文诗</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    s1:     db &#39;Good,better,best,&#39;,&#39;$&#39;</span><br><span class="line">    s2:     db &#39;Never let it rest,&#39;,&#39;$&#39;</span><br><span class="line">    s3:     db &#39;Till good is better,&#39;,&#39;$&#39;</span><br><span class="line">    s4:     db &#39;And better,best.&#39;,&#39;$&#39;</span><br><span class="line">    s:      dw offset s1,offset s2, offset s3,offset s4</span><br><span class="line">    row:    db 2,4,6,8</span><br><span class="line"></span><br><span class="line">    start:</span><br><span class="line">        mov ax,cs</span><br><span class="line">        mov ds,ax</span><br><span class="line">        mov bx,offset s</span><br><span class="line">        mov si,offset row</span><br><span class="line">        mov cx,4</span><br><span class="line">    ok:</span><br><span class="line">        mov bh,0 ; 第0页</span><br><span class="line">        mov dh,[si] ; 行号</span><br><span class="line">        mov dl,0 ; 列号</span><br><span class="line">        mov ah,2 ; 调10h中断例程中的显示例程</span><br><span class="line">        int 10h ; 调bios的10h号例程</span><br><span class="line"></span><br><span class="line">        mov dx,ds:[bx] ; ds:dx执行要显示字符串首</span><br><span class="line">        mov ah,9 ; 调21h中断例程的9号例程</span><br><span class="line">        int 21h ; 调dos的21h号中断例程</span><br><span class="line"></span><br><span class="line">        inc si</span><br><span class="line">        add bx,2</span><br><span class="line"></span><br><span class="line">        loop ok</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/4-%E8%8B%B1%E6%96%87%E8%AF%97%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验14：从CMOS读取并显示时间</title>
    <url>/2021/06/11/assembly-experiment14.html</url>
    <content><![CDATA[<p>从 CMOS RAM 读取时间并显示到屏幕。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 显示CMOS中当前日期时间</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">src:</span><br><span class="line">    db 9,8,7,4,2,0 ; 年月日时分秒的地址</span><br><span class="line">dst:</span><br><span class="line">    db &#39;yy&#x2F;mm&#x2F;dd hh:mm:ss&#39;,0</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset src</span><br><span class="line">    mov di,offset dst</span><br><span class="line">    mov cx,6</span><br><span class="line">s:</span><br><span class="line">    mov dx,cx</span><br><span class="line">    mov al,[si]</span><br><span class="line">    out 70h,al ; 70h为地址端口</span><br><span class="line">    in al,71h ; 71h为数据端口</span><br><span class="line">    mov ah,al</span><br><span class="line">    mov cl,4</span><br><span class="line">    shr ah,cl ; 右移4位，ah为十进制的十位数</span><br><span class="line">    and al,00001111b ; al为十进制的个位数</span><br><span class="line">    add ah,30h</span><br><span class="line">    add al,30h ; 数值转字符形式</span><br><span class="line">    xor ah,al</span><br><span class="line">    xor al,ah</span><br><span class="line">    xor ah,al ; 交换ah al的值</span><br><span class="line">    mov [di],ax</span><br><span class="line">    add di,3</span><br><span class="line">    inc si</span><br><span class="line">    mov cx,dx</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,0</span><br><span class="line">    mov si,offset dst</span><br><span class="line">s1:</span><br><span class="line">    mov ch,0</span><br><span class="line">    mov cl,[si]</span><br><span class="line">    jcxz ok</span><br><span class="line">    mov ch,2 ; 绿色字</span><br><span class="line">    mov es:[di],cx</span><br><span class="line">    inc si</span><br><span class="line">    add di,2</span><br><span class="line">    jmp s1</span><br><span class="line">ok:</span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验15：安装新的int9中断例程</title>
    <url>/2021/06/11/assembly-experiment15.html</url>
    <content><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>安装一个新的int 9中断例程，功能是在DOS下，按下A键后，除非不松开，否则一松开就显示满屏幕的A。</p>
<p>这个程序在win2k的DOS下会有问题，dosbox中执行正常。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><a id="more"></a>

<p>汇编源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 实验15</span><br><span class="line">; 安装新的int9中断例程</span><br><span class="line">; 功能是在DOS下，按下A键，除非一直按住，只要松开就显示满屏幕的A</span><br><span class="line">; 此程序在DOS下有问题，在dosbox下执行正常</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">    db 128 dup (0)</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    cli</span><br><span class="line">    mov ax,stack</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,128</span><br><span class="line">    sti</span><br><span class="line"></span><br><span class="line">    push cs</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line"></span><br><span class="line">    mov si,offset int9 ; ds:si指向新int9中断例程的代码</span><br><span class="line">    mov di,204h        ; es:di指向新int9例程存放处</span><br><span class="line">    mov cx,offset int9end - offset int9</span><br><span class="line">    cld</span><br><span class="line">    rep movsb</span><br><span class="line"></span><br><span class="line">    ; 原int9入口地址保存在0:200h、0:202h</span><br><span class="line">    push es:[9*4]</span><br><span class="line">    pop es:[200h]</span><br><span class="line">    push es:[9*4+2]</span><br><span class="line">    pop es:[202h]</span><br><span class="line"></span><br><span class="line">    ; 中断向量表9号中断保存新入口地址</span><br><span class="line">    cli</span><br><span class="line">    mov word ptr es:[9*4],204h</span><br><span class="line">    mov word ptr es:[9*4+2],0</span><br><span class="line">    sti</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">; 新int9中断例程</span><br><span class="line">int9:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    in al,60h</span><br><span class="line"></span><br><span class="line">    pushf</span><br><span class="line">    call dword ptr cs:[200h] ; 此中断执行时，cs&#x3D;0</span><br><span class="line"></span><br><span class="line">    cmp al,1eh+80h ; A按键的通码1eh，断码&#x3D;通码+80h</span><br><span class="line">    jne int9ret</span><br><span class="line"></span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,2000</span><br><span class="line">s:</span><br><span class="line">    mov byte ptr es:[bx],&#39;A&#39;</span><br><span class="line">    add bx,2</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">int9end:</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/Untitled.gif" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：指令系统总结</title>
    <url>/2021/06/11/assembly-instruction-system.html</url>
    <content><![CDATA[<p>指令系统总结：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/%E6%8C%87%E4%BB%A4%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93.png" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：实验16：安装新的7ch中断例程</title>
    <url>/2021/06/16/assembly-experiment16.html</url>
    <content><![CDATA[<p>中断例程装载程序源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 安装新的 7ch 中断例程，实现如下功能的子程序：</span><br><span class="line">; 1) 清屏</span><br><span class="line">; 2) 设置前景色</span><br><span class="line">; 3) 设置背景色</span><br><span class="line">; 4) 向上滚动一行</span><br><span class="line"></span><br><span class="line">; 入口参数：</span><br><span class="line">; ah&#x3D;功能号：0清屏，1前景色，2背景色，3向上滚动一行</span><br><span class="line">; 对于1、2号功能，用al传递颜色值，范围0~7的整数</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">    mov ax,cs</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov si,offset setscreent ; ds:si指向中断例程的代码</span><br><span class="line"></span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,200h ; es:di指向中断例程装载位置</span><br><span class="line">    mov cx,offset setsrcend - offset setscreent ; 中断例程长度</span><br><span class="line">    cld</span><br><span class="line">    rep movsb ; 串传输</span><br><span class="line"></span><br><span class="line">    ; 设置 7ch 号中断向量</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov word ptr es:[7ch*4],200h</span><br><span class="line">    mov word ptr es:[7ch*4+2],0</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">; 中断处理程序开始</span><br><span class="line">setscreent:</span><br><span class="line">    jmp short set ; 此指令占2字节</span><br><span class="line">    ; 此dw数据开始地址为 0:200h入口地址+2 即0:202h</span><br><span class="line">    ; sub1为数据标号，dw sub1相当于dw offset sub1</span><br><span class="line">    dw 200h+sub1-setscreent,200h+sub2-setscreent,200h+sub3-setscreent,200h+sub4-setscreent</span><br><span class="line">set:</span><br><span class="line">    push bx</span><br><span class="line">    cmp ah,3  ; 判断功能号是否大于3</span><br><span class="line">    ja sret</span><br><span class="line">    mov bl,ah</span><br><span class="line">    mov bh,0</span><br><span class="line">    add bx,bx ; ah中的功能号*2&#x3D;table表中的偏移</span><br><span class="line">    call word ptr cs:[bx+202h] ; 此中断执行时，cs&#x3D;0</span><br><span class="line">sret:</span><br><span class="line">    pop bx</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">sub1: ; 清屏</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,0 ; 显存的偶地址单元为字符</span><br><span class="line">    mov cx,2000</span><br><span class="line">sub1s:</span><br><span class="line">    mov byte ptr es:[bx],&#39; &#39; ; 空格填充屏幕</span><br><span class="line">    add bx,2</span><br><span class="line">    loop sub1s</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">sub2: ; 设置字体颜色</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,1 ; 显存的奇地址单元为属性</span><br><span class="line">    mov cx,2000</span><br><span class="line">sub2s:</span><br><span class="line">    and byte ptr es:[bx],11111000b</span><br><span class="line">    or es:[bx],al</span><br><span class="line">    add bx,2</span><br><span class="line">    loop sub2s</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">sub3: ; 设置背景色</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line">    mov cl,4</span><br><span class="line">    shl al,cl</span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,1</span><br><span class="line">    mov cx,2000</span><br><span class="line">sub3s:</span><br><span class="line">    and byte ptr es:[bx],10001111b</span><br><span class="line">    or es:[bx],al</span><br><span class="line">    add bx,2</span><br><span class="line">    loop sub3s</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">sub4: ; 向上滚动一行</span><br><span class="line">    push cx</span><br><span class="line">    push si</span><br><span class="line">    push di</span><br><span class="line">    push es</span><br><span class="line">    push ds</span><br><span class="line">    mov si,0b800h</span><br><span class="line">    mov es,si</span><br><span class="line">    mov ds,si</span><br><span class="line">    mov si,160 ; ds:si指向n+1行</span><br><span class="line">    mov di,0   ; es:di指向n行</span><br><span class="line">    cld</span><br><span class="line">    mov cx,24  ; 共复制24行</span><br><span class="line">sub4s:</span><br><span class="line">    push cx</span><br><span class="line">    mov cx,160</span><br><span class="line">    rep movsb  ; 一行复制完，si+&#x3D;160，di+&#x3D;160</span><br><span class="line">    pop cx</span><br><span class="line">    loop sub4s</span><br><span class="line">    mov cx,80</span><br><span class="line">    mov si,0</span><br><span class="line">sub4s1:</span><br><span class="line">    mov byte ptr [160*24+si],&#39; &#39;  ; 最后一行清空</span><br><span class="line">    add si,2</span><br><span class="line">    loop sub4s1</span><br><span class="line">    pop ds</span><br><span class="line">    pop es</span><br><span class="line">    pop di</span><br><span class="line">    pop si</span><br><span class="line">    pop cx</span><br><span class="line">    ret</span><br><span class="line">; 中断处理程序结束</span><br><span class="line"></span><br><span class="line">setsrcend:</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>测试源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 测试新的 7ch 中断例程</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">    ; 测试清屏</span><br><span class="line">    mov ah,0</span><br><span class="line">    int 7ch</span><br><span class="line"></span><br><span class="line">    ; 测试绿色字</span><br><span class="line">    mov ah,1</span><br><span class="line">    mov al,2</span><br><span class="line">    int 7ch</span><br><span class="line"></span><br><span class="line">    ; 测试红底</span><br><span class="line">    mov ah,2</span><br><span class="line">    mov al,4</span><br><span class="line">    int 7ch</span><br><span class="line"></span><br><span class="line">    ; 向上滚动一行</span><br><span class="line">    mov ah,3</span><br><span class="line">    int 7ch</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<img src="/2021/06/16/assembly-experiment16/Untitled.gif" class="">
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编：史上最全注释，王爽汇编语言，课程设计2源码</title>
    <url>/2021/06/21/assembly-course-design2.html</url>
    <content><![CDATA[<p>课程设计2</p>
<p>题目见 汇编语言 第四版 作者王爽 p312</p>
<p>这篇文章是《汇编语言 第四版》的完结篇。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>1、vm虚拟机中安装win98se，以下称为<code>win98</code>。</p>
<p>2、成功安装系统后，虚拟机添加一个新软盘（需要创建软盘映像.img文件）。</p>
<p>3、启动win98系统，将下文源码编译，然后执行程序（需要masm汇编器）。</p>
<p>4、关闭win98系统，在虚拟机中，设置<code>软盘</code>为启动盘。</p>
<p>5、启动虚拟机，我们自己写的程序就能执行了。</p>
<p>如果用两个硬盘，即添加新硬盘代替软盘，然后设新硬盘为启动盘后，启动失败（暂不管此问题）！</p>
<h2 id="程序结构"><a href="#程序结构" class="headerlink" title="程序结构"></a>程序结构</h2><p>软盘：第1扇区存放我们的引导程序，第2-3扇区存放主程序，实现4个功能。</p>
<p>硬盘1：是win98系统盘，第1扇区有mbr引导程序。</p>
<p>开机后，软盘为启动盘，加载我们自己的引导程序，执行引导程序，然后加载2-3扇区的主程序。</p>
<h2 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h2><p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt=""></p>
<a id="more"></a>

<h2 id="汇编源码"><a href="#汇编源码" class="headerlink" title="汇编源码"></a>汇编源码</h2><p>源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">; 课程设计2</span><br><span class="line">; 实现了4个功能的程序以下称为主程序</span><br><span class="line"></span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">    ; 安装我们自己的引导程序到软盘a，占1个扇区</span><br><span class="line">    call inst_my_boot</span><br><span class="line"></span><br><span class="line">    ; 安装主程序到软盘a，占2个扇区</span><br><span class="line">    call inst_my_main</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">;---------------- 安装程序 ----------------</span><br><span class="line">inst_my_boot:</span><br><span class="line">    mov bx,cs</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,offset my_boot ; es:bx指向my_boot</span><br><span class="line"></span><br><span class="line">    ; 写入内容到 软盘A，0面，0道，1扇区</span><br><span class="line">    mov dl,0 ; 软盘A</span><br><span class="line">	mov dh,0 ; 0面</span><br><span class="line">    mov ch,0 ; 0道</span><br><span class="line">	mov cl,1 ; 第1扇区</span><br><span class="line">	mov al,1 ; 写1个扇区</span><br><span class="line">	mov ah,3 ; 写</span><br><span class="line">	int 13h</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">inst_my_main:</span><br><span class="line">    mov bx,cs</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,offset my_main ; es:bx指向my_main</span><br><span class="line"></span><br><span class="line">    ; 写入内容到 软盘A，0面，0道，2扇区</span><br><span class="line">    mov dl,0 ; 软盘A</span><br><span class="line">	mov dh,0 ; 0面</span><br><span class="line">    mov ch,0 ; 0道</span><br><span class="line">	mov cl,2 ; 第2扇区</span><br><span class="line">	mov al,2 ; 写2个扇区</span><br><span class="line">	mov ah,3 ; 写</span><br><span class="line">	int 13h</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">;---------------- 引导程序 ----------------</span><br><span class="line">my_boot:</span><br><span class="line">    ; 设栈</span><br><span class="line">    cli</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov ss,ax</span><br><span class="line">    mov sp,7c00h</span><br><span class="line">    sti</span><br><span class="line"></span><br><span class="line">    ; 装载新int9h中断例程</span><br><span class="line">    call load_newint9</span><br><span class="line"></span><br><span class="line">    ; 将主程序拷贝到7e00h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,7e00h</span><br><span class="line"></span><br><span class="line">    ; 读取 软盘A，0面，0道，2扇区 开始的2个扇区 到0:7e00h</span><br><span class="line">    mov dl,0 ; 软盘A</span><br><span class="line">	mov dh,0 ; 0面</span><br><span class="line">    mov ch,0 ; 0道</span><br><span class="line">	mov cl,2 ; 第2扇区</span><br><span class="line">	mov al,2 ; 复制2个扇区</span><br><span class="line">	mov ah,2 ; 读取</span><br><span class="line">	int 13h</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    push bx</span><br><span class="line">    mov bx,7e00h</span><br><span class="line">    push bx</span><br><span class="line">    retf ; 从栈中取2字 设CS:IP&#x3D;0:7e00h 并从此处开始执行</span><br><span class="line"></span><br><span class="line">; 装载新int9h中断例程</span><br><span class="line">load_newint9:</span><br><span class="line">    push ds</span><br><span class="line">    push si</span><br><span class="line">    push es</span><br><span class="line">    push di</span><br><span class="line">    push cx</span><br><span class="line"></span><br><span class="line">    push cs ; 引导程序执行时，cs:ip&#x3D;0:7c00h</span><br><span class="line">    pop ds</span><br><span class="line"></span><br><span class="line">    mov cx,0</span><br><span class="line">    mov es,cx</span><br><span class="line"></span><br><span class="line">    mov si,newint9-my_boot+7c00h ; ds:si指向新int9例程</span><br><span class="line">    mov di,204h ; es:di指向新int9例程装载位置</span><br><span class="line">    mov cx,newint9end-newint9</span><br><span class="line">    cld</span><br><span class="line">    rep movsb</span><br><span class="line"></span><br><span class="line">    ; 保存旧的int9h中断向量</span><br><span class="line">    push es:[9*4]</span><br><span class="line">    pop es:[200h]</span><br><span class="line">    push es:[9*4+2]</span><br><span class="line">    pop es:[202h]</span><br><span class="line"></span><br><span class="line">    pop cx</span><br><span class="line">    pop di</span><br><span class="line">    pop es</span><br><span class="line">    pop si</span><br><span class="line">    pop ds</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">newint9:</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line"></span><br><span class="line">    in al,60h</span><br><span class="line"></span><br><span class="line">    pushf</span><br><span class="line">    call dword ptr cs:[200h] ; 此newint9中断放在0:204h处，此中断执行时cs&#x3D;0</span><br><span class="line"></span><br><span class="line">    cmp al,3bh ; f1扫描码</span><br><span class="line">    je chgcolor</span><br><span class="line">    cmp al,01h ; esc键扫描码</span><br><span class="line">    je int9ret</span><br><span class="line">    jmp newint9ret</span><br><span class="line"></span><br><span class="line">backmain:</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line"></span><br><span class="line">    add sp,4 ; 跳过cs:ip</span><br><span class="line">    popf</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    push bx</span><br><span class="line">    mov bx,7e00h</span><br><span class="line">    push bx</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">int9ret:</span><br><span class="line">    ; 恢复原int9中断向量，原中断向量保存在0:200h, 0:202h</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov es,ax</span><br><span class="line">    cli</span><br><span class="line">    push es:[200h]</span><br><span class="line">    pop es:[9*4]</span><br><span class="line">    push es:[202h]</span><br><span class="line">    pop es:[9*4+2]</span><br><span class="line">    sti</span><br><span class="line">    jmp backmain</span><br><span class="line"></span><br><span class="line">chgcolor:</span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov bx,1</span><br><span class="line">    mov cx,17</span><br><span class="line">chgcolor_s1:</span><br><span class="line">    inc byte ptr es:[bx]</span><br><span class="line">    add bx,2</span><br><span class="line">    loop chgcolor_s1</span><br><span class="line"></span><br><span class="line">newint9ret:</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line">    iret</span><br><span class="line"></span><br><span class="line">newint9end:</span><br><span class="line">    nop</span><br><span class="line"></span><br><span class="line">; 因为引导程序占512字节，这里填充512字节0，作为扇区结束，</span><br><span class="line">; 防止引导程序不够512字节，而复制下面的代码到1扇区内</span><br><span class="line">db 512 dup (0)</span><br><span class="line"></span><br><span class="line">;--------------------- 主程序 ---------------------</span><br><span class="line">my_main:</span><br><span class="line">    jmp main_start</span><br><span class="line">    menu1     db &#39;1) reset pc&#39;,0</span><br><span class="line">    menu2     db &#39;2) start system&#39;,0</span><br><span class="line">    menu3     db &#39;3) clock&#39;,0</span><br><span class="line">    menu4     db &#39;4) set clock&#39;,0</span><br><span class="line">    menu_addr dw menu1-my_main+7e00h, menu2-my_main+7e00h, menu3-my_main+7e00h, menu4-my_main+7e00h</span><br><span class="line">    timestr   db &#39;yy&#x2F;mm&#x2F;dd hh:mm:ss&#39;,0</span><br><span class="line">    timeaddr  db 9,8,7,4,2,0</span><br><span class="line">    strbuffer db 100 dup (0) ; 输入字符串缓冲区</span><br><span class="line"></span><br><span class="line">main_start:</span><br><span class="line">    ; 初始化数据段寄存器</span><br><span class="line">    mov ax,0</span><br><span class="line">    mov ds,ax</span><br><span class="line"></span><br><span class="line">    call clr_src</span><br><span class="line">    call show_menu</span><br><span class="line">    call choose_item</span><br><span class="line"></span><br><span class="line">choose_item: ; 选择菜单项</span><br><span class="line">    mov si,strbuffer-my_main+7e00h</span><br><span class="line">    call getstr ; 输入字符串，回车确认，ds:si指向字符串缓冲区</span><br><span class="line"></span><br><span class="line">    cmp byte ptr [si],&#39;1&#39;</span><br><span class="line">    je item1</span><br><span class="line">    cmp byte ptr [si],&#39;2&#39;</span><br><span class="line">    je item2</span><br><span class="line">    cmp byte ptr [si],&#39;3&#39;</span><br><span class="line">    je item3</span><br><span class="line">    cmp byte ptr [si],&#39;4&#39;</span><br><span class="line">    je item4</span><br><span class="line">    jmp main_start ; 其他输入时，重新显示菜单</span><br><span class="line"></span><br><span class="line">item1:</span><br><span class="line">    mov bx,0ffffh</span><br><span class="line">    push bx</span><br><span class="line">    mov bx,0</span><br><span class="line">    push bx</span><br><span class="line">    retf ; 将从ffff:0处开始执行，会重启系统</span><br><span class="line"></span><br><span class="line">item2: ; 引导现有系统</span><br><span class="line">    ; 将原mbr拷贝到7c00h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,7c00h</span><br><span class="line"></span><br><span class="line">    ; 读取 硬盘c，0面，0道，1扇区 到0:7c00h</span><br><span class="line">    mov dl,80h ; 盘c</span><br><span class="line">	mov dh,0 ; 0面</span><br><span class="line">    mov ch,0 ; 0道</span><br><span class="line">	mov cl,1 ; 第1扇区</span><br><span class="line">	mov al,1 ; 复制1个扇区</span><br><span class="line">	mov ah,2 ; 读取</span><br><span class="line">	int 13h</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    push bx</span><br><span class="line">    mov bx,7c00h</span><br><span class="line">    push bx</span><br><span class="line">    retf</span><br><span class="line"></span><br><span class="line">item3:</span><br><span class="line">    call setnewint9</span><br><span class="line">    call show_dt</span><br><span class="line">    jmp main_start</span><br><span class="line"></span><br><span class="line">item4:</span><br><span class="line">    call clr_src</span><br><span class="line">    mov si,strbuffer-my_main+7e00h</span><br><span class="line">    call getstr</span><br><span class="line">    call set_dt ; ds:si指向字符串缓冲区</span><br><span class="line">    jmp main_start</span><br><span class="line"></span><br><span class="line">show_menu: ; 显示主程序菜单</span><br><span class="line">    push bx</span><br><span class="line">    push es</span><br><span class="line">    push si</span><br><span class="line">    push cx</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,160*10+32*2 ; 中间位置显示菜单，第10行第32列</span><br><span class="line">    mov di,menu_addr-my_main+7e00h ; 直接定址表</span><br><span class="line">    mov cx,4</span><br><span class="line">show_menu_s1:</span><br><span class="line">    mov si,[di] ; ds:di定位直接定址表</span><br><span class="line">    call show_str</span><br><span class="line">    add di,2</span><br><span class="line">    add bx,160 ; 跳到下一行</span><br><span class="line">    loop show_menu_s1</span><br><span class="line"></span><br><span class="line">    pop di</span><br><span class="line">    pop cx</span><br><span class="line">    pop si</span><br><span class="line">    pop es</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">clr_src: ; 清屏</span><br><span class="line">    push bx</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,0 ; 显存的偶地址单元为字符</span><br><span class="line">    mov cx,2000</span><br><span class="line">clr_src_s1:</span><br><span class="line">    mov byte ptr es:[bx],&#39; &#39; ; 空格填充</span><br><span class="line">    add bx,2</span><br><span class="line">    loop clr_src_s1</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 显示字符串，字符串以0结束</span><br><span class="line">; ds:si指向字符串开头</span><br><span class="line">; es:bx指向显存开始，对应屏幕上的位置</span><br><span class="line">show_str:</span><br><span class="line">    push si</span><br><span class="line">    push cx</span><br><span class="line">    push es</span><br><span class="line">    push bx</span><br><span class="line">show_str_s1:</span><br><span class="line">    mov cl,[si]</span><br><span class="line">    cmp cl,0</span><br><span class="line">    je show_str_ret</span><br><span class="line">    mov es:[bx],cl</span><br><span class="line">    add bx,2</span><br><span class="line">    inc si</span><br><span class="line">    jmp show_str_s1</span><br><span class="line">show_str_ret:</span><br><span class="line">    pop bx</span><br><span class="line">    pop es</span><br><span class="line">    pop cx</span><br><span class="line">    pop si</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 接受字符串输入</span><br><span class="line">; ds:si指向字符栈空间</span><br><span class="line">getstr:</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line">    push es</span><br><span class="line">    push di</span><br><span class="line"></span><br><span class="line">    mov ax,0b800h</span><br><span class="line">    mov es,ax</span><br><span class="line">    mov di,160*14+32*2 ; es:di为光标初始位置、字符串输入位置</span><br><span class="line">    ;mov di,0</span><br><span class="line">    call setcur</span><br><span class="line"></span><br><span class="line">    mov dx,0 ; 字符栈栈指针</span><br><span class="line">getstrs:</span><br><span class="line">    mov ah,0</span><br><span class="line">    int 16h ; 获取键盘缓冲区内容</span><br><span class="line">    cmp al,20h</span><br><span class="line">    jb nochar</span><br><span class="line">    cmp al,7eh</span><br><span class="line">    ja nochar ; 只能输入可见字符</span><br><span class="line">    mov ah,0</span><br><span class="line">    call charstack ; 字符入栈</span><br><span class="line">    mov ah,2</span><br><span class="line">    call charstack ; 显示栈中字符</span><br><span class="line">    jmp getstrs</span><br><span class="line"></span><br><span class="line">nochar:</span><br><span class="line">    cmp ah,0eh ; 退格键扫描码</span><br><span class="line">    je backspace</span><br><span class="line">    cmp ah,1ch ; 回车键扫描码</span><br><span class="line">    je enter</span><br><span class="line">    jmp getstrs</span><br><span class="line"></span><br><span class="line">backspace:</span><br><span class="line">    mov ah,1</span><br><span class="line">    call charstack ; 字符出栈</span><br><span class="line">    mov ah,2</span><br><span class="line">    call charstack</span><br><span class="line">    jmp getstrs</span><br><span class="line"></span><br><span class="line">enter:</span><br><span class="line">    mov al,0 ; 把0入栈，作为字符串结束</span><br><span class="line">    mov ah,0</span><br><span class="line">    call charstack</span><br><span class="line">    mov ah,2</span><br><span class="line">    call charstack</span><br><span class="line"></span><br><span class="line">    pop di</span><br><span class="line">    pop es</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 字符入栈、出栈、显示功能</span><br><span class="line">; ah&#x3D;功能号，0入栈，1出栈，2显示</span><br><span class="line">; ds:si指向字符栈空间</span><br><span class="line">; dx&#x3D;字符栈栈指针</span><br><span class="line">; 0号功能，al&#x3D;入栈字符</span><br><span class="line">; 1号功能，al&#x3D;返回的字符</span><br><span class="line">; 2号功能，es:di指向屏幕位置</span><br><span class="line">charstack: jmp short charstart</span><br><span class="line">table      dw charpush-my_main+7e00h,charpop-my_main+7e00h,charshow-my_main+7e00h</span><br><span class="line"></span><br><span class="line">charstart:</span><br><span class="line">    push bx</span><br><span class="line">    push di</span><br><span class="line">    push es</span><br><span class="line">    ;dx为charstack非局部变量，不要入栈</span><br><span class="line">    ;push dx</span><br><span class="line"></span><br><span class="line">    cmp ah,2 ; 功能号判断</span><br><span class="line">    ja sret</span><br><span class="line">    mov bl,ah</span><br><span class="line">    mov bh,0</span><br><span class="line">    add bx,bx ; 根据功能号取得对应的偏移地址</span><br><span class="line">    jmp word ptr table-my_main+7e00h[bx]</span><br><span class="line"></span><br><span class="line">charpush:</span><br><span class="line">    mov bx,dx</span><br><span class="line">    mov [si][bx],al</span><br><span class="line">    inc dx</span><br><span class="line">    jmp sret</span><br><span class="line"></span><br><span class="line">charpop:</span><br><span class="line">    cmp dx,0</span><br><span class="line">    je sret</span><br><span class="line">    dec dx</span><br><span class="line">    mov bx,dx</span><br><span class="line">    mov al,[si][bx]</span><br><span class="line">    jmp sret</span><br><span class="line"></span><br><span class="line">charshow:</span><br><span class="line">    ; es:di指向屏幕位置，由调用者传递</span><br><span class="line">    mov bx,0</span><br><span class="line">charshows:</span><br><span class="line">    cmp bx,dx</span><br><span class="line">    jne noempey</span><br><span class="line">    mov byte ptr es:[di],&#39; &#39;</span><br><span class="line">    call setcur</span><br><span class="line">    jmp sret</span><br><span class="line"></span><br><span class="line">noempey:</span><br><span class="line">    mov al,[si][bx]</span><br><span class="line">    mov es:[di],al</span><br><span class="line">    mov byte ptr es:[di+2],&#39; &#39; ; 清空后一个字符</span><br><span class="line">    inc bx</span><br><span class="line">    add di,2</span><br><span class="line">    jmp charshows</span><br><span class="line"></span><br><span class="line">sret:</span><br><span class="line">    pop es</span><br><span class="line">    pop di</span><br><span class="line">    pop bx</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">setcur: ; 设置光标到es:di位置</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line"></span><br><span class="line">    mov ax,di</span><br><span class="line">    mov dh,160</span><br><span class="line">    div dh</span><br><span class="line">    mov dh,al ; 行号</span><br><span class="line">    mov al,ah</span><br><span class="line">    mov ah,0</span><br><span class="line">    mov dl,2</span><br><span class="line">    div dl</span><br><span class="line">    mov dl,al ; 列号</span><br><span class="line">    mov ah,2 ; 设置光标位置</span><br><span class="line">    mov bh,0 ; 第0页</span><br><span class="line">    int 10h</span><br><span class="line"></span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 显示时间</span><br><span class="line">show_dt:</span><br><span class="line">    call get_dt</span><br><span class="line">    call delay</span><br><span class="line">    jmp show_dt</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 设置新的int9h中断向量</span><br><span class="line">setnewint9:</span><br><span class="line">    push es</span><br><span class="line">    push bx</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov es,bx</span><br><span class="line">    cli</span><br><span class="line">    mov word ptr es:[9*4],204h</span><br><span class="line">    mov word ptr es:[9*4+2],0</span><br><span class="line">    sti</span><br><span class="line">    pop bx</span><br><span class="line">    pop es</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 获取CMOS中的系统时间</span><br><span class="line">; ds:si从cmos对应地址取日期时间，ds:di转换后的日期时间字符串</span><br><span class="line">get_dt:</span><br><span class="line">    push si</span><br><span class="line">    push di</span><br><span class="line">    push cx</span><br><span class="line">    push ax</span><br><span class="line">    push es</span><br><span class="line">    push bx</span><br><span class="line"></span><br><span class="line">    mov si,timeaddr-my_main+7e00h</span><br><span class="line">    mov di,timestr-my_main+7e00h</span><br><span class="line">    mov cx,6</span><br><span class="line">get_dt_s1:</span><br><span class="line">    mov bx,cx</span><br><span class="line">    mov al,[si]</span><br><span class="line">    out 70h,al ; 70h为地址端口</span><br><span class="line">    in al,71h ; 71h为数据端口</span><br><span class="line">    mov ah,al</span><br><span class="line">    mov cl,4</span><br><span class="line">    shr ah,cl ; 右移4位，ah为十进制的十位数</span><br><span class="line">    and al,00001111b ; al为十进制的个位数</span><br><span class="line">    add ah,30h</span><br><span class="line">    add al,30h ; 数值转字符形式</span><br><span class="line">    xchg ah,al</span><br><span class="line">    mov [di],ax</span><br><span class="line">    add di,3</span><br><span class="line">    inc si</span><br><span class="line">    mov cx,bx</span><br><span class="line">    loop get_dt_s1</span><br><span class="line"></span><br><span class="line">    mov bx,0b800h</span><br><span class="line">    mov es,bx</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov si,timestr-my_main+7e00h</span><br><span class="line">    call show_str</span><br><span class="line"></span><br><span class="line">    pop bx</span><br><span class="line">    pop es</span><br><span class="line">    pop ax</span><br><span class="line">    pop cx</span><br><span class="line">    pop di</span><br><span class="line">    pop si</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 延时</span><br><span class="line">delay:</span><br><span class="line">    push ax</span><br><span class="line">    push dx</span><br><span class="line">    mov dx,6000h ; 循环6000000h次</span><br><span class="line">    mov ax,0</span><br><span class="line">delays1:</span><br><span class="line">    sub ax,1</span><br><span class="line">    sbb dx,0</span><br><span class="line">    cmp ax,0</span><br><span class="line">    jne delays1</span><br><span class="line">    cmp dx,0</span><br><span class="line">    jne delays1</span><br><span class="line">    pop dx</span><br><span class="line">    pop ax</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">; 设置系统时间</span><br><span class="line">set_dt:</span><br><span class="line">    push si</span><br><span class="line">    push di</span><br><span class="line">    push cx</span><br><span class="line">    push ax</span><br><span class="line">    push bx</span><br><span class="line"></span><br><span class="line">    mov di,timeaddr-my_main+7e00h</span><br><span class="line">    mov cx,6</span><br><span class="line">set_dt_s1:</span><br><span class="line">    mov ax,[si] ; al为十位数，ah为个位数</span><br><span class="line">    sub ah,30h</span><br><span class="line">    sub al,30h</span><br><span class="line">    and ah,00001111b ; 取个位数</span><br><span class="line">    mov bx,cx</span><br><span class="line">    mov cl,4</span><br><span class="line">    shl al,cl</span><br><span class="line">    or al,ah</span><br><span class="line">    mov cx,bx</span><br><span class="line">    mov ah,al</span><br><span class="line">    mov al,[di]</span><br><span class="line">    out 70h,al</span><br><span class="line">    mov al,ah</span><br><span class="line">    out 71h,al</span><br><span class="line">    inc di</span><br><span class="line">    add si,3</span><br><span class="line">    loop set_dt_s1</span><br><span class="line"></span><br><span class="line">    pop bx</span><br><span class="line">    pop ax</span><br><span class="line">    pop cx</span><br><span class="line">    pop di</span><br><span class="line">    pop si</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">db 1024 dup (0) ; 填充1k字节，原因同上</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E5%8A%9F%E8%83%BD1to2.gif" alt=""></p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/1-%E5%8A%9F%E8%83%BD3to4.gif" alt=""></p>
]]></content>
      <categories>
        <category>汇编实战</category>
      </categories>
      <tags>
        <tag>汇编实战</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的浮点数探秘</title>
    <url>/2021/08/12/float-in-python3.html</url>
    <content><![CDATA[<h2 id="查看Python的浮点数如何在内存中存储"><a href="#查看Python的浮点数如何在内存中存储" class="headerlink" title="查看Python的浮点数如何在内存中存储"></a>查看Python的浮点数如何在内存中存储</h2><p>下面的探讨主要针对Python3，在Python2中不一定适用。</p>
<p>Python的浮点数实现原理：<br>CPython实现有一个PyFloatObject的结构体，用来构造Python的浮点数类型：</p>
<p>typedef struct {<br>  PyObject_HEAD  # 这个对象包含：引用计数+对象类型，占8+8=16字节<br>  double ob_fval;   # 这个是存储浮点数的地方，Python的浮点数就是C的double，双精度<br>} PyFloatObject;</p>
<p>所以Python的浮点数类型占24字节：<br>引用计数+对象类型+双精度浮点数 = 8+8+8 = 24字节<br>不过Python3的整数长度无限，所以占字节数不定</p>
<p>用Python代码验证浮点数：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/py-float-1.png" alt=""></p>
<p>代码：</p>
<a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> string_at</span><br><span class="line"><span class="keyword">from</span> sys <span class="keyword">import</span> getsizeof</span><br><span class="line"><span class="keyword">from</span> binascii <span class="keyword">import</span> hexlify</span><br><span class="line">a=<span class="number">134.375</span></span><br><span class="line">buffer=hexlify(string_at(id(a),getsizeof(a)))</span><br><span class="line">print(buffer)</span><br><span class="line">buffer_float=buffer[len(buffer)<span class="number">-16</span>:]</span><br><span class="line">print(buffer_float)</span><br><span class="line">tmp=[buffer_float[i:i+<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(buffer_float),<span class="number">2</span>)]</span><br><span class="line">tmp=[bin(int(tmp[i].decode(),<span class="number">16</span>))[<span class="number">2</span>:].rjust(<span class="number">8</span>,<span class="string">'0'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(len(tmp)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>)]</span><br><span class="line">print(<span class="string">' '</span>.join(tmp))</span><br><span class="line">print(<span class="string">'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~'</span>)</span><br><span class="line">b = <span class="string">''</span>.join(tmp)</span><br><span class="line">S=b[<span class="number">0</span>]</span><br><span class="line">print(<span class="string">'符号位'</span>,S)</span><br><span class="line">E=b[<span class="number">1</span>:<span class="number">12</span>]</span><br><span class="line">print(<span class="string">'指数位'</span>,E)</span><br><span class="line">M=b[<span class="number">12</span>:]</span><br><span class="line">print(<span class="string">'尾数位'</span>,M)</span><br></pre></td></tr></table></figure>

<h3 id="探讨一下"><a href="#探讨一下" class="headerlink" title="探讨一下"></a>探讨一下</h3><p>十进制数 134.375 如何转换为二进制浮点数，并存储在内存中的：</p>
<p>134.375 等于二进制的 10000110.011，转换为IEEE754的浮点数格式：1.0000110011x2^7，其中首位1隐藏，尾数位=0000110011，符号位=0，指数位=(7+1023)的二进制=10000000110</p>
<p>134.375转换二进制小数的方法详见 <a href="https://blog.csdn.net/u014470361/article/details/79820892" target="_blank" rel="noopener">浮点数在内存中是怎么存储的？</a></p>
<p>十进制小数部分最后一位不是5时，小数部分与2相乘不会得到1.0，就无法准确转换为二进制，比如134.372，小数0.372如果允许60个二进制位，将转换为：</p>
<p>010111110011101101100100010110100001110010101,100000010000000</p>
<p>整数部分134二进制为：10000110，首位1隐藏，变成0000110(7位)，双精度52位尾数-7位整数部分=45位供小数存储。因为小数0.372无法准确转换为二进制，第46进行“向偶数舍入” [1]，变成：</p>
<p>010111110011101101100100010110100001110010110<br>010111110011101101100100010110100001110010101,100000010000000 (原60位小数)</p>
<p>用代码验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># 134.372 整数部分隐藏首位1 二进制=0000110</span></span><br><span class="line"><span class="comment"># 小数部分向偶数舍入后 二进制=010111110011101101100100010110100001110010110</span></span><br><span class="line"><span class="comment"># 指数二进制=10000000110</span></span><br><span class="line"><span class="comment"># 符号位=0</span></span><br><span class="line"><span class="comment"># S E M = 0,10000000110,0000110(整数)010111110011101101100100010110100001110010110(小数)</span></span><br><span class="line"><span class="comment"># 134.372 64位浮点数实际如下</span></span><br><span class="line">a = <span class="string">'0100000001100000110010111110011101101100100010110100001110010110'</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line">h = <span class="string">''</span></span><br><span class="line"><span class="keyword">while</span> i&lt;<span class="number">64</span>:</span><br><span class="line">    h += <span class="string">f'<span class="subst">&#123;int(a[i:i+<span class="number">8</span>],<span class="number">2</span>):x&#125;</span>'</span></span><br><span class="line">    i+=<span class="number">8</span></span><br><span class="line"><span class="comment"># 134.372 的浮点数十六进制</span></span><br><span class="line">print(h)  <span class="comment"># 4060cbe76c8b4396</span></span><br><span class="line"><span class="comment"># 复原</span></span><br><span class="line">print(struct.unpack(<span class="string">'!d'</span>, bytes.fromhex(h)))  <span class="comment"># 输出结果是 (134.372,)</span></span><br></pre></td></tr></table></figure>

<h3 id="十进制数转换浮点数步骤（双精度）"><a href="#十进制数转换浮点数步骤（双精度）" class="headerlink" title="十进制数转换浮点数步骤（双精度）"></a>十进制数转换浮点数步骤（双精度）</h3><p>1、整数部分转二进制：可以精确转换，假如数值为134.375</p>
<p>2、小数部分转二进制：可能无法精确转换，当小数最后一位是5时，一定能准确转换，转换后为10000110.011</p>
<p>3、写成规范化形式：1.0000110011x2^7</p>
<p>4、隐藏首位1：变成0000110011，这是尾数部分</p>
<p>5、计算符号位：正数0，负数1</p>
<p>6、计算指数位：双精度浮点数偏移=2^(指数位11-1)-1=1023，指数7+偏移1023=1030=10000000110(二进制)</p>
<p>7、最终内存中的样子：得到符号(S=1位)+指数(E=11位)+尾数(M=52位)的64比特二进制=0,10000000110,0000110011000000000000000000000000000000000000000000</p>
<h3 id="浮点数（双精度）转换十进制数步骤"><a href="#浮点数（双精度）转换十进制数步骤" class="headerlink" title="浮点数（双精度）转换十进制数步骤"></a>浮点数（双精度）转换十进制数步骤</h3><p>1、提取尾数位：补全首位的到，1.0000110011000000000000000000000000000000000000000000</p>
<p>2、指数移位操作：指数位10000000110=1030，1030-偏移1023=7，对尾数右移位7（负指数向左移位）=10000110.011000000000000000000000000000000000000000000</p>
<p>3、转换二进制整数+小数部分：<code>1x2^7+0x2^6...0x2^0.0x(2^-1)+1x(2^-2)+1x(2^-3)...=134.375</code></p>
<h2 id="Python的struct-pack-与struct-unpack"><a href="#Python的struct-pack-与struct-unpack" class="headerlink" title="Python的struct.pack()与struct.unpack()"></a>Python的struct.pack()与struct.unpack()</h2><p>python的struct主要用来处理C结构数据。主要有如下两个方法 [2]：</p>
<p>struct.pack(fmt, v1, v2, …)<br>struct.unpack(fmt, string)</p>
<p>下面用struct来验证python的浮点数是不是C的double：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/py-float-2.png" alt=""></p>
<p>可以看到，上面截图的两段代码显示的134.375浮点数的S、E、M是完全一样的。</p>
<h2 id="浮点数的IEEE754标准"><a href="#浮点数的IEEE754标准" class="headerlink" title="浮点数的IEEE754标准"></a>浮点数的IEEE754标准</h2><h3 id="有效位计算方法1"><a href="#有效位计算方法1" class="headerlink" title="有效位计算方法1"></a>有效位计算方法1</h3><p>一个十进制位需要多少二进制位来表示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/py-float-3.png" alt=""></p>
<p>大约需要3.322个二进制位来表示一个十进制位，所以：</p>
<p>单精度浮点数24（23尾数位+1隐藏位）位二进制可以表示大约：24/3.322≈7.225 位的十进制。</p>
<p>可见单精度浮点数的准确有效位是7（有效位表示非零整数部分+小数部分的数字位数，如1.23有效位是3，0.1234有效位是4）。</p>
<p>双精度浮点数的有效位同理计算可得：53/3.322≈15.95，有效位是15，总的来说：</p>
<p>1、单精度浮点数是4字节32位，符号位+指数位+尾数位=1位+8位+23位，有效位7～8位</p>
<p>2、双精度浮点数是8字节64位，符号位+指数位+尾数位=1位+11位+52位，有效位15～16位 [3]</p>
<h3 id="有效位计算方法2"><a href="#有效位计算方法2" class="headerlink" title="有效位计算方法2"></a>有效位计算方法2</h3><p>1、单精度浮点数有效数24位全是1时：<code>10^7 &lt; 2^24-1=16777215 &lt; 10^8</code></p>
<p>所以单精度浮点数能准确表示小数点后第7位，第8位部分准确。16777215是能够转化为单精度浮点数表示的整数的最大精度，超过这个数会进行“舍入”导致丢失精度。</p>
<p>2、双精度浮点数有效数53位全是1时：<code>10^15 &lt; 2^53-1=9007199254740991 &lt; 10^16</code></p>
<p>所以双精度浮点数能准确表示小数点后第15位，第16位部分准确。9007199254740991是能够转化为双精度浮点数表示的整数的最大精度，超过这个数会进行“舍入”导丢失精度。[4]</p>
<h2 id="Python的sys-float-info详解"><a href="#Python的sys-float-info详解" class="headerlink" title="Python的sys.float_info详解"></a>Python的sys.float_info详解</h2><p>sys.float_info输出内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">202</span>]: sys.float_info</span><br><span class="line">Out[<span class="number">202</span>]: sys.float_info(max=<span class="number">1.7976931348623157e+308</span>, max_exp=<span class="number">1024</span>, max_10_exp=<span class="number">308</span>, min=<span class="number">2.2250738585072014e-308</span>, min_exp=<span class="number">-1021</span>, min_10_exp=<span class="number">-307</span>, dig=<span class="number">15</span>, mant_dig=<span class="number">53</span>, epsilon=<span class="number">2.220446049250313e-16</span>, radix=<span class="number">2</span>, rounds=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>1、max表示的就是最大规约数（即远离0的很大的数，加个负号成为最小规约数）；</p>
<p>2、radix表示的是在电脑中储存的基数，二进制显然是2；</p>
<p>3、max_exp表示的是使得radix**(e-1)为可表示的有限浮点数最大指数，由于移码后的规约数的指数范围为-1022~1023，即最大为1023，所以最大的e自然就是1024；</p>
<p>4、max_10_exp表示的是让10**e为一个可表示的浮点数最大的指数，从结果1.7976931348623157e+308，得出max_10_exp自然就是308；</p>
<p>5、min表示最小的正规约数（即靠近0的很小的数，加个负号为靠近0的负的很大的数）；</p>
<p>6、min_exp表示的是使得radix**(e-1)为可表示的有限浮点数最小指数，移码后的最小指数为-1022（尽管指数为0时，设定偏移量为1022，移码后的指数依然为-1022），因此最小的e为-1021；</p>
<p>7、min_10_exp表示的是让10**e为一个可表示的规约浮点数最小的指数，从结果2.2250738585072014e-308，得出这时最小的e为-307（要注意不是-308，因为10**(-308)比最小正规约数2.2250738585072014e-308还小，这是不符合要求的，所以应该是-307）；</p>
<p>8、dig表示可以保证被精确的转为浮点数的整数的数字个数，保证被精确的转为浮点数的整数应该小于等于9007199254740991，该数有16位数字，但是大于该数的16位数字的整数是无法被精确的转为浮点数的，所以能确保精确的有效位是15；</p>
<p>9、mant_dig就是mantissa digits，即尾数位数，因为尾数的首位1被隐藏，所以真正的尾数位数共有52+1=53位；</p>
<p>10、epsilon表示最小的大于1的浮点数和1之间的差值；</p>
<p>11、rounds表示的是当一个整数转成浮点数，对无法精确表示的整数的近似模式，这里为1表示的是取距离原值最近的浮点数表示；[5]</p>
<h2 id="Python浮点数举例"><a href="#Python浮点数举例" class="headerlink" title="Python浮点数举例"></a>Python浮点数举例</h2><p>首先，双精度浮点数的全部53有效位可表示的最大十进制数是（53位全是1的情况）：</p>
<p>2**53-1=<strong>9007199254740991</strong></p>
<p>看一个更长的小数：</p>
<p>In [220]: 0.123456789123456789</p>
<p>Out[220]: 0.12345678912345678</p>
<p>为什么得到的浮点数是0.12345678912345678？它的小数位有17个，难道有效位变成了17？</p>
<p>其实有效位是16，因为0.12345678912345678中的<strong>1234567891234567</strong>才是精确的，最后的8是舍入后的值。那为什么是16个有效位？</p>
<p>因为上文说了双精度浮点数有效位15位是精确的，第16位部分精确，而<strong>1234567891234567&lt;9007199254740991</strong>，1234567891234567这个值并没有完全填满53位尾数，当然是可以的。</p>
<p>舍入的那个值举例：</p>
<p>In [264]: 0.123456789123456749</p>
<p>Out[264]: 0.1234567891234567<strong>4</strong></p>
<p>In [265]: 0.123456789123456759</p>
<p>Out[265]: 0.1234567891234567<strong>6</strong></p>
<p>可以明显看到最后一位4或6是舍入值，因为它变大还是变小是不精确的，这取决于浮点数的舍入规则。[6]</p>
<p>参考：<br>[1] <a href="https://blog.csdn.net/S_o_l_o_n/article/details/106483412" target="_blank" rel="noopener">整数转浮点数精度溢出的原因和处理方式</a><br>[2] <a href="https://blog.csdn.net/D_R_L_T/article/details/91910774" target="_blank" rel="noopener">Python中struct.pack()和struct.unpack()用法详细说明</a><br>[3] <a href="https://blog.csdn.net/bluewanderer/article/details/86671653" target="_blank" rel="noopener">浮点数的有效数字位数</a>、<a href="https://blog.csdn.net/startwithdp/article/details/8721466" target="_blank" rel="noopener">浮点数(单精度、双精度数)的有效位</a>、<a href="https://blog.csdn.net/dreamer2020/article/details/24158303" target="_blank" rel="noopener">深入理解浮点数有效位</a><br>[4] <a href="https://blog.csdn.net/S_o_l_o_n/article/details/106438708" target="_blank" rel="noopener">理解浮点数的二进制表示</a>、<a href="https://blog.csdn.net/S_o_l_o_n/article/details/106483412" target="_blank" rel="noopener">整数转浮点数精度溢出的原因和处理方式</a>、<a href="http://c.biancheng.net/view/314.html" target="_blank" rel="noopener">浮点数标准详解参考</a><br>[5] <a href="https://blog.csdn.net/S_o_l_o_n/article/details/106459473" target="_blank" rel="noopener">浮点数的各种最值推算以及对python sys.float_info的解释</a>、<a href="https://blog.csdn.net/S_o_l_o_n/article/details/106483412" target="_blank" rel="noopener">整数转浮点数精度溢出的原因和处理方式</a>、<a href="https://docs.python.org/3.8/library/sys.html#sys.float_info" target="_blank" rel="noopener">python文档</a><br>[6] <a href="https://blog.csdn.net/S_o_l_o_n/article/details/106483412" target="_blank" rel="noopener">整数转浮点数精度溢出的原因和处理方式</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>浮点数</tag>
      </tags>
  </entry>
  <entry>
    <title>一文彻底搞懂 Python中的描述器、反射</title>
    <url>/2021/08/19/python-descriptor.html</url>
    <content><![CDATA[<h2 id="描述器"><a href="#描述器" class="headerlink" title="描述器"></a>描述器</h2><h3 id="什么是描述器？"><a href="#什么是描述器？" class="headerlink" title="什么是描述器？"></a>什么是描述器？</h3><p>一个类中定义了如下一个或多个魔术方法，这个<strong>类的实例</strong>就是描述器：</p>
<p><code>__get__，__set__，__delete__</code></p>
<p>通常需要两个类来构建描述器：</p>
<p>如果类B的类属性x，指向另一个类A的实例。被指向的A的实例就是描述器对象。B.x是描述器，B也是描述器的属主（owner）。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    x = A()  <span class="comment"># x是描述器</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>类属性的值，通常是一些已有类型的对象，比如字符串、列表等。</p>
<p>当使用了描述器，类属性就指向一个描述器对象，描述器通过三个魔术方法，可以自定义属性的行为。</p>
<a id="more"></a>

<h3 id="描述器的分类"><a href="#描述器的分类" class="headerlink" title="描述器的分类"></a>描述器的分类</h3><p>非数据描述器：</p>
<p>只定义了<code>__get__</code>，就是非数据描述器（non-data descriptor）。</p>
<p>数据描述器：</p>
<p>定义了<code>__get__</code>，且定义了<code>__set__</code>或<code>__set__ 与 __delete__</code>，就是数据描述器（data descriptor）。</p>
<h3 id="属性搜索顺序"><a href="#属性搜索顺序" class="headerlink" title="属性搜索顺序"></a>属性搜索顺序</h3><p>当一个实例与它所属的类有相同的属性名时：</p>
<p><strong>非数据描述器，实例的属性搜索顺序：</strong></p>
<p><code>__getattribute__</code> ⟶ 默认搜索顺序 [1] ⟶ <code>__getattr__</code>。也就是说，此时__get__无效。</p>
<p><strong>数据描述器，会拦截实例属性字典的访问：</strong></p>
<p>不会访问实例属性字典<code>__dict__</code>。属性访问或修改会被描述器的<code>__get__</code>, <code>__set__</code>, <code>__delete__</code>方法处理。</p>
<p><strong>注意：</strong></p>
<p>如果有 __getattribute__ 方法，不管有没有描述器，实例属性搜索时，都优先调用此方法，可以拦截一切（包括 实例.__dict__ 的访问也拦截）。</p>
<p>__getattribute__ 和 __getattr__ 又是做什么的？下文讲。</p>
<p><strong>[1] 默认搜索顺序：</strong><br>默认搜索顺序就是没有描述器时的搜索顺序，遵循如下规则：<br>实例的属性字典(__dict__) ⟶ 类的属性字典 ⟶ 类的父类的属性字典 ⟶ … ⟶ 祖先类object的属性字典</p>
<p>属性搜索顺序与类的继承有关。如果是单继承，属性（或方法）搜索路径是确定的，一直向上找。如果是多继承，就涉及到MRO（方法解析顺序）。Python3的MRO采用C3算法，在类被创建出来的时候，就计算出一个MRO有序列表。关于C3算法，见<a href="https://www.python.org/download/releases/2.3/mro/" target="_blank" rel="noopener">官方文档</a>。</p>
<h3 id="属性读写操作示例"><a href="#属性读写操作示例" class="headerlink" title="属性读写操作示例"></a>属性读写操作示例</h3><p>B.x = 400，类属性赋值（赋值即重新定义），如果x是描述器，将被覆盖。<br>b.x = 500，非数据描述器时，将修改实例自己的属性（__dict__）。<br>b.x = 600，数据描述器时，将调用描述器的<code>__set__</code>方法。</p>
<p>B.x，若x是描述器，调用描述器的<code>__get__</code>方法。<br>b.x，若x是描述器，调用描述器的<code>__get__</code>方法。</p>
<p>直接操作实例的<code>__dict__</code>字典，可以绕开描述器对<code>__get__</code>，<code>__set__</code>等的调用。</p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A().init'</span>)</span><br><span class="line">        self.x = <span class="number">101</span>       <span class="comment"># 这是A自己的实例，与B无关</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'~~~~ A.get ~~~~'</span>)</span><br><span class="line">        print(self)         <span class="comment"># A的实例本身</span></span><br><span class="line">        print(instance)     <span class="comment"># B.x访问时，为None。b.x访问时，为B的实例对象</span></span><br><span class="line">        print(owner)        <span class="comment"># 类B</span></span><br><span class="line">        print(<span class="string">'~~~~ A.get ~~~~'</span>)</span><br><span class="line">        <span class="keyword">return</span> getattr(instance, <span class="string">'z'</span>, <span class="string">'no_z_found'</span>)  <span class="comment"># 查找b.z时，又会回去调用B.__getattribute__</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'~~~~~ A.set ~~~~'</span>)</span><br><span class="line">        print(self)         <span class="comment"># A的实例本身</span></span><br><span class="line">        print(instance)     <span class="comment"># 修改b.x时，才进入此方法，instance为B的实例对象</span></span><br><span class="line">        print(value)        <span class="comment"># 赋给 b.x 的值</span></span><br><span class="line">        print(<span class="string">'~~~~~ A.set ~~~~'</span>)</span><br><span class="line">        instance.z = value  <span class="comment"># 演示，把b.x的值保存到b.z，而不是b的属性字典__dict__</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'~~~~~ in delete'</span>)</span><br><span class="line">        <span class="keyword">del</span> instance.z</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="comment"># 创建描述器x</span></span><br><span class="line">    x = A()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义如下方法，实例属性访问最先调用它，但在类A中定义无用</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'___ in getattribute ___'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 查找b.x时，此处又会调用A.__get__（因为x是描述器），而不是调B.__getattribute__，不然会递归</span></span><br><span class="line">        <span class="keyword">return</span> object.__getattribute__(self, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B().init'</span>)</span><br><span class="line">        self.x = <span class="number">1000</span>       <span class="comment"># 非数据描述器时，实例修改自己的属性，self.x会访问实例自己的__dict__</span></span><br><span class="line">                            <span class="comment"># 数据描述器时，调用 A.__set__</span></span><br><span class="line"></span><br><span class="line">b = B()          <span class="comment"># 先生成A的实例，即执行A.__init__，生成描述器对象，然后执行B.__init__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性访问</span></span><br><span class="line">print(<span class="string">'\n'</span> + <span class="string">'-'</span> * <span class="number">30</span>)</span><br><span class="line">print(B.x)</span><br><span class="line">print()</span><br><span class="line">print(b.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 属性修改</span></span><br><span class="line"><span class="comment"># 覆盖描述器</span></span><br><span class="line"><span class="comment">#B.x = 123</span></span><br><span class="line"><span class="comment">#print(B.x)</span></span><br><span class="line">print(<span class="string">'\n'</span> + <span class="string">'#'</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非数据描述器时，b修改自己的属性，赋值即重新定义，覆盖描述器x</span></span><br><span class="line"><span class="comment"># 数据描述器时，b.x 调用 A.__set__</span></span><br><span class="line">b.x = <span class="number">456</span></span><br><span class="line">print(b.x)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">print(b.__dict__)  <span class="comment"># 甚至访问b的属性字典，也是调用B.__getattribute__</span></span><br><span class="line"><span class="keyword">del</span> b.x            <span class="comment"># 删除属性，会调用 A.__delete__</span></span><br><span class="line">print(b.x)</span><br><span class="line">print(b.__dict__)</span><br></pre></td></tr></table></figure>

<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>上文提到的__getattribute__跟__get__有什么关系呢？实际上前者是<strong>反射</strong>相关的魔术方法。那什么是反射呢？</p>
<p>当我们需要用到对象的某个属性（或方法），但是由于某种原因无法确定这个属性是否存在，这时我们需要用一种特殊的机制，去访问和操作这个未知的属性，这种机制就称为<strong>反射（reflection）</strong>。反射就相当于一种自我检查机制。</p>
<p>反射机制不仅包括，要能在运行时对程序自身信息进行检测，还要求程序能进一步根据这些信息，改变程序状态或结构。总之一句话，反射指的是运行时获取类型定义信息，并且还能修改这些信息。</p>
<p>与反射相关的四个函数：<code>getattr、setattr、delattr、hasattr</code>。与这些函数相关的四个魔术方法：<code>__getattr__, __setattr__, __delattr__, __getattribute__</code>。见下面表格：</p>
<table>
<thead>
<tr>
<th align="left">魔术方法</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>__getattr__</code></td>
<td align="left">此方法只影响实例。实例属性<strong>默认搜索顺序</strong>：实例自己(的__dict__，后同)、实例的类、类的父类、父类的父类、object祖先类。若从这个顺序中没有找到属性，会抛出<code>AttributeError</code>异常，但类中定义了<code>__getattr__</code>，实例将<strong>捕获异常</strong>，并调用此方法。此方法可用于实例没有找到属性时，拦截异常，做一些操作。</td>
</tr>
<tr>
<td align="left"><code>__setattr__</code></td>
<td align="left">此方法只影响实例。self.x = x, setattr(self, ‘x’, x) 等涉及到修改实例属性的操作时，如果定义了<code>__setattr__</code>，就会调用此方法。此方法可以拦截实例属性修改操作的默认行为。比如将实例的属性存储在新的字典中，而不是存储在默认字典__dict__。</td>
</tr>
<tr>
<td align="left"><code>__delattr__</code></td>
<td align="left">此方法只影响实例。del self.x, delattr(self, ‘x’) 等涉及删除实例属性的操作时，如果定义了<code>__delattr__</code>，将会调用此方法。</td>
</tr>
<tr>
<td align="left"><code>__getattribute__</code></td>
<td align="left">此方法只影响实例。实例的<strong>所有属性</strong>的访问，第一个就调用此方法。此方法能完全控制属性的默认访问顺序。可以在此方法中做一些处理，然后手动抛出<code>AttributeError</code>异常，这将继续调用<code>__getattr__</code>方法(如果有的话)。</td>
</tr>
</tbody></table>
<p><code>__getattr__ VS __getattribute__</code></p>
<p>两者的执行时间点不同。</p>
<p>前者会在默认属性搜索顺序中未找到属性时，拦截异常，并执行。</p>
<p>后者会在第一时间执行，完全拦截默认属性搜索顺序。两者执行顺序如下：</p>
<p><code>__getattribute__</code> ⟶ <code>实例属性的默认搜索顺序</code> ⟶ <code>__getattr__</code></p>
<p>举例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用kv赋值方式增加属性 不会调用__setattr__</span></span><br><span class="line">        self.__dict__[<span class="string">'a'</span>] = <span class="number">7</span></span><br><span class="line">        self.__dict__[<span class="string">'_d'</span>] = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如下属性将会存储到新字典_d 会调用__setattr__</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'_in getattr:'</span>, item)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 属性未找到时 才调用__getattr__ 并从新字典返回属性</span></span><br><span class="line">        <span class="keyword">return</span> self._d[item]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        print(<span class="string">'_in setattr:'</span>, key, value)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 下面写法都会递归 它们都调用__setattr__</span></span><br><span class="line">        <span class="comment"># self.key = value</span></span><br><span class="line">        <span class="comment"># setattr(self, str(key), value)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 用新字典存储属性</span></span><br><span class="line">        <span class="comment"># _d 属性在实例的__dict__，因为是字典操作，所以等号左边的self._d就不会调用__getattr__</span></span><br><span class="line">        self._d[key] = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">'_in delattr:'</span>, item)</span><br><span class="line">        <span class="keyword">del</span> self._d[item]</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(a.__dict__)  <span class="comment"># 打印属性字典，不会调用A.__getattr__，除非定义了_getattribute__</span></span><br><span class="line">print(a.x)</span><br><span class="line"><span class="keyword">del</span> a.x</span><br><span class="line">delattr(a, <span class="string">'y'</span>)</span><br><span class="line">a.t = <span class="number">123</span>          <span class="comment"># 这也会调__setattr__</span></span><br><span class="line">print(a.__dict__)</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    d = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(item, <span class="string">'~~~~~~~'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 推荐写法</span></span><br><span class="line">        <span class="keyword">return</span> object.__getattribute__(self, item)</span><br><span class="line"></span><br><span class="line">a = A(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">print(<span class="string">'#'</span> * <span class="number">30</span>)</span><br><span class="line">print(a.x, a.d)</span><br></pre></td></tr></table></figure>

<p>如果上面提及的魔术方法同时存在，会怎么样呢？详见 <a href="https://izhaojie.com/2021/08/21/python-attribute-search-order.html">Python中的属性搜索顺序</a></p>
<h2 id="描述器的应用"><a href="#描述器的应用" class="headerlink" title="描述器的应用"></a>描述器的应用</h2><p>用描述器实现ClassMethod、StaticMethod（非数据描述器的应用）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 非数据描述器 实现StaticMethod</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticMethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'_in StaticMethod'</span>)</span><br><span class="line">        print(self, instance, owner)</span><br><span class="line">        <span class="keyword">return</span> self.fn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非数据描述器 实现ClassMethod</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassMethod</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'_in ClassMethod'</span>)</span><br><span class="line">        print(self, instance, owner)</span><br><span class="line">        <span class="keyword">return</span> partial(self.fn, owner)  <span class="comment"># 固定fn的owner参数，就是固定bar函数的所属类A2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span><span class="params">(object)</span>:</span></span><br><span class="line">    AGE = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.__age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 装饰器语法</span></span><br><span class="line"><span class="meta">    @StaticMethod  # foo=StaticMethod(foo) 构建非数据描述器对象foo</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(x)</span>:</span></span><br><span class="line">        print(<span class="string">'_in foo'</span>)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 装饰器语法</span></span><br><span class="line"><span class="meta">    @ClassMethod  # bar=ClassMethod(bar) 构建非数据描述器对象bar</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(cls, x)</span>:</span></span><br><span class="line">        print(<span class="string">'_in bar'</span>)</span><br><span class="line">        <span class="keyword">return</span> cls.AGE, x</span><br><span class="line"></span><br><span class="line">a = A2(<span class="string">'Tom'</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里分两步，a.foo读取属性foo，会调用__get__返回A2里定义的foo函数，这个函数其实是描述器的属性fn，</span></span><br><span class="line"><span class="comment"># 然后调函数fn(3)，以此来实现静态方法foo</span></span><br><span class="line">print(a.foo(<span class="number">3</span>))</span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里分两步，a.bar读取属性bar，会调用__get__返回A2里定义的bar函数，这个函数其实是描述器的属性fn，</span></span><br><span class="line"><span class="comment"># 然后调函数fn(4)，cls参数已固定，实现了类方法</span></span><br><span class="line">print(a.bar(<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>用描述器实现Property（数据描述器的应用）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Property</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fget, fset=None, fdel=None)</span>:</span></span><br><span class="line">        self.fget = fget  <span class="comment"># fget是A的方法age</span></span><br><span class="line">        self.fset = fset</span><br><span class="line">        self.fdel = fdel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="comment"># fget是self实例的属性，不是Property的方法，所以不会把self自动传递给fget，所以需要instance参数</span></span><br><span class="line">        <span class="keyword">return</span> self.fget(instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        self.fset(instance, value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        self.fdel(instance)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setter</span><span class="params">(self, fset)</span>:</span></span><br><span class="line">        self.fset = fset</span><br><span class="line">        <span class="keyword">return</span> self  <span class="comment"># 必须返回Property实例才能构建描述器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deleter</span><span class="params">(self, fdel)</span>:</span></span><br><span class="line">        self.fdel = fdel</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__age = <span class="number">13</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># age=Property(age)=描述器对象</span></span><br><span class="line">    <span class="comment"># @Property必需在@age.setter与@age.deleter的前面</span></span><br><span class="line">    <span class="comment"># 因为@Property创建了描述器对象add，下面才能使用add对象</span></span><br><span class="line"><span class="meta">    @Property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># age=age.setter(age)=描述器对象</span></span><br><span class="line">    <span class="comment"># 因为age是描述器对象，指向Property的实例，该实例有属性setter</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__age = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__age</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">print(a.age)  <span class="comment"># 把方法调用变成了属性访问</span></span><br><span class="line">a.age = <span class="number">17</span>    <span class="comment"># 调__set__</span></span><br><span class="line">print(a.age)</span><br><span class="line"><span class="keyword">del</span> a.age     <span class="comment"># 调__delete__</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>描述器</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>一文彻底搞懂 Python中的装饰器、偏函数</title>
    <url>/2021/08/19/python-decorator-and-partial.html</url>
    <content><![CDATA[<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>要讲清楚装饰器，首先要知道一些前置概念。下文涉及到这些概念的地方，会展开讲述。</p>
<h3 id="什么是装饰器？"><a href="#什么是装饰器？" class="headerlink" title="什么是装饰器？"></a>什么是装饰器？</h3><p>装饰器是一种AOP（面向切面编程）的设计模式。</p>
<p>面向对象编程往往需要通过继承或组合依赖等方式调用一些功能，这样可能造成代码的重复，增加了耦合。</p>
<p>而AOP可以在需要的类或方法上切入，切入点可以增强功能，让调用者与被调用者解耦。</p>
<p><strong>这种不修改原来的业务代码，给程序动态添加（或修改）功能的技术，就是装饰器</strong>。</p>
<p>装饰器可用于日志记录、监控、参数检查等地方。比如业务函数中不应该包含与业务无关的功能，那么可以构建一个logger装饰器，对业务函数增加日志功能。并且logger装饰器可以是通用的，需要日志功能的地方，都可以使用logger装饰器，达到复用的目的。</p>
<h3 id="装饰器的分类"><a href="#装饰器的分类" class="headerlink" title="装饰器的分类"></a>装饰器的分类</h3><p>无参数装饰器：无参数装饰器实现的关键是“闭包”，即嵌套函数与自由变量。</p>
<p>带参数装饰器：带参数装饰器实现的关键是“柯里化”，多层嵌套函数可以实现柯里化。</p>
<h3 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h3><p>在讲什么是闭包前，需要先讲一个概念：自由变量。什么是自由变量呢？</p>
<p>未在本地作用域中定义，就是出现在嵌套函数中，定义在某函数的外层函数的作用域中的变量，叫<strong>自由变量</strong>。</p>
<p>如果某函数（即内层函数）引用了外层函数的自由变量，这样就形成了<strong>闭包</strong>。</p>
<a id="more"></a>

<p>比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    x = <span class="number">100</span>        <span class="comment"># 这个x就是自由变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        print(x)   <span class="comment"># 嵌套函数bar就能使用自由变量x（注意是直接使用x而不是通过参数传递给bar函数），这就叫闭包</span></span><br><span class="line">    bar()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure>

<p>再比如，用列表实现一个计数器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>]            <span class="comment"># 自由变量c</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 这行不会报错，因为这里不是在赋值变量c本身，</span></span><br><span class="line">        <span class="comment"># 而是修改c变量里（即列表里）的内容，c保存的列表引用是不变的</span></span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> inc</span><br><span class="line">foo = counter()</span><br><span class="line">print(foo(), foo())    <span class="comment"># 输出 1 2</span></span><br><span class="line">c = <span class="number">100</span>                <span class="comment"># 这是全局变量c，与函数内的局部变量c无关</span></span><br><span class="line">print(foo())           <span class="comment"># 输出 3</span></span><br></pre></td></tr></table></figure>

<p>上面代码的第6行，涉及到Python的“未赋值先引用”问题。因为Python是动态语言，对一个变量赋值就是在定义这个变量，就是“<strong>赋值即定义</strong>”。由于这个特性，会造成下面的问题：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 或者 x += 1</span></span><br><span class="line">    x = x + <span class="number">1</span>    <span class="comment"># 这里的x是本地变量，这里会抛出未赋值先引用异常</span></span><br><span class="line">    print(x)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>上面的 <strong>x=x+1</strong> 语句为什么会异常呢？如果是静态编译语言，像C语言，这个语句就是对全局变量x加1，没有问题。但是，因为<strong>赋值即定义</strong>，x=x+1 这个表达式先计算等号右边部分：x+1，此时的x的确是全局变量，即x=5的那个x。</p>
<p>接着计算等号左边部分，就涉及到赋值操作，等号左边的x赋值即定义，那就是在定义局部变量x。这时，会出现冲突：<br><strong>x=x+1 这个等式里的x到底是全局变量还是函数的本地（局部）变量？</strong></p>
<p>显然，因为抛出了未赋值先引用的异常，这个等式里的x最后变成了<strong>本地变量</strong>（要不然，赋值即定义这种特性就不复存在了）。解决这个问题的办法之一就是把func内的x声明为全局变量：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> x  <span class="comment"># 把x声明为全局变量</span></span><br><span class="line">    x = x + <span class="number">1</span> <span class="comment"># x的结果=6</span></span><br><span class="line">    print(x)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure>

<p>好了。到这里，闭包的概念有了。接下来要讲什么是柯里化。</p>
<h3 id="什么是柯里化？"><a href="#什么是柯里化？" class="headerlink" title="什么是柯里化？"></a>什么是柯里化？</h3><p>简单来说，柯里化就是把一个函数的多参数形式转换成函数的<strong>单参数连续调用</strong>形式。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span>  <span class="comment"># 多参数形式</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">func(a)(b)(c)       <span class="comment"># 要变成这样的单参数连续调用的形式</span></span><br></pre></td></tr></table></figure>

<p>那怎么变呢？用<strong>嵌套函数</strong>实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a+b+c</span><br><span class="line"></span><br><span class="line">print(func(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  <span class="comment"># 返回结果是6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套函数func。如果_infunc1函数是业务函数，func函数是装饰函数，装饰器的雏形是不是已经出来了？</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_infunc1</span><span class="params">(b)</span>:</span>       <span class="comment"># 内层函数1</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_infunc2</span><span class="params">(c)</span>:</span>   <span class="comment"># 内层函数2</span></span><br><span class="line">            <span class="keyword">return</span> a+b+c</span><br><span class="line">        <span class="keyword">return</span> _infunc2</span><br><span class="line">    <span class="keyword">return</span> _infunc1</span><br><span class="line"></span><br><span class="line">print(func(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)) <span class="comment"># 返回也是6，这个就是单参数连续调用</span></span><br></pre></td></tr></table></figure>

<p>好了。柯里化的概念也有了，而且从上面代码可见，装饰器的雏形已经出来了。</p>
<p><strong>问题：</strong></p>
<p>聪明的你，可能会提出一个问题。因为Python里面一切皆对象，对象是有生命周期的。Python给对象设定<strong>引用计数</strong>来决定某个对象是否要销毁。如果对象的引用计数=0，这个对象会在恰当的时机被Python的GC（垃圾回收）回收，然后释放出占用的内存。</p>
<p>于是这个问题就是：自由变量为什么不会被销毁呢？</p>
<p>因为自由变量它也是局部变量，而函数内的局部变量是在函数调用时才创建（压入函数栈）。调用完成，局部变量就不需要了，也就没有了。像下面这个例子里的自由变量c，函数counter执行完，c怎么没有被销毁呢，c不也是函数内的局部变量吗？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">    c = [<span class="number">0</span>]    <span class="comment"># c是自由变量，也是局部变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inc</span><span class="params">()</span>:</span></span><br><span class="line">        c[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> c[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> inc</span><br><span class="line"></span><br><span class="line">foo = counter()</span><br><span class="line">foo()</span><br><span class="line">foo()         <span class="comment"># 连续执行foo，返回值从1，2，3...不断累加，表明c变量没有消失</span></span><br></pre></td></tr></table></figure>

<p>因为，当foo=counter()执行完之后，counter返回它的内部函数inc，即foo=inc，内部函数被变量foo记住了，所以inc的引用计数不可能是0。并且，c是被inc函数引用的，inc没有消失，c怎么能消失呢。c的引用计数也必然不会等于0，所以执行foo()可以不断累加。具体可以看Python的源代码，这里只是反推，不解析源码。</p>
<p>讲了这么多，下面终于可以讲装饰器了。装饰器可以分为这么几种：</p>
<p>函数作为装饰器、类作为装饰器、类的实例作为装饰器（即描述器）。</p>
<h2 id="函数作为装饰器"><a href="#函数作为装饰器" class="headerlink" title="函数作为装饰器"></a>函数作为装饰器</h2><h3 id="无参数装饰器"><a href="#无参数装饰器" class="headerlink" title="无参数装饰器"></a>无参数装饰器</h3><p>先给出用法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>其中 @logger 为装饰器的语法糖，等价于 add=logger(add)。那么logger长什么样呢？如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(fn)</span>:</span>     <span class="comment"># 这个就是装饰器，用函数构建的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">'调用原函数前增强的代码'</span>)</span><br><span class="line">        ret = fn(*args, **kwargs)</span><br><span class="line">        print(<span class="string">'调用原函数后增强的代码'</span>)</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="keyword">return</span> wrapper  <span class="comment"># 返回一个新函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器语法，等价于 add = logger(add)，add变量保存的就是wrapper函数，</span></span><br><span class="line"><span class="comment"># add(4,5) 相当于调用 logger(add)(4,5)，还记得吗？这种单参数连续调用就是柯里化。</span></span><br><span class="line"><span class="comment"># 而且@logger是无参数装饰器，有参数装饰器形如@logger(a,b)，下文讲</span></span><br><span class="line"><span class="meta">@logger</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">4</span>,<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<p>以上就是用函数logger作为装饰器，去修饰一个加法函数add，而且logger是无参数装饰器。可以看到，一个无参数装饰器是一个<strong>两层嵌套函数</strong>。</p>
<p>装饰器还可以多次使用，规则是：<strong>自底向上执行</strong>，即靠近被装饰函数的装饰器先执行，远离的后执行。比如：</p>
<p>@logger1<br>@logger2<br>@logger3<br>def add(x,y):<br>    pass</p>
<p>等价形式为：logger1(logger2(logger3(add))) 等价于调用：令f=logger1(logger2(logger3(add))), f(4,5)</p>
<p>就是说，add这个函数被3个装饰器分别修改了3次，形成一个新函数。</p>
<h3 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h3><p>要实现带参数装饰器，只需要再加一层嵌套函数，形成<strong>三层嵌套函数</strong>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_logger</span><span class="params">(fn)</span>:</span>       <span class="comment"># 再套一层函数，外层函数logger就可以带参数了</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span>  <span class="comment"># kwargs这里没用到，不用管</span></span><br><span class="line">            print(<span class="string">f'增强代码, a=<span class="subst">&#123;a&#125;</span>, b=<span class="subst">&#123;b&#125;</span>'</span>)</span><br><span class="line">            ret = fn(*args, **kwargs)</span><br><span class="line">            print(<span class="string">f'增强代码, a+b+add<span class="subst">&#123;args&#125;</span>=<span class="subst">&#123;a+b+ret&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> wrapper     <span class="comment"># 返回一个新函数</span></span><br><span class="line">    <span class="keyword">return</span> _logger</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带参数的装饰器，相当于：logger(1,2)=&gt;_logger, _logger(add)=&gt;wrapper, wrapper(4,5)</span></span><br><span class="line"><span class="comment"># 在add被装饰前，等价于执行：logger(1,2)(add)(4,5)</span></span><br><span class="line"><span class="meta">@logger(1, 2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">增强代码, a=<span class="number">1</span>, b=<span class="number">2</span></span><br><span class="line">增强代码, a+b+add(<span class="number">4</span>, <span class="number">5</span>)=<span class="number">12</span></span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong></p>
<p>到这里，我们又可以提出一个问题：</p>
<p>装饰器如何解决同一个作用域中变量名同名问题？比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(fn)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">w</span><span class="params">(x,y)</span>:</span></span><br><span class="line">        print(<span class="string">'_in w'</span>)</span><br><span class="line">        <span class="keyword">return</span> fn(x, y)</span><br><span class="line">    <span class="keyword">return</span> w</span><br><span class="line"></span><br><span class="line"><span class="comment"># 装饰器名是add，函数名也是add，假如两个变量都在全局作用域中，而且同名，如何解决同名变量名问题？</span></span><br><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">add(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>推测：</p>
<p>装饰器语法执行时，被装饰函数虽然名叫add，但实际定义该函数后，函数对象直接赋值给了装饰器add的参数fn，类似于 fn=lambda x,y: x+y，被装饰函数名add实际上并不存在。所以，也就不存在相同变量名（add）冲突的问题（根据上面源码debug后观察到）。</p>
<p>上面讲的是，函数作为装饰器，去装饰一个函数。函数装饰器也可以去装饰一个类。</p>
<h3 id="用函数装饰类"><a href="#用函数装饰类" class="headerlink" title="用函数装饰类"></a>用函数装饰类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_name</span><span class="params">(name=<span class="string">'tom'</span>, lang=<span class="string">'cn'</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(cls)</span>:</span></span><br><span class="line">        cls.NAME = name</span><br><span class="line">        cls.LANG = lang</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@add_name()  # 给类添加新属性NAME与LANG</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    AGE = <span class="number">13</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self)</span><br><span class="line">p = Person()</span><br><span class="line">p.NAME, p.LANG</span><br></pre></td></tr></table></figure>

<h2 id="类作为装饰器"><a href="#类作为装饰器" class="headerlink" title="类作为装饰器"></a>类作为装饰器</h2><p>同样，类也可以作为装饰器。去装饰函数或者类。</p>
<h3 id="用类装饰函数"><a href="#用类装饰函数" class="headerlink" title="用类装饰函数"></a>用类装饰函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Log</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, msg1, msg2)</span>:</span></span><br><span class="line">        self.msg1 = msg1</span><br><span class="line">        self.msg2 = msg2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, fn)</span>:</span>  <span class="comment"># 让类的实例可调用</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            print(<span class="string">f'msg1 = <span class="subst">&#123;self.msg1&#125;</span>'</span>)</span><br><span class="line">            ret = fn(*args, **kwargs)</span><br><span class="line">            print(<span class="string">f'msg2 = <span class="subst">&#123;self.msg2&#125;</span>'</span>)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@Log('start', 'end')  # 相当于：add=Log(...)(add)=callable_obj(add)=add</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<h3 id="用类装饰类"><a href="#用类装饰类" class="headerlink" title="用类装饰类"></a>用类装饰类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClsName</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, prefix)</span>:</span></span><br><span class="line">        self.prefix = prefix</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, cls)</span>:</span>  <span class="comment"># 让实例可调用</span></span><br><span class="line">        cls.name = self.prefix + <span class="string">' '</span> + cls.__name__</span><br><span class="line">        <span class="keyword">return</span> cls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@ClsName('class name is')  # A1=ClsName(...)(A1)=callable_obj(A1)=A1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = A1()</span><br><span class="line">a.name</span><br></pre></td></tr></table></figure>

<p>最后，用with可以实现类似装饰器的效果。</p>
<h3 id="with上下文管理实现装饰器的效果"><a href="#with上下文管理实现装饰器的效果" class="headerlink" title="with上下文管理实现装饰器的效果"></a>with上下文管理实现装饰器的效果</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeIt</span>:</span>                 <span class="comment"># 构建上下文，达到类似装饰器的目的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn)</span>:</span></span><br><span class="line">        self.fn = fn</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.start = time.time()</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, tp, val, tb)</span>:</span></span><br><span class="line">        print(<span class="string">f'TimeIt: <span class="subst">&#123;time.time()-self.start&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.fn(*args, **kwargs)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y, z)</span>:</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> x+y+z</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> TimeIt(add) <span class="keyword">as</span> f:</span><br><span class="line">    print(f(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>严格地讲，with这个用法不是装饰器，但它达到了装饰器具有的一些能力，比如这里的统计函数执行时间。</p>
<h2 id="类的实例作为装饰器（描述器）"><a href="#类的实例作为装饰器（描述器）" class="headerlink" title="类的实例作为装饰器（描述器）"></a>类的实例作为装饰器（描述器）</h2><p>类的实例作为装饰器，通常用作描述器。</p>
<p>什么是描述器？详见 <a href="https://izhaojie.com/2021/08/19/python-descriptor.html">一文彻底搞懂 Python中的描述器</a>。</p>
<h2 id="偏函数"><a href="#偏函数" class="headerlink" title="偏函数"></a>偏函数</h2><h3 id="什么是偏函数？"><a href="#什么是偏函数？" class="headerlink" title="什么是偏函数？"></a>什么是偏函数？</h3><p>偏函数：把一个函数的部分参数固定下来，就是为部分参数添加固定的默认值，形成一个新的函数并返回。</p>
<p>偏函数可以配合嵌套函数实现<strong>带参数</strong>装饰器。Python标准库提供了偏函数 <strong>functools.partial</strong>。partial的等价函数为：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 等价偏函数（实际functools.partial是一个类，它还会做更多工作，比如改变新函数的函数头）</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partial</span><span class="params">(func, *args, **keywords)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">newfunc</span><span class="params">(*fargs, **fkeywords)</span>:</span></span><br><span class="line">        newkeywords = keywords.copy()  <span class="comment"># 浅拷贝偏函数提供的可变关键字参数给newkeywords</span></span><br><span class="line">        newkeywords.update(fkeywords)  <span class="comment"># 合并新函数提供的可变关键字参数</span></span><br><span class="line">        <span class="keyword">return</span> func(*args, *fargs, **newkeywords)  <span class="comment"># 偏函数提供的位置参数放前面，这样就把原函数的部分参数固定下来了</span></span><br><span class="line">    newfunc.func = func  <span class="comment"># 记录下原函数给新函数</span></span><br><span class="line">    newfunc.args = args  <span class="comment"># 记录下要固定的位置参数给新函数</span></span><br><span class="line">    newfunc.keywords = keywords  <span class="comment"># 记录下要固定关键字参数给新函数</span></span><br><span class="line">    <span class="keyword">return</span> newfunc  <span class="comment"># 返回新函数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定add的参数x，partial(add,4) 返回 newfunc，调用newfunc(5)-&gt;func(*args,*fargs)-&gt;func(4,5)</span></span><br><span class="line">newadd = partial(add, <span class="number">4</span>)</span><br><span class="line">newadd(<span class="number">5</span>) <span class="comment"># 返回9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 固定add的所有参数</span></span><br><span class="line">partial(add, <span class="number">4</span>, <span class="number">5</span>)() <span class="comment"># 返回9</span></span><br></pre></td></tr></table></figure>

<h3 id="用偏函数与嵌套函数实现装饰器"><a href="#用偏函数与嵌套函数实现装饰器" class="headerlink" title="用偏函数与嵌套函数实现装饰器"></a>用偏函数与嵌套函数实现装饰器</h3><p>为了方便，这里使用标准库里的偏函数partial，实现带参数装饰器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logger</span><span class="params">(fn, a, b=<span class="number">3</span>)</span>:</span>  <span class="comment"># 两层嵌套函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a + b + fn(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">newlogger</span><span class="params">(a, b=<span class="number">3</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> partial(logger, a=a, b=b)  <span class="comment"># 固定logger的参数a、b</span></span><br><span class="line"></span><br><span class="line">fn = newlogger(<span class="number">2</span>,<span class="number">4</span>)  <span class="comment"># 测试</span></span><br><span class="line">print(inspect.signature(fn))  <span class="comment"># 偏函数返回的新函数的函数头 (fn, *, a=2, b=4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add=newlogger(4,5)(add)=(logger,a=4,b=5)(add)，生成新的logger(add)-&gt;wrapper, 使add(x,y)变成了wrapper(x,y)</span></span><br><span class="line"><span class="meta">@newlogger(4, 5)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 相当于调用 newlogger(4,5)(add)(1,2) 或 partial(logger,a=4,b=5)(add)(1,2)，返回12</span></span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>装饰器</tag>
        <tag>偏函数</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的属性搜索顺序</title>
    <url>/2021/08/21/python-attribute-search-order.html</url>
    <content><![CDATA[<p>属性：这里表示类（或类的实例）中的变量与方法的统称。</p>
<p>所以搜索顺序包括：类的属性搜索顺序、类的实例的属性搜索顺序。</p>
<p>下面是所有魔术方法同时出现的情况下，类或实例的属性搜索顺序。</p>
<h2 id="默认搜索顺序"><a href="#默认搜索顺序" class="headerlink" title="默认搜索顺序"></a>默认搜索顺序</h2><p><strong>对于类</strong>，比如查找A.x。A是类，x是类的属性。</p>
<p>类属性的默认搜索顺序：A自己的x（即A的属性字典__dict__） ⟶ A的父类的x [1] ⟶ 父类的父类的x… ⟶ object的x</p>
<p><strong>对于类的实例</strong>，比如查找a.x。a是A的实例，x是实例的属性。</p>
<p>实例的默认搜索顺序：a自己的x（即a的属性字典__dict__） ⟶ A自己的x ⟶ A的父类的x [1] ⟶  父类的父类的x… ⟶ object的x</p>
<p>[1]：</p>
<p>如果A是单继承，直接不断向上找父类。如果A是多继承，由Python3的mro生成一个有序的继承列表，依次找父类。</p>
<h2 id="相关的魔术方法"><a href="#相关的魔术方法" class="headerlink" title="相关的魔术方法"></a>相关的魔术方法</h2><p><strong>与搜索顺序相关的魔术方法有：</strong></p>
<p>1、反射相关的：<code>__getattr__, __setattr__, __delattr__, __getattribute__</code></p>
<p>2、描述器相关的：<code>__get__，__set__，__delete__</code></p>
<p>下面是所有魔术方法同时出现的情况下，类或实例的属性搜索顺序：</p>
<a id="more"></a>

<h2 id="实例属性搜索顺序"><a href="#实例属性搜索顺序" class="headerlink" title="实例属性搜索顺序"></a>实例属性搜索顺序</h2><p>还是以 a.x 为例。</p>
<h3 id="修改-删除-a-x-时"><a href="#修改-删除-a-x-时" class="headerlink" title="修改/删除 a.x 时"></a>修改/删除 a.x 时</h3><p>不管 x 这个属性是不是描述器，描述器不起作用：<br>修改a.x时，直接调 __setattr__<br>删除a.x时，直接调 __delattr__</p>
<p>因为修改/删除肯定是操作a自己的x，不会去操作继承位置的x，显然是直接调用类A的 __setattr__ 或 __delattr__。</p>
<h3 id="读取-a-x-时"><a href="#读取-a-x-时" class="headerlink" title="读取 a.x 时"></a>读取 a.x 时</h3><p><strong>如果 x 是描述器：</strong></p>
<p>1、非数据描述器时，描述器不起作用：<br>__getattribute__ ⟶ 实例默认搜索顺序 ⟶ __getattr__</p>
<p>2、数据描述器时：<br>__getattribute__ ⟶ 描述器的__get__</p>
<p><strong>如果 x 不是描述器：</strong></p>
<p>__getattribute__ ⟶ 实例默认搜索顺序 ⟶ __getattr__</p>
<h2 id="类属性搜索顺序"><a href="#类属性搜索顺序" class="headerlink" title="类属性搜索顺序"></a>类属性搜索顺序</h2><h3 id="修改-删除-A-x"><a href="#修改-删除-A-x" class="headerlink" title="修改/删除 A.x"></a>修改/删除 A.x</h3><p>与实例一样，是操作A自己的x，不存在搜索顺序。</p>
<p>修改时，比如A.x=100，赋值即重新定义。</p>
<h3 id="读取-A-x"><a href="#读取-A-x" class="headerlink" title="读取 A.x"></a>读取 A.x</h3><p>如果 x 是描述器：调描述器的 __get__</p>
<p>如果不是描述器：符合上文的 <strong>类属性的默认搜索顺序</strong></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>MRO</tag>
        <tag>属性</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的元编程</title>
    <url>/2021/08/23/python-metaprograming.html</url>
    <content><![CDATA[<h2 id="元编程"><a href="#元编程" class="headerlink" title="元编程"></a>元编程</h2><h3 id="什么是元编程？"><a href="#什么是元编程？" class="headerlink" title="什么是元编程？"></a>什么是元编程？</h3><p>用代码来生成代码，或者说，用程序来生成程序，就叫元编程。Python能通过反射实现元编程。</p>
<h3 id="什么是元类？"><a href="#什么是元类？" class="headerlink" title="什么是元类？"></a>什么是元类？</h3><p>与元编程相关的一个概念是元类。什么是元类呢，具体到Python，用来创建类的类，就叫<strong>元类</strong>。元类是制造类的工厂。</p>
<p>在Python中，一个普通类创建出来的东西是类的实例，实例是一个对象。而元类也是一种类，它创建出来的东西是<strong>另一个普通类</strong>，普通类也是一个对象（Python中一切皆对象），然后这个普通类，又可以创建出类的实例。所以说，元类是类的类。它们的构建过程如下图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/jasonz666/imgHost/blogPic/class-and-metaclass1.png" alt=""></p>
<p><strong>Python中：</strong></p>
<p>1、所有非object类都继承自object类（包括type）<br>2、所有类的类型都是type（包括type、object、元类）<br>3、type类继承自object（符合第1句）</p>
<p>虽然type也继承自object，但是我们自己写的类，继承自object与继承自type，会有些不同。</p>
<h3 id="type元类"><a href="#type元类" class="headerlink" title="type元类"></a>type元类</h3><p>type这个类，不仅可以获取Python中对象的类型，比如type(123)，会告诉你123是int类型（int也是类）。</p>
<p>type也可以作为元类，来构建其他类。语法是：</p>
<p><code>type(name, bases, dict) -&gt; a new type</code> 返回一个新的类型</p>
<a id="more"></a>

<p>其中，name为类的名称，bases为类的继承列表，dict为类的属性字典。比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.x = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用type创建了一个新的类，变量名NewClass，新类的类名是newclass</span></span><br><span class="line">NewClass = type(<span class="string">'newclass'</span>, (object,), &#123;<span class="string">'a'</span>:<span class="number">100</span>, <span class="string">'b'</span>:[], <span class="string">'__init__'</span>:__init__&#125;)</span><br><span class="line">print(NewClass.__dict__)  <span class="comment"># 类的属性里会有a, b, __init__</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 等价于如下class关键字创建的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newclass</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    b = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">456</span></span><br><span class="line">print(newclass.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不同之处在于，type创建的newclass的__init__函数在全局作用域里，</span></span><br><span class="line"><span class="comment"># class关键字创建的newclass的__init__函数在类内部，即newclass.__init__</span></span><br></pre></td></tr></table></figure>

<p>以上例子没有什么神奇。元类的真正用途，是在元类的构造方法（__new__, __init__）里写我们的代码，从而改变一个类的构建行为。</p>
<p>上面用type构建了一个新的类，类在程序中是代码，type(…)调用也是代码。所以，<strong>这种用代码来生成代码的过程，就是元编程</strong>。</p>
<h3 id="构建自己的元类"><a href="#构建自己的元类" class="headerlink" title="构建自己的元类"></a>构建自己的元类</h3><p>如果一个类继承自type（而不是object），它就会成为元类，比如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元类，ModelMeta是元类，因为继承自type</span></span><br><span class="line"><span class="comment"># 我们把ModelMeta当作元类模版</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMeta</span><span class="params">(type)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 因为继承自type，参数与type元类一样</span></span><br><span class="line">    <span class="comment"># 在__new__中可以改变构建普通类时的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, _dict)</span>:</span></span><br><span class="line">        print(cls)</span><br><span class="line">        print(name)</span><br><span class="line">        print(bases)</span><br><span class="line">        print(_dict)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 注意这里和普通类调用super不同: return super().__new__(cls)</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls, name, bases, _dict)</span><br><span class="line">        <span class="comment"># 或者</span></span><br><span class="line">        <span class="comment">#return type.__new__(cls, name, bases, _dict)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、用metaclass关键字参数创建一个元类</span></span><br><span class="line"><span class="comment"># 这里的写法表示A这个类是被元类ModelMeta构建的，而不是继承</span></span><br><span class="line"><span class="comment"># 这种写法是用元类构建一个类A，所以元类里的__new__实例化方法会执行</span></span><br><span class="line"><span class="comment"># 即元类实例化出来的东西是另一个普通类(而不是一个类的实例)</span></span><br><span class="line"><span class="comment"># A是普通类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(metaclass=ModelMeta)</span>:</span></span><br><span class="line">    x = <span class="number">999</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'A.init'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 2、继承</span></span><br><span class="line"><span class="comment"># 这里才表示正常的类的继承，</span></span><br><span class="line"><span class="comment"># 但是B的构建路线是：ModelMeta-&gt;构建A-&gt;继承到B</span></span><br><span class="line"><span class="comment"># B是普通类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'B.init'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 3、元类模版也可以使用调用语法，创建新类，就像type那样</span></span><br><span class="line"><span class="comment"># C是普通类</span></span><br><span class="line">C = ModelMeta(<span class="string">'C'</span>, (), &#123;<span class="string">'x'</span>:<span class="number">999</span>&#125;)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line"><span class="comment"># 4、继承元类</span></span><br><span class="line"><span class="comment"># D继承自元类ModelMeta，所以D也是一个元类(这里是继承而不是用元类构建D)</span></span><br><span class="line"><span class="comment"># 因为是继承，元类ModelMeta的__new__不会执行</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(ModelMeta)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="元类的应用"><a href="#元类的应用" class="headerlink" title="元类的应用"></a>元类的应用</h2><p>元编程可用于开发框架。比如ORM（对象关系映射）。将数据库的操作与类（以及实例）的操作联系起来，就可以使用元类。</p>
<p><strong>映射关系：</strong></p>
<p>表 ⟶ class<br>行 ⟶ 实例<br>字段 ⟶ 属性（描述器，见 <a href="https://izhaojie.com/2021/08/19/python-descriptor.html">这里</a>）</p>
<p>一个简单的例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 字段类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Field</span>:</span></span><br><span class="line">    <span class="comment"># 字段名fn，类型tp，是否为主键pk，是否空null</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, fn=None, tp=None, pk=False, null=True)</span>:</span></span><br><span class="line">        self.fn = fn</span><br><span class="line">        self.tp = tp</span><br><span class="line">        self.pk = pk</span><br><span class="line">        self.nl = null</span><br><span class="line">        self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.tp:</span><br><span class="line">            self.value = self.tp(value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.value</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模版元类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ModelMeta</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, name, bases, attrs)</span>:</span></span><br><span class="line">        <span class="comment">#print(cls)</span></span><br><span class="line">        <span class="comment">#print(name)</span></span><br><span class="line">        <span class="comment">#print(bases)</span></span><br><span class="line">        <span class="comment">#print(attrs)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 添加表名</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">'__tblname__'</span> <span class="keyword">not</span> <span class="keyword">in</span> attrs.keys():</span><br><span class="line">            attrs[<span class="string">'__tblname__'</span>] = name</span><br><span class="line"></span><br><span class="line">        primarykeys = []</span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> attrs.items():</span><br><span class="line">            <span class="keyword">if</span> isinstance(v, Field):</span><br><span class="line">                <span class="keyword">if</span> v.fn <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    v.fn = k  <span class="comment"># 属性名作为字段名</span></span><br><span class="line">                <span class="keyword">if</span> v.pk:</span><br><span class="line">                    primarykeys.append(v)</span><br><span class="line">                    v.nl = <span class="literal">False</span>  <span class="comment"># 有主键自动不为空</span></span><br><span class="line"></span><br><span class="line">        attrs[<span class="string">'__primarykeys__'</span>] = primarykeys</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(metaclass=ModelMeta)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> k,v <span class="keyword">in</span> kwargs.items():</span><br><span class="line">            <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> self.__class__.__dict__:</span><br><span class="line">                <span class="keyword">raise</span> AttributeError(<span class="string">f"'<span class="subst">&#123;k&#125;</span>' is not a field name"</span>)</span><br><span class="line">            setattr(self, k, v)  <span class="comment"># 将调用描述器的__set__</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设计学生表</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Base)</span>:</span></span><br><span class="line">    sid = Field(tp=int, pk=<span class="literal">True</span>)  <span class="comment"># 描述器</span></span><br><span class="line">    name = Field(<span class="string">'username'</span>, tp=str, null=<span class="literal">False</span>)</span><br><span class="line">    age = Field(tp=int)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"&lt;<span class="subst">&#123;self.__class__.__name__&#125;</span> sid=<span class="subst">&#123;self.sid&#125;</span> name=<span class="subst">&#123;self.name&#125;</span> age=<span class="subst">&#123;self.age&#125;</span>&gt;"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># s = Student(sid=1, gender=112)</span></span><br><span class="line">s = Student(sid=<span class="number">1</span>)</span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">s.name = <span class="number">123</span></span><br><span class="line">s.age=<span class="number">20</span></span><br><span class="line">print(s)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span> * <span class="number">30</span>)</span><br><span class="line">print(s.name, s.age, type(s.name))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>元编程</tag>
      </tags>
  </entry>
</search>

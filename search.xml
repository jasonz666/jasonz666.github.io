<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Sh 和 Bash 之间的区别</title>
    <url>/2018/12/24/diff-between-sh-and-bash.html</url>
    <content><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>一般情况下，<code>sh</code> 是指向 <code>bash</code> 的链接。查看 bash 的手册页可知，bash 作为 sh 运行时，相当于 <code>bash --posix</code>，即 sh 以符合 POSIX 标准的方式来运行。</p>
<p>在一次使用脚本的过程中，发现脚本中 <code>alias</code> 命令设置的别名始终无效。后来查资料发现，<code>bash</code> 和 <code>sh</code> 运行脚本的结果是不同的。</p>
<p>默认情况下，bash 运行非交互式 shell 时，是关闭 <code>alias</code> 别名扩展功能的，而脚本就是非交互式 shell。但是，sh 同样的情况下是开启别名扩展功能的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>① 使用 sh 运行脚本。</p>
<p>② 在脚本文件中显式地指出开启别名扩展功能，方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在脚本的 alias 命令之前添加如下命令</span></span><br><span class="line"><span class="comment"># 最好是在脚本的开头位置添加</span></span><br><span class="line"><span class="built_in">shopt</span> -s expand_aliases</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>关于 <code>bash</code> 与 <code>sh</code> 的差别可能还有更多，写脚本后应该充分测试。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/liuxiangke0210/article/details/66476970" target="_blank" rel="noopener">https://blog.csdn.net/liuxiangke0210/article/details/66476970</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Shell</tag>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用指定的 SSH 密钥克隆和提交</title>
    <url>/2018/12/23/git-commit-via-ssh-key.html</url>
    <content><![CDATA[<h2 id="Git-使用指定的密钥"><a href="#Git-使用指定的密钥" class="headerlink" title="Git 使用指定的密钥"></a>Git 使用指定的密钥</h2><p>默认情况，Git 会使用 <code>~/.ssh/id_ecdsa</code> 来登录远程仓库，比如登录 <code>github.com</code>。我这里使用的是 <code>ecdsa</code> 算法，所以是 <code>id_ecdsa</code>。</p>
<p>怎么样使用指定的密钥呢？比如使用 <code>id_ecdsa_123</code>。创建 ssh 配置文件 <code>config</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件内容</span></span><br><span class="line">Host github.com</span><br><span class="line">    HostName github.com</span><br><span class="line">    User git</span><br><span class="line">    IdentityFile ~/.ssh/id_ecdsa_github</span><br><span class="line">    IdentitiesOnly yes</span><br></pre></td></tr></table></figure>

<p>配置文件的含义：</p>
<ul>
<li><code>Host github.com</code>：指定一个主机</li>
<li><code>HostName github.com</code>：上面指定的主机的主机名</li>
<li><code>User git</code>：登录该主机的用户名，如果是登录 <code>github.com</code>，就必须是 <code>git</code></li>
<li><code>IdentityFile ~/.ssh/id_ecdsa_github</code>：关键配置，这里指定了使用哪个私钥文件</li>
<li><code>IdentitiesOnly yes</code>：它指示 ssh 仅使用在命令行上指定的私钥文件或在 <code>config</code> 文件中配置的私钥文件</li>
</ul>
<a id="more"></a>

<h2 id="使用密钥克隆"><a href="#使用密钥克隆" class="headerlink" title="使用密钥克隆"></a>使用密钥克隆</h2><p>配置完上面的 <code>config</code> 文件之后，就可以使用指定的私钥文件来克隆。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:jasonz666/shell-utils</span><br></pre></td></tr></table></figure>

<h2 id="使用密钥提交修改"><a href="#使用密钥提交修改" class="headerlink" title="使用密钥提交修改"></a>使用密钥提交修改</h2><p>如果我们使用 HTTPS 方式克隆了一个仓库，而不是像上面那样使用 SSH 密钥方式。先要将 SSH 密钥登录远程服务器 <code>github.com</code> 的方式关联到本地仓库。执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入本地仓库目录</span></span><br><span class="line">$ <span class="built_in">cd</span> shell-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已关联的远程仓库服务器</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (fetch)</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (push)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新的远程仓库服务器</span></span><br><span class="line">$ git remote add ssh git@github.com:jasonz666/shell-utils</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看远程仓库服务器</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (fetch)</span><br><span class="line">origin	https://github.com/jasonz666/shell-utils (push)</span><br><span class="line">ssh	gitgit@github.com:jasonz666/shell-utils (fetch)</span><br><span class="line">ssh	gitgit@github.com:jasonz666/shell-utils (push)</span><br></pre></td></tr></table></figure>

<p>使用 SSH 密钥方式提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push ssh master</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/82aa1678411e" target="_blank" rel="noopener">https://www.jianshu.com/p/82aa1678411e</a><br><a href="https://www.howtoing.com/fix-ssh-too-many-authentication-failures-error" target="_blank" rel="noopener">https://www.howtoing.com/fix-ssh-too-many-authentication-failures-error</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/12/21/hello-world.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用 GPG 密钥登录 SSH</title>
    <url>/2019/02/03/login-ssh-via-gpg-key.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>SSH 通常有密码登录和密钥登录两种方式。密钥登录时使用的是 SSH 的密钥，由 ssh-agent 来处理。这里介绍使用 GnuPG 生成的 PGP 密钥来登录 SSH。此时使用 gpg-agent 来处理登录过程。</p>
<p>使用 GPG 密钥登录的好处是便于管理服务器。只要把 GPG 密钥的公钥放到服务器上面，用同一个密钥可以登录所有这些服务器。还有，GnuPG 可以使用智能卡来保存密钥，使 SSH 密钥更加安全。</p>
<p><strong>注意：</strong></p>
<p>这篇文章使用 Ubuntu 18.04，并使用 GnuPG v2.2.X 来演示，小于 v2.2.X 的版本下文某些命令可能是无效的。运行如下命令查看版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --version</span><br></pre></td></tr></table></figure>

<h2 id="生成-GnuPG-密钥并添加认证密钥"><a href="#生成-GnuPG-密钥并添加认证密钥" class="headerlink" title="生成 GnuPG 密钥并添加认证密钥"></a>生成 GnuPG 密钥并添加认证密钥</h2><p>快速生成 GnuPG 密钥的方法详见 <a href="https://he.izhaojie.com/2019/01/09/learn-asymmetric-encryption-by-gpg.html" target="_blank" rel="noopener">这里</a></p>
<p>分步生成 GnuPG 密钥的方法详见：</p>
<ol>
<li><a href="https://linux.cn/article-9529-1.html" target="_blank" rel="noopener">生成主密钥</a></li>
<li><a href="https://linux.cn/article-9607-1.html" target="_blank" rel="noopener">生成认证密钥等子密钥</a></li>
</ol>
<p>生成属于自己的一对密钥后，再向这个密钥中添加一个认证密钥[A]。</p>
<a id="more"></a>

<p>最后，密钥看起来像下面这样。[A] 子密钥用于认证，即用于 SSH 登录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ gpg --list-key 0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">pub   rsa4096 2019-XX-XX [C] [有效至：20XX-XX-XX]</span><br><span class="line">      0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">uid           [ 绝对 ] Jason &lt;example@example.com&gt;</span><br><span class="line">sub   rsa4096 2019-01-15 [E]</span><br><span class="line">sub   rsa4096 2019-01-15 [A]</span><br><span class="line">sub   rsa4096 2019-01-15 [S]</span><br></pre></td></tr></table></figure>

<h2 id="设置用于-SSH-登录"><a href="#设置用于-SSH-登录" class="headerlink" title="设置用于 SSH 登录"></a>设置用于 SSH 登录</h2><h3 id="配置-gpg-agent-选项"><a href="#配置-gpg-agent-选项" class="headerlink" title="配置 gpg-agent 选项"></a>配置 gpg-agent 选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.gnupg/gpg-agent.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入下面三行</span></span><br><span class="line"><span class="comment"># 三行分别表示</span></span><br><span class="line"><span class="comment"># 输入一次 GPG 密码后，600 秒内不用重复输入，600 秒内再次使用密码会重置这个时间</span></span><br><span class="line"><span class="comment"># 从首次输入密码算起，不管最近一次使用密码是什么时间，只要最大 TTL 过期，就需要重新输入密码</span></span><br><span class="line"><span class="comment"># 启用 SSH 支持</span></span><br><span class="line"></span><br><span class="line">default-cache-ttl 600</span><br><span class="line">max-cache-ttl 7200</span><br><span class="line"><span class="built_in">enable</span>-ssh-support</span><br></pre></td></tr></table></figure>

<h3 id="修改-bashrc-文件"><a href="#修改-bashrc-文件" class="headerlink" title="修改 .bashrc 文件"></a>修改 .bashrc 文件</h3><p>让 ssh 与 gpg-agent 通信，而不是 ssh-agent。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 .bashrc 文件末尾添加如下一行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> SSH_AUTH_SOCK=$(gpgconf --list-dirs agent-ssh-socket)</span><br></pre></td></tr></table></figure>

<p>为了使更改生效，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">killall gpg-agent</span><br><span class="line">bash</span><br></pre></td></tr></table></figure>

<h3 id="获取认证密钥的-keygrip"><a href="#获取认证密钥的-keygrip" class="headerlink" title="获取认证密钥的 keygrip"></a>获取认证密钥的 keygrip</h3><p>为了告诉 gpg-agent 应该使用哪个认证子密钥，需要先获取认证子密钥的 keygrip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录下认证子密钥的 keygrip</span></span><br><span class="line"><span class="comment"># 下面的结果中 keygrip 就是</span></span><br><span class="line"><span class="comment"># 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC</span></span><br><span class="line"></span><br><span class="line">$ gpg --with-keygrip --list-key 0AAABBCCDDDDDDDDDDDDDDDDFFFFFFFXXXXXXXXZ</span><br><span class="line">...</span><br><span class="line">sub   rsa4096 2019-01-15 [A]</span><br><span class="line">      Keygrip = 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 keygrip</span></span><br><span class="line"><span class="built_in">echo</span> 0BBBBBBBBBBZZZZZZZZZZZZZZXXXXXXXXZZBBBCC &gt;&gt; ~/.gnupg/sshcontrol</span><br></pre></td></tr></table></figure>

<h3 id="列出-SSH-格式的-GPG-认证密钥的公钥"><a href="#列出-SSH-格式的-GPG-认证密钥的公钥" class="headerlink" title="列出 SSH 格式的 GPG 认证密钥的公钥"></a>列出 SSH 格式的 GPG 认证密钥的公钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面命令会列出 GPG 认证密钥的公钥</span></span><br><span class="line">ssh-add -L</span><br></pre></td></tr></table></figure>

<p>把列出的公钥，放到服务器上的文件 ~/.ssh/authorized_keys 里，就能通过 GPG 来使用 SSH 登录远程主机了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行如下命令测试是否能成功登入远程主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -p port username@remote_ip</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>Gpg</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 GPG 学习非对称加密</title>
    <url>/2019/01/09/learn-asymmetric-encryption-by-gpg.html</url>
    <content><![CDATA[<h2 id="非对称加密需要公钥和私钥："><a href="#非对称加密需要公钥和私钥：" class="headerlink" title="非对称加密需要公钥和私钥："></a>非对称加密需要公钥和私钥：</h2><p>你的公钥的作用：别人用来给你发加密的信息(公钥加密)＆别人验证你的签名(公钥解密)，即加密&amp;验证（别人来做）<br>你的私钥的作用：你用来创建签名(私钥加密)＆解密别人发给你的信息的(私钥解密)，即解密&amp;签名（你来做）</p>
<p>具体而言，Alice要想发送加密信息到Bob，则：<br>Alice有Alice的签名私钥和Bob的加密公匙<br>Bob有Alice的签名公匙和Bob的解密私钥</p>
<h2 id="使用GPG可以很好的演示这一点："><a href="#使用GPG可以很好的演示这一点：" class="headerlink" title="使用GPG可以很好的演示这一点："></a>使用GPG可以很好的演示这一点：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg (GnuPG) 2.1.11</span><br><span class="line">libgcrypt 1.6.5</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>首先，我们在安装好GPG之后（<a href="https://www.gnupg.org/howtos/zh/index.html" target="_blank" rel="noopener">GnuPG官方文档</a>），可以使用 <code>gpg --gen-key</code> 生成属于我们自己的一对公钥和私钥（通常一个GPG密钥包含多个RSA密钥对，一对主密钥，若干对不同用途的子密钥，一对密钥包括一个公钥和一个私钥。一般 <code>gpg --gen-key</code> 得到的，就包括一对主密钥，可以用于签名与认证[SC]；一对子密钥用于加密[E]）。之后我们可以使用 <code>gpg --export [UID]</code> 来输出UID所对应的公钥，比如对于我来说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~ $ gpg --<span class="built_in">export</span> -a 刘海博</span><br><span class="line">-----BEGIN PGP PUBLIC KEY BLOCK-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">mQENBFbnwUkBCADtMQ73lZ1XEbcNbGyaF5IHQ1aoYBrIhj+BpXbV9Qz95OxqOoFP</span><br><span class="line">6s0n1/cBhpjhhqm2hlJFhwrKIDMkTKBY0rif3ZHdHVKK7k7xW0qYWa0HZDtRApao</span><br><span class="line">N3lZ3Ay2EyTSPj6SoFxleLm8LoftlDscp90kK/zGiXf95pslTmk4ziSolOtPTvP7</span><br><span class="line">FpSaYizOO3JfUKUDrTdXRcEx2p7KmXi8v1O33bY0YG6yRmff90DzMxYqQ2LUQBfl</span><br><span class="line">hVSu3mYKpP5IQ0tNgTCbUiyVqOX+TdxQoqMiTWiWvD5OJZf+7RqnbpQ9l6epmUEk</span><br><span class="line">HAJcvhcEfLeDslt2o+x2s7BXW1o71/Xa3Q/fABEBAAG0HuWImOa1t+WNmiA8c2hp</span><br><span class="line">bmluZ2xoYkAxNjMuY29tPokBNwQTAQgAIQUCVufBSQIbAwULCQgHAgYVCAkKCwIE</span><br><span class="line">FgIDAQIeAQIXgAAKCRBbDqAL2u3LWxkXB/96dBtELKkA6hc2BLBxLBxchakEeaMK</span><br><span class="line">lXDEiom6kwiqeI/H3KJchOtlTbBLGUmSdRAm3rX5UkVtaDvxW6iWuNzcbDZN6oCe</span><br><span class="line">YCFqOvmzLZ+YWh48tRBJOTEzrkZrT/OpTGRtRI0cAIAJ68rMc5Vpxl1Vqknp/BzI</span><br><span class="line">z84qPGBWgThy/UlgcFnbkZVLh37FLmIhtTMIbA1whum570/a/bnKP6xWnB4P5ryn</span><br><span class="line">6lXLBMDMA2a0jtgzmywXm60nI6M77lzfd6UXGX0NQOU/AP+v0hNzkl4+KapEOONC</span><br><span class="line">x7MjoL09b946Tqysly5u6gJpK/YmD0UUnVrH2OW6YQy/UmXQk7mKjG/7uQENBFbn</span><br><span class="line">wUkBCACx3kvVDVjuo/LQrODb0wZig7NrsLasQ+dAOo/9UXY53wjrnLPiZLRbtYm1</span><br><span class="line">tPFMykAv/23+vLXmLFW7gd0PjGOPZE4Q0/vR/Re+vJjonH3Z6E+DidE7T9vQmuB4</span><br><span class="line">aLIvDpEcAWKSRN75/zLKzAysqHwEBXeSVD89bSMdH4rPpC70hABZZuVYC3rEkrdZ</span><br><span class="line">6EcW7jca71eKVTKQRznuTZKzpHG8XwcgTt5qtmbZmWxIT4SMdxyI//fpAUjDc913</span><br><span class="line">qN9i/ZY668g8URQLxCUTdFy04p1Vft1yCByZF9Pie5paVO28kgegZf1O6+k1rR42</span><br><span class="line">WHbtLFq7xYgW3vOG9I9yQdA8oOUHABEBAAGJAR8EGAEIAAkFAlbnwUkCGwwACgkQ</span><br><span class="line">Ww6gC9rty1vt+ggAza5faR5AeHgIOnUyI3j28GxFey3E7CbVRO0ubO7Iq5qy+P1z</span><br><span class="line">EQPmnpeQ/FpDabvP4P7qds77U2wFbvsa/Ar4ZuznmNuL9r8fGJn6BrmPLAMxfwOo</span><br><span class="line">c+w6qN0iYp+kl6pRTYYolICyZfq/CLrDKxUaAHlSpZoEI5CUIs/tntcLJRSei/1S</span><br><span class="line">GUjXS7sqlVafNM2Vqxy3XBqVffXGsUNXr1zRGz/Dia9Kt3sztDYDjo3csHlEPVTw</span><br><span class="line">v1gRxVTnsrmoQlJ7+S2tT6hocuD5k6Ye11vyCMYny6BxCYz5CW6HtvAWs9kXT6E3</span><br><span class="line">hTFS5THpkuu+uZLPM2CGJuFLdwNrBzMXHrqRaQ==</span><br><span class="line">=Eh6b</span><br><span class="line">-----END PGP PUBLIC KEY BLOCK-----</span><br></pre></td></tr></table></figure>

<p>以上就是我的公钥，其中 <code>-a</code> 是为了让字符以ASCII形式输出，而不是二进制。隐含地，结果将输出到标准输出（stdout）去，可以用 <code>-o</code> 选项把它放到一个文件里去。<br>之后，我们需要得到别人的公钥，才能用他的公钥加密我们想要发给他的数据。<code>gpg --import [filename]</code> 即可导入别人的公钥，这个存放公钥的文件可以使用 <code>-o</code> 选项导出。<br>我们可以通过 <code>gpg --list-keys</code> 查看当前所有的公钥，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --list-keys</span><br><span class="line">/home/lgl/.gnupg/pubring.kbx</span><br><span class="line">----------------------------</span><br><span class="line">pub   rsa2048/DAEDCB5B 2016-03-15 [SC]</span><br><span class="line">uid         [ 绝对 ] 刘海博 &lt;shininglhb@163.com&gt;</span><br><span class="line">sub   rsa2048/7D6453AF 2016-03-15 [E]</span><br><span class="line"></span><br><span class="line">pub   dsa1024/C9C40C31 2001-05-25 [SCA]</span><br><span class="line">uid         [ 未知 ] Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">uid         [ 未知 ] Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">sub   elg1024/59FAB546 2001-05-25 [E]</span><br></pre></td></tr></table></figure>

<p>说明我现在有两个公钥，一个是我自己的，另一个是Justin的。钥匙号分别为 <code>DAEDCB5B</code> 和 <code>C9C40C31</code> ，说到钥匙号，我们也可以使用别人的公钥钥匙号导入公钥 <code>gpg --recv-keys 0xC9C40C31</code> 。<br>如果此时Justin用自己的私钥给文件签名（假设签名后的文件为sample.txt.asc，关于签名的内容我们会在最后再说）然后发给我，那么我就可以用公钥去验证文件签名的真伪：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --verify sample.txt.asc</span><br><span class="line">gpg: 于 Fri 17 Aug 2001 06:56:01 AM CST 创建的签名，使用 DSA，钥匙号 C9C40C31</span><br><span class="line">gpg: 完好的签名，来自于“Justin R. Miller &lt;justin@solidlinux.com&gt;” [未知]</span><br><span class="line">gpg:               亦即“Justin R. Miller &lt;justin@voxel.net&gt;” [未知]</span><br><span class="line">gpg: 警告：这把密钥未经受信任的签名认证！</span><br><span class="line">gpg:       没有证据表明这个签名属于它所声称的持有者。</span><br><span class="line">主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br></pre></td></tr></table></figure>

<p>以上信息可以看出，我们使用Justin的公钥可以认证这个文件，且文件的内容未曾被更改。但是有警告信息，这些信息是在告诉我们：如果这把公钥真的是Justin的，那么这个文件就是Justin的，但是这把公钥的真伪并没有的到验证，可能存在我们当初得到的公钥是被别人替换过的公钥的情况。为此，我们应当跟Justin本人确认此公钥的正确性，如果确认无误，我们可以对这个公钥进行信任程度设置（稍后再讲信任度的设置）。<br>如果使用了 <code>--detach-sign</code> 选项（下文会讲到此选项的含义）将签名保存到单独的文件里，那么完整的验证命令是这样的 <code>gpg --verify signfile [datafile]</code>。比如 <code>gpg --verify sample.txt.asc sample.txt</code> (如果 sample.txt.asc 是单独的签名文件，sample.txt 是原始数据文件的话)。</p>
<h2 id="接下来看使用GPG加密与解密的过程："><a href="#接下来看使用GPG加密与解密的过程：" class="headerlink" title="接下来看使用GPG加密与解密的过程："></a>接下来看使用GPG加密与解密的过程：</h2><p>首先，我们写一些话，想要发给Justin（Hello.txt）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br></pre></td></tr></table></figure>

<p>既然我们想发给Justin，那么我们自然需要用Justin的公钥对其进行加密（然后Justin再用自己的私钥对我发过去的加密内容进行解密），加密使用到的命令是 <code>gpg -e 要加密的文件名</code> 或者是 <code>gpg --encrypt 要加密的文件名</code> ，我们可以再加 <code>-r</code> 参数直接指定要发送的人的UID（即选用指定的公钥），如果此处不使用 <code>-r</code> ，在执行加密的过程中也会要求填写接收人的UID：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r justin -e Hello.txt</span><br><span class="line">gpg: 59FAB546：没有证据表明这把密钥真的属于它所声称的持有者</span><br><span class="line">sub  elg1024/59FAB546 2001-05-25 Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"> 子钥指纹： 5B6A 9C4D 7C54 5936 B9F5  4D8B EDD4 CD22 59FA B546</span><br><span class="line"></span><br><span class="line">这把密钥并不一定属于用户标识声称的那个人。如果您真的知道自</span><br><span class="line">己在做什么，您可以在下一个问题回答 yes。</span><br><span class="line"></span><br><span class="line">无论如何还是使用这把密钥吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>以上可以看出，虽然我们对内容进行了加密，但是由于我们还没有对公钥进行信任度设置，gpg仍在提醒我们公钥本身有可能就是假的。<br>接下来看看加密后的内容（Hello.txt.gpg）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hello.txt.gpg</span><br><span class="line">����<span class="string">"Y��F�����re�5m�j ���</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>乱码，因为这是二进制文件。<br>试试在加密过程中加入 <code>--armor</code> 参数（以ASCII而不是二进制输出）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r justin -e --armor Hello.txt</span><br><span class="line">gpg: 59FAB546：没有证据表明这把密钥真的属于它所声称的持有者</span><br><span class="line">sub  elg1024/59FAB546 2001-05-25 Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"> 子钥指纹： 5B6A 9C4D 7C54 5936 B9F5  4D8B EDD4 CD22 59FA B546</span><br><span class="line"></span><br><span class="line">这把密钥并不一定属于用户标识声称的那个人。如果您真的知道自</span><br><span class="line">己在做什么，您可以在下一个问题回答 yes。</span><br><span class="line"></span><br><span class="line">无论如何还是使用这把密钥吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>接下来再查看加密后的文件（Hello.txt.asc）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hello.txt.asc</span><br><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQEOA+3UzSJZ+rVGEAP/YTDy4HcGP9PyvfKxH30fZtVJ/jqg/+NKJjTecuSdchSc</span><br><span class="line">RxDBwu0zEmpV0pdnllBteayfabPr1JDJdZ5UX6yCpsc/vON6nRVULGHSkACIXsmc</span><br><span class="line">m2vCTIMlbbnclu4bRSoXU5tI2tgWie6xFrZUMH7q4pRVUrL9wMYRyTUsP6wcJDYD</span><br><span class="line">/1ybF3IWEWjYiLWS+KDbiQUcvpLrJzXXNsiYsIUV4no1Uh14SOKraU3sz7zGq/Sy</span><br><span class="line">FuhdMALDENqVX2+tGhi9/u3qJq5NgSn1v+uUwJFqehYbO514LAxSczWSQGE7APUN</span><br><span class="line">vOPhLJURN7iHdN1cHnJvi2zvDHcvMssPwwPjUKtnnR3Z0oEBW8LuO7pICGZ5PDss</span><br><span class="line">4ItACKwNQYPcNGukYvO+LuRbE7uxMegROeqpLPOjVNsNOiCQVHl4pI9KSV+WLFXl</span><br><span class="line">xgurX4Up1uUi1rW1mPZEaXbnMT+rcenY508Dj6ayYAN07XP5/wg5HDQF0S2+OIhW</span><br><span class="line">VQEkj6DiqZfbIEUSz2SDm5zIZiU=</span><br><span class="line">=IMgg</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>虽然是字符，但显然内容已经被加密了，无法看懂。<br>我们把加密后的信息发给Justin之后，他直接用自己的私钥解密就可以阅读我们想给他传达的信息了（但是我无法演示解密过程，因为我没有Justin的私钥啊，现在这个世界上只有他可以解密这封密信了）。</p>
<h2 id="为了演示解密过程，我们再举一个例子："><a href="#为了演示解密过程，我们再举一个例子：" class="headerlink" title="为了演示解密过程，我们再举一个例子："></a>为了演示解密过程，我们再举一个例子：</h2><p>还是刚刚那个文件，命名为Hi.txt，这次我们用自己的公钥加密（这样我就可以用自己的私钥解密了）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r 刘海博 -e Hi.txt</span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hi.txt.gpg</span><br><span class="line">�`����5��<span class="comment">#MU\���˧4%</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>显然这个生成的Hi.txt.gpg是二进制的，我们再生成一个ASCII的，名称默认为Hi.txt.asc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -r 刘海博 -e --armor Hi.txt</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ cat Hi.txt.asc</span><br><span class="line">-----BEGIN PGP MESSAGE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line"></span><br><span class="line">hQEMA9RdjQJ9ZFOvAQgAhZ0OTp/AVjE+8eLxFUt5W4UM1ZbsiJ0KMB8gAPm+5Lqx</span><br><span class="line">ewOGtRXN2jWkRIuYXi0UKQmv/uTOUXQFDGpmeBtm2dkX+TV54GCdrarxq32soZzk</span><br><span class="line">Kxbvj0ucpiSP/EUsWtNacuThhzgiibxGZq6LlD71t6UZhVC8MtQ7AOi1yeh9cZV9</span><br><span class="line">KCJLH8a81yU6hL+uk8OnOn6RJW6jMaITNpN36k4kbwLbrYAzSkD/m9zEatVE/Jpm</span><br><span class="line">ozYyV9NznAETLZ3i+RcmTAMzP4Ka1R9luwSvNKdHbdEq/jboJZaS2Ye+JLfW38ID</span><br><span class="line">4P00Z91U0JoM64lqVlskzH2zIfZJpj+uLJiskQDw+NKCAbanCIfDqAn/2LYlDoMI</span><br><span class="line">oHRI6Qq58OSYj4iw2OVmzUYQQVLg0s4RsrMKHtLRWc8KR5wcw8pWxD0gdQrTqUEi</span><br><span class="line">tvv9y2c3afhn7AQzDvtIxrQIt/7MS37e4A6Y6f9Ax43rWLmL0198tRuojrwpk6UR</span><br><span class="line">uTF5oyUpJx2VFYUDtVh2JKCzjQ==</span><br><span class="line">=zvVm</span><br><span class="line">-----END PGP MESSAGE-----</span><br></pre></td></tr></table></figure>

<p>对于这两个加密的文件（一个Hi.txt.gpg，一个Hi.txt.asc），分别对其进行解密，使用 <code>gpg -d 密文文件名</code> 或者 <code>gpg --decrypt 密文文件名</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hi.txt.asc</span><br><span class="line">gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 7D6453AF、生成于 2016-03-15</span><br><span class="line">  “刘海博 &lt;shininglhb@163.com&gt;”</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hi.txt.gpg</span><br><span class="line">gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 7D6453AF、生成于 2016-03-15</span><br><span class="line">  “刘海博 &lt;shininglhb@163.com&gt;”</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br></pre></td></tr></table></figure>

<p>均成功解密，显示了加密之前的信息。<br>此时，如果我们去解密刚刚用Justin的公钥加密过的文件Hello.txt.asc：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg -d Hello.txt.asc</span><br><span class="line">gpg: 由 1024 位的 ELG 密钥加密，钥匙号为 59FAB546、生成于 2001-05-25</span><br><span class="line">  “Justin R. Miller &lt;justin@solidlinux.com&gt;”</span><br><span class="line">gpg: 解密失败：没有秘匙</span><br></pre></td></tr></table></figure>

<p>显然失败了，因为我们只有属于自己的私钥，不可能解开别的公钥加密过的文件。<br>现在我们再来考虑一下信任度的设置。之前由于我们未对Justin的公钥进行信任度设置，每次用到Justin的公钥的时候，gpg都会友善的提醒我们，在我们获取此公钥的时候，有可能公钥已经被篡改了，因此此公钥有可能不是Justin本人的。但是如果我们确信这就是Justin的公钥，我们可以对其设置信任度，使用 <code>gpg --edit-key</code> ：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --edit-key justin@solidlinux.com</span><br><span class="line">gpg (GnuPG) 2.1.11; Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">gpg&gt; sign</span><br><span class="line">Really sign all text user IDs? (y/N) y</span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line"> 主钥指纹： 2231 DFF0 869E E3A5 885A  E7D4 F787 7A2B C9C4 0C31</span><br><span class="line"></span><br><span class="line"> Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line"> Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">您真的确定要签名这把密钥，使用您的密钥</span><br><span class="line">“刘海博 &lt;shininglhb@163.com&gt;”(DAEDCB5B)</span><br><span class="line"></span><br><span class="line">真的要签名吗？(y/N)y</span><br><span class="line"></span><br><span class="line">gpg&gt; trust</span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：未知        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line"></span><br><span class="line">您是否相信这位用户有能力验证其他用户密钥的有效性(查对身份证、通过不同的渠道检查</span><br><span class="line">指纹等)？</span><br><span class="line"></span><br><span class="line">  1 = 我不知道或我不作答</span><br><span class="line">  2 = 我不相信</span><br><span class="line">  3 = 我勉强相信</span><br><span class="line">  4 = 我完全相信</span><br><span class="line">  5 = 我绝对相信</span><br><span class="line">  m = 回到主菜单</span><br><span class="line"></span><br><span class="line">您的决定是什么？5</span><br><span class="line">您真的要把这把密钥设成绝对信任？(y/N)n</span><br><span class="line">您的决定是什么？4</span><br><span class="line"></span><br><span class="line">pub  dsa1024/C9C40C31</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：SCA</span><br><span class="line"> 信任度：完全        有效性：未知</span><br><span class="line">sub  elg1024/59FAB546</span><br><span class="line"> 创建于：2001-05-25  有效至：永不过期  可用于：E</span><br><span class="line">[ 未知 ] (1). Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">[ 未知 ] (2)  Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">请注意，在您重启程序之前，显示的密钥有效性未必正确，</span><br><span class="line"></span><br><span class="line">gpg&gt; quit</span><br><span class="line">要保存变动吗？(y/N)y</span><br></pre></td></tr></table></figure>

<p>之后再查看公钥列表：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/GPGtest $ gpg --list-keys</span><br><span class="line">gpg: 正在检查信任度数据库</span><br><span class="line">gpg: marginals needed: 3  completes needed: 1  trust model: PGP</span><br><span class="line">gpg: 深度：0 有效性：  1 已签名：  1 信任度：0-，0q，0n，0m，0f，1u</span><br><span class="line">gpg: 深度：1 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，1f，0u</span><br><span class="line">/home/lgl/.gnupg/pubring.kbx</span><br><span class="line">----------------------------</span><br><span class="line">pub   rsa2048/DAEDCB5B 2016-03-15 [SC]</span><br><span class="line">uid         [ 绝对 ] 刘海博 &lt;shininglhb@163.com&gt;</span><br><span class="line">sub   rsa2048/7D6453AF 2016-03-15 [E]</span><br><span class="line"></span><br><span class="line">pub   dsa1024/C9C40C31 2001-05-25 [SCA]</span><br><span class="line">uid         [ 完全 ] Justin R. Miller &lt;justin@solidlinux.com&gt;</span><br><span class="line">uid         [ 完全 ] Justin R. Miller &lt;justin@voxel.net&gt;</span><br><span class="line">sub   elg1024/59FAB546 2001-05-25 [E]</span><br></pre></td></tr></table></figure>

<p>原来Justin的公钥之前显示的[未知]已经变成我们设置的[完全]了。我们可以发现我们自己的公钥被默认设置为绝对信任，这显然是必须的，也是肯定正确的。我们还可以发现修改完信任度之后再查询公钥时，gpg会先查询信任度数据库，这说明这些信任信息不是存在储存钥匙的文件里，而是存在另一个文件里的。</p>
<h2 id="最后，我们说一下签名："><a href="#最后，我们说一下签名：" class="headerlink" title="最后，我们说一下签名："></a>最后，我们说一下签名：</h2><p>为避免 “别人宣称是你” 这样的风险，对所有你加密的东西签名是有用的。签名的意义在于两个方面：Authenticity(身份认证)和Integrity(数据完整性)。即数字签名可以证明数据是你发送的，并同时证明发送的内容未曾被别人修改过。<br>签名的命令为 <code>gpg -s [Data]</code> 或者 <code>gpg --sign [Data]</code> 。这样做的时候，同时数据也被压缩。也就是说，最终结果是无法直接读懂的。若你想要一个能直接读懂的结果，你可以用 <code>gpg --clearsign [Data]</code> ，这样就能保证结果是清晰可读的。同时它也照样对数据签名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -s Hi.txt</span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --clearsign Hi.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其实也可以对加密后的信息进行签名</span></span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --clearsign Hi.txt.asc</span><br></pre></td></tr></table></figure>

<p>上面两条命令分别生成了Hi.txt.gpg和Hi.txt.asc两个文件。<br>需要注意的是，刚刚的签名自然是签的我们自己的名，所以用的是我们自己的私钥，需要用我们自己的公钥认证签名 <code>gpg --verify 签名文件</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.asc</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.gpg</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:18 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>两个文件均验证为正确，说明这两个文件是“刘海博”签的名。<br>用 <code>gpg -b (--detach-sign) [Data]</code>，还可以将签名写进另一个文件。我们高度推荐这种用法，尤其是对二进制文件（如文档）签名的时候。另外，<code>--armor</code> 选项在这儿也非常有用。<br>签名后的文件，我们还可以使用解密来读取：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -d Hi.txt.asc</span><br><span class="line">Hello, I am Liu Haibo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 完好的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>可以看到区别就在与 <code>verify</code> 只显示认证的结果，而 <code>decrypt</code> 同时也显示出了原数据的内容。<br>如果这个时候我们对认证后的动动手脚，修改一些内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lgl@pArch ~/tmp/minecraft $ gpg --verify Hi.txt.asc</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 已损坏的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br><span class="line"></span><br><span class="line">lgl@pArch ~/tmp/minecraft $ gpg -d Hi.txt.asc</span><br><span class="line">Hello, I am Liu Haibdddddo.</span><br><span class="line">This is my sample text sending to Justin.</span><br><span class="line">gpg: 于 Wed 16 Mar 2016 02:33:42 AM CST 创建的签名，使用 RSA，钥匙号 DAEDCB5B</span><br><span class="line">gpg: 已损坏的签名，来自于“刘海博 &lt;shininglhb@163.com&gt;” [绝对]</span><br></pre></td></tr></table></figure>

<p>可以看出签名的第二个功能生效了，我们可以根据签名验证文件内容是否被修改。<br>有趣的是，如果再把修改过后的内容修改回去，则认证又会再次通过。这也说明了签名的确就是对整个文件的内容进行Hash产生的。<br>而且，不管什么样的文件，签名的时候只是单纯的在文件内容前后添加头尾，即以下格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-----BEGIN PGP SIGNED MESSAGE-----</span><br><span class="line">Hash: SHA256</span><br><span class="line"></span><br><span class="line">// 此处为原文件内容或者是加密后的密文</span><br><span class="line"></span><br><span class="line">-----BEGIN PGP SIGNATURE-----</span><br><span class="line">Version: GnuPG v2</span><br><span class="line">// 此处为加密后的签名信息</span><br><span class="line">-----END PGP SIGNATURE-----</span><br></pre></td></tr></table></figure>

<h2 id="为什么要先签名后加密？"><a href="#为什么要先签名后加密？" class="headerlink" title="为什么要先签名后加密？"></a>为什么要先签名后加密？</h2><p>答：<br>主要是为了抵御中间人攻击和公钥伪造。<br>比如Alice要发送信息给Bob。</p>
<p>1）如果Alice与Bob之间交换公钥没有其他任何人截获，那先加密再签名也没事。因为Bob明确地知道Alice的公钥只有自己才有，只要有人篡改信息，Bob这边验证就会失败。<br>2）如果Alice与Bob通过网络传递公钥，可能中间人Eve会截获他们的公钥。此时Eve有Alice的公钥，他可以解密文件中的签名信息，然后用自己的私钥签名文件内容来冒充Alice（从上文的内容可看到先加密后签名生成的文件签名部分与原文内容部分是分开的），Eve很容易用自己的假签名替换Alice的签名。然后Eve再把自己的公钥传递给Bob，在Bob收到文件后，用假公钥进行了验证却把假公钥误认为是Alice。</p>
<p>但是，如果先签名后加密，那么原文内容和签名信息是合在一起被加密的。即使Eve截获文件，也无法解密内容来替换成假签名。因为只有Bob才有私钥可以解密文件。但这样还是无法避免Alice和Bob交换公钥时被Eve截获然后冒充。</p>
<p>因此，更安全的办法是：<br>Alice对自己的公钥也进行签名，GnuPG默认就是这么做的。签名后就会有一个公钥的指纹。Alice把自己公钥的指纹放在一个十分安全且无法被篡改的地方。Bob拿到Alice的公钥后，读取公钥指纹，然后去这个十分安全的地方对照指纹是不是一样，从而确定这个公钥是不是真的属于Alice。</p>
<p>要做到既加密又签名，完整的命令行大致如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg [-u Sender] [-r Recipient] [--armor] --sign --encrypt [Data]</span><br></pre></td></tr></table></figure>

<h2 id="最后说一下密钥迁移的问题："><a href="#最后说一下密钥迁移的问题：" class="headerlink" title="最后说一下密钥迁移的问题："></a>最后说一下密钥迁移的问题：</h2><p>如果我们现在想换电脑，无疑我们需要把之前的公钥和自己的私钥全部都导出来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --<span class="built_in">export</span> puppylpg &gt; puppylpg.public</span><br><span class="line">gpg --<span class="built_in">export</span>-secret-key puppylpg &gt; puppylpg.private</span><br></pre></td></tr></table></figure>

<p>我们将puppylpg的两个密钥导出成为两个文件，之后再导入另一个电脑。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gpg --import puppylpg.public</span><br><span class="line">gpg --allow-secret-key-import --import puppylpg.private</span><br></pre></td></tr></table></figure>

<p>注意导入私钥的时候需要添加 <code>--allow-secret-key-import</code> 给予允许添加私钥的权限，并且也不能遗漏 <code>--import</code> 参数。</p>
<p>即便用导出密钥的方式来备份密钥，主机系统上的 GPG 密钥仍有被盗的风险。为了获得最佳安全性，可以使用 USB 类型的智能卡配合 GPG 从而保护密钥。这样的智能卡有 <code>Nitrokey Pro</code> 和 <code>Yubikey 4</code> 等等。查看下面链接获取这些智能卡的使用详情：</p>
<p><a href="https://zh.wikipedia.org/wiki/YubiKey" target="_blank" rel="noopener">Yubikey Wiki</a><br><a href="https://www.jebbs.co/2017/01/20/use-gpg-with-smart-card/" target="_blank" rel="noopener">在 GPG 中使用智能卡</a><br><a href="http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html" target="_blank" rel="noopener">Yubikey 4 简介与配置</a><br><a href="https://mechanus.io/ke-neng-shi-zui-hao-de-yubikey-gpg-ssh-zhi-neng-qia-jiao-cheng/" target="_blank" rel="noopener">可能是最好的 Yubikey + GPG/SSH 智能卡教程</a></p>
<p>参考：</p>
<blockquote>
<p>原文：<a href="https://blog.csdn.net/puppylpg/article/details/50901779" target="_blank" rel="noopener">https://blog.csdn.net/puppylpg/article/details/50901779</a><br>参考：<a href="http://blog.csdn.net/puppylpg/article/details/50899484" target="_blank" rel="noopener">http://blog.csdn.net/puppylpg/article/details/50899484</a><br>参考：<a href="http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html" target="_blank" rel="noopener">http://www.shafa.com/articles/zhPd9zCFMDay8Nax.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Gpg</tag>
        <tag>Encryption</tag>
      </tags>
  </entry>
  <entry>
    <title>设置 Ubuntu 18.04 夜灯的色温</title>
    <url>/2018/12/24/set-ubuntu-night-light-temperature.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 Ubuntu 18.04 里，系统设置，设备，显示 里可以开启夜灯：</p>
<img src="/2018/12/24/set-ubuntu-night-light-temperature/2018-12-24%2022-01-58%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="">

<p>但是，没有调整夜灯色温的功能。</p>
<a id="more"></a>

<h2 id="设置夜灯色温"><a href="#设置夜灯色温" class="headerlink" title="设置夜灯色温"></a>设置夜灯色温</h2><ol>
<li>安装软件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>打开软件 <code>dconf-editor</code>：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dconf-editor</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>鼠标点击找到如下路径：</li>
</ol>
<p><code>/org/gnome/settings-daemon/plugins/color/night-light-temperature</code></p>
<ol start="4">
<li>设置自定义值：</li>
</ol>
<p>关闭 <code>使用默认值</code>，然后输入一个 <code>自定义值</code>：</p>
<img src="/2018/12/24/set-ubuntu-night-light-temperature/2018-12-24%2022-11-12%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png" class="">

<h2 id="色温值参考"><a href="#色温值参考" class="headerlink" title="色温值参考"></a>色温值参考</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1000  —  最低值（最暖色调/效果最红）</span><br><span class="line">4000  —  默认值</span><br><span class="line">5500  —  适中值</span><br><span class="line">6500  —  关闭夜灯时的色温值</span><br><span class="line">10000 —  最高值（最冷色调/效果最蓝）</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<blockquote>
<p><a href="https://www.omgubuntu.co.uk/2017/07/adjust-color-temperature-gnome-night-light" target="_blank" rel="noopener">https://www.omgubuntu.co.uk/2017/07/adjust-color-temperature-gnome-night-light</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu 18.04 禁用 nouveau 安装 NVIDIA 显卡驱动</title>
    <url>/2019/01/28/ubuntu-install-nvidia-driver.html</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>1）从 NVIDIA 官网下载对应显卡的驱动备用</p>
<p><a href="https://www.nvidia.cn/Download/index.aspx?lang=cn" target="_blank" rel="noopener">https://www.nvidia.cn/Download/index.aspx?lang=cn</a></p>
<p>我下载的驱动是：NVIDIA-Linux-x86_64-410.93.run<br>安装环境：华硕笔记本 Ubuntu 18.04</p>
<p><strong>注意</strong>：<br>主板 BIOS 必须关闭安全启动 (Secure Boot)，不然安装的 NVIDIA 驱动无法加载。<br>但此时，还是能正常进 Ubuntu 桌面，可能是此时使用的是 Intel 核显有关。</p>
<p>2）首次运行 NVIDIA 驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x NVIDIA-Linux-x86_64-410.93.run</span><br><span class="line">sudo ./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure>

<p>首次运行驱动程序，不会安装，因为系统中有 nouveau 驱动存在。<br>但是 NVIDIA-Linux-x86_64-410.93.run 会生成 <code>/etc/modprobe.d/nvidia-installer-disable-nouveau.conf</code> 文件。用于禁用系统自带的 nouveau 驱动。该文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat /etc/modprobe.d/nvidia-installer-disable-nouveau.conf</span><br><span class="line"><span class="comment"># generated by nvidia-installer</span></span><br><span class="line">blacklist nouveau</span><br><span class="line">options nouveau modeset=0</span><br></pre></td></tr></table></figure>

<p>3）使禁用生效</p>
<p>只有 blacklist 并不能真的禁用 nouveau 驱动。执行如下命令更新 initramfs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>

<p>然后，重启系统，禁用就成功了。执行如下命令验证：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 输出结果为空说明已经禁用 nouveau 驱动</span></span><br><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h2 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h2><p>1）开始安装 NVIDIA 驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-410.93.run</span><br></pre></td></tr></table></figure>

<p>安装完，重启系统</p>
<p>2）查看是否安装成功</p>
<p>运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行下面命令查看显卡驱动部分，如果有 Kernel driver in use: nvidia 则成功</span></span><br><span class="line">lspci -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以运行如下命令，看看 nvidia 模块是否加载成功</span></span><br><span class="line">lsmod | grep nvidia</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>运行 <code>glxgears</code>，如果帧数远大于 60 FPS，说明 nvidia 驱动已在使用，因为 NVIDIA 驱动安装后，默认不会开启垂直同步。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install mesa-utils</span><br><span class="line">glxgears</span><br></pre></td></tr></table></figure>

<p>最后，笔记本盒盖睡眠，再打开，没有黑屏，唤醒成功。</p>
<h2 id="可选：开启垂直同步解决画面撕裂"><a href="#可选：开启垂直同步解决画面撕裂" class="headerlink" title="可选：开启垂直同步解决画面撕裂"></a>可选：开启垂直同步解决画面撕裂</h2><p>安装完 NVIDIA 驱动后，默认不开启同步，有可能出现画面撕裂。解决办法如下。</p>
<p>1）在终端运行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/modprobe.d/nvidia-drm-nomodeset.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加入如下一行</span></span><br><span class="line">options nvidia-drm modeset=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新到 initramfs</span></span><br><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>

<p>重启系统。</p>
<p>2）重启系统后查看结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面命令应该是输出 "Y" 而不是 "N"</span></span><br><span class="line">sudo cat /sys/module/nvidia_drm/parameters/modeset</span><br></pre></td></tr></table></figure>

<p>3）设置 NVIDIA 驱动</p>
<p>终端运行命令 <code>nvidia-settings</code> 打开驱动设置窗口。<br>在窗口左侧选择 <code>GPU 0-(xxx)</code> –&gt; <code>PowerMizer</code> –&gt; 设置 <code>PowerMizer Settings</code> 为 <code>Prefer Maximum Performance</code>。</p>
<p>4）让系统尽可能地使用物理内存而不是交换空间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文末加入两行（默认值为 60）：</span></span><br><span class="line"><span class="comment"># User defines</span></span><br><span class="line">vm.swappiness=10</span><br></pre></td></tr></table></figure>

<p>然后，重启系统。运行 <code>cat /proc/sys/vm/swappiness</code> 查看结果。</p>
<h2 id="如果要卸载驱动"><a href="#如果要卸载驱动" class="headerlink" title="如果要卸载驱动"></a>如果要卸载驱动</h2><p>装完 NVIDIA 驱动后，如果要卸载，会有一个命令 <code>nvidia-uninstall</code> 用来卸载驱动。但是同时要删除文件 <code>/etc/modprobe.d/nvidia-installer-disable-nouveau.conf</code> 文件，然后运行 <code>sudo update-initramfs -u</code>，让 nouveau 驱动再次生效。</p>
<p>参考：<br><a href="https://blog.csdn.net/u012442845/article/details/78855573" target="_blank" rel="noopener">https://blog.csdn.net/u012442845/article/details/78855573</a><br><a href="https://askubuntu.com/questions/1031511/cant-disable-nouveau-drivers-in-ubuntu-18-04" target="_blank" rel="noopener">https://askubuntu.com/questions/1031511/cant-disable-nouveau-drivers-in-ubuntu-18-04</a><br><a href="https://askubuntu.com/questions/1056363/how-to-disable-gui-on-boot-in-18-04-bionic-beaver" target="_blank" rel="noopener">https://askubuntu.com/questions/1056363/how-to-disable-gui-on-boot-in-18-04-bionic-beaver</a><br><a href="http://ubuntuhandbook.org/index.php/2018/07/fix-screen-tearing-ubuntu-18-04-optimus-laptops/" target="_blank" rel="noopener">http://ubuntuhandbook.org/index.php/2018/07/fix-screen-tearing-ubuntu-18-04-optimus-laptops/</a></p>
]]></content>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Bash 的输入输出重定向详解</title>
    <url>/2019/01/02/stdin-stdout-and-redirection.html</url>
    <content><![CDATA[<p>Linux 中每个进程维护了一个文件描述符表，如 shell 终端，默认有三个文件已打开，他们的文件描述符和文件对应关系为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fd 0: /dev/stdin -&gt; /proc/self/fd/0（前者是指向后者的软链接，下同）</span><br><span class="line">fd 1: /dev/stdout -&gt; /proc/self/fd/1</span><br><span class="line">fd 2: /dev/stderr -&gt; /proc/self/fd/2</span><br></pre></td></tr></table></figure>

<p>所以在该 shell 中创建新的的文件的描述符就从3开始。</p>
<p><strong>用于输入输出重定向使用的文件描述符大于9，所以安全可用的自定义文件描述符范围就是：3-9</strong></p>
<p>因为 Bash <a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">文档</a> 里有这样一句话：</p>
<blockquote>
<p>Redirections using file descriptors greater than 9 should be used with care, as they may conflict with file descriptors the shell uses internally.</p>
</blockquote>
<h2 id="下面的几个例子会分别演示"><a href="#下面的几个例子会分别演示" class="headerlink" title="下面的几个例子会分别演示"></a>下面的几个例子会分别演示</h2><p>1）输入输出重定向<br>2）复制输入输出文件描述符<br>3）移动输入输出文件描述符<br>4）关闭文件描述符和同时读写文件<br>5）将已重定向的输入/输出恢复到标准输入/标准输出</p>
<a id="more"></a>

<h3 id="脚本例子1"><a href="#脚本例子1" class="headerlink" title="脚本例子1"></a>脚本例子1</h3><p>这个例子讲的是 <code>输出重定向</code> 和 <code>复制输出文件描述符</code></p>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd4..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd4"</span> &gt;&amp;4</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd5..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd5"</span> &gt;&amp;5</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"write to fd6..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd6"</span> &gt;&amp;6</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh test.sh 3&gt;file3 4&gt;file4 5&gt;file5 6&gt;file6</span></span><br><span class="line">write to fd3...</span><br><span class="line">write to fd4...</span><br><span class="line">write to fd5...</span><br><span class="line">write to fd6...</span><br><span class="line">[root@jz ~]<span class="comment"># cat file*</span></span><br><span class="line">fd3</span><br><span class="line">fd4</span><br><span class="line">fd5</span><br><span class="line">fd6</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>创建自定义的文件描述符（fd）从 3 开始。test.sh 脚本中 &gt;&amp;n（n 表示文件描述符，为 3, 4, 5, 6）表示：<br>复制 fd n 作为 fd 1（1 即标准输出的文件描述符）的值（这里的复制可以理解为复制 fd n 指向的文件指针，fd n 的值 n 实际上是数组下标，数组元素才是指向文件的指针）<br>也就是说，fd 1 复制了 fd n 的值之后，fd 1 原本指向文件 /dev/stdout，而现在与 fd n 指向相同的文件，n 必须与实际文件关联，这个文件描述符 n 才是有效的<br>在上文的例子中，通过执行脚本 test.sh，fd 3 关联（重定向）到了实际文件 file3，fd 4 关联到了实际文件 file4 等等<br>fd 3, 4, 5, 6 关联了实际文件之后，脚本中的 echo “fdN” &gt;&amp;N 就可以依次把标准输出的内容保存到不同的文件了</p>
<h3 id="脚本例子2"><a href="#脚本例子2" class="headerlink" title="脚本例子2"></a>脚本例子2</h3><p>这个例子讲的是 <code>输入重定向</code> 和 <code>复制输入文件描述符</code></p>
<p>脚本内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"read from fd4..."</span></span><br><span class="line">cat &lt;&amp;4</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh test.sh 3&lt;file3 4&lt;file4</span></span><br><span class="line"><span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line"><span class="built_in">read</span> from fd4...</span><br><span class="line">fd4</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>和输出重定向差不多，例子2脚本中标准输入分别复制了：输入文件描述符3、输入文件描述符4，使得标准输入分别指向 file3、file4<br>执行脚本时，fd 3、fd 4 分别重定向到了 file3、file4，所以脚本中 cat &lt;&amp;N 就会依次从 file3、file4 读取内容（file3、file 4 是例子1脚本执行后创建的）<br>上面两个例子讲的是“<strong>复制文件描述符</strong>”和“<strong>输入输出重定向</strong>”，bash shell 也支持“<strong>移动文件描述符</strong>”，下面的脚本将实验移动文件描述符。</p>
<h3 id="脚本例子1-1"><a href="#脚本例子1-1" class="headerlink" title="脚本例子1"></a>脚本例子1</h3><p>这个例子讲的是 <code>移动输出文件描述符</code></p>
<p>脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: write to fd3..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"fd3"</span> &gt;&amp;3</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&gt;file3</span></span><br><span class="line">1: write to fd3...</span><br><span class="line">2: write to fd3...</span><br><span class="line">3: write to fd3...</span><br><span class="line">move_fn.sh: line 8: 3: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>1）与复制文件描述符不同的是，脚本中 &gt;&amp;3- 表示在 fd 1 复制了 fd 3 的文件指针以后，fd 3 就会关闭，就好像 fd 3 移动到了 fd 1 一样<br>注意脚本执行结果，第1次写入内容到 fd 3 是正常的，第2次写入时也正常，但之后 fd 3 就被关闭，即 fd 3 不再重定向到文件 file3<br>所以第3次写入内容时，就会报错，显示坏掉的文件描述符</p>
<p><strong>2）还有，一开始 file3 只有一行，最后变成了二行，因为脚本中的 echo 操作的文件从始至终都是 file3，脚本执行时，因为输出文件 fd 3 重定向到 file3</strong><br>脚本开始执行，file3 被打开，直到脚本结束，file3 文件才被关闭，所以脚本中每次执行完 echo “fd3” &gt;&amp;3[-] 都是向 file3 新增一行<br>而不会像终端下直接执行：echo “fd3” &gt; file3，每次都是覆盖文件，因为终端下每次执行 echo 都会单独打开/关闭文件 file3</p>
<h3 id="脚本例子2-1"><a href="#脚本例子2-1" class="headerlink" title="脚本例子2"></a>脚本例子2</h3><p>这个例子讲的是 <code>移动输入文件描述符</code></p>
<p>脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3-; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: read from fd3..."</span></span><br><span class="line"><span class="built_in">read</span> ln &lt;&amp;3; <span class="built_in">echo</span> <span class="variable">$ln</span>; ln=</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&lt;file3</span></span><br><span class="line">1: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">2: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">3: <span class="built_in">read</span> from fd3...</span><br><span class="line">move_fd.sh: line 8: 3: Bad file descriptor</span><br><span class="line"></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>脚本中使用 read 命令而不是 cat，因为 read 可以逐行读取文件，而 cat 会一次把文件所有行都读取完<br>类似脚本例子1，这里 &lt;&amp;3- 把输入文件描述符3关闭之后，下次执行 read 命令就会报错</p>
<p><strong>如果脚本例子2内容如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># move_fd.sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3-</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3: read from fd3..."</span></span><br><span class="line">cat &lt;&amp;3</span><br></pre></td></tr></table></figure>

<p>输出结果是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># sh move_fd.sh 3&lt;file3</span></span><br><span class="line">1: <span class="built_in">read</span> from fd3...</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">2: <span class="built_in">read</span> from fd3...</span><br><span class="line">3: <span class="built_in">read</span> from fd3...</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>可以看到，cat 并不会报错，可能是在 cat 一次读完文件后，cat 先判断文件是否读完，再判断文件描述符3是否可用（因为已读完就无需判断是否可用），所以不会报错</strong></p>
<h2 id="创建文件描述符来同时读写文件"><a href="#创建文件描述符来同时读写文件" class="headerlink" title="创建文件描述符来同时读写文件"></a>创建文件描述符来同时读写文件</h2><p>语法：<code>n&lt;&gt;filename</code></p>
<p>n 为文件描述符<br>filename 为实际文件名<br>n 不写时表示 fd 0</p>
<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="comment"># 如下命令行表示把输入/输出同时重定向到 inputfile 文件，而文件描述符是3</span></span><br><span class="line"><span class="comment"># 然后让标准输入指向 inputfile 文件，标准输出也指向 inputfile 文件</span></span><br><span class="line"><span class="comment"># 执行 exec 后，下面的命令标准输出都保存到 inputfile 文件，标准输入都读取自 inputfile</span></span><br><span class="line"><span class="comment"># 只有标准错误输出依旧是屏幕</span></span><br><span class="line"><span class="built_in">exec</span> 3&lt;&gt;inputfile &lt;&amp;3 &gt;&amp;3</span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">"1234"</span></span><br><span class="line">ls xxxx</span><br><span class="line">cat</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat inputfile</span></span><br><span class="line">abcde</span><br><span class="line">dsfsf</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh</span></span><br><span class="line">ls: cannot access xxxx: No such file or directory</span><br><span class="line">[root@jz ~]<span class="comment"># cat inputfile</span></span><br><span class="line">1234e</span><br><span class="line">dsfsf</span><br><span class="line">e</span><br><span class="line">dsfsf</span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>以上输出结果很复杂，涉及到文件读写操作的实现细节，猜测如下：<br>脚本执行后，执行到 exec 命令行，文件 inputfile 被打开，文件读写指针应该是指向文件开头的<br>此时运行 echo 命令行，把 1234 写入到文件开头位置，覆盖掉 abcde 前4个字符变成 1234e，读写指针在字符 e 的位置<br>执行 ls 时因为文件不存在，信息输出到标准错误，所以文件 inputfile 读写指针位置不变<br>执行 cat 从字符 e 开始读取，直到文件结尾，读到的内容是：<br>e<br>dsfsf</p>
<p>因为文件被 exec 打开，cat 并不会关闭文件，cat 读取出来的内容会再次写入 inputfile 文件，此时读写指针在文件结尾<br>cat 读出的内容添加到文件结尾之后，变成：<br>1234e<br>dsfsf<br>e<br>dsfsf</p>
<h2 id="关闭文件描述符"><a href="#关闭文件描述符" class="headerlink" title="关闭文件描述符"></a>关闭文件描述符</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;&amp;- 关闭标准输入</span><br><span class="line">&gt;&amp;- 关闭标准输出</span><br><span class="line">n&lt;&amp;- 表示将 n 号输入关闭</span><br><span class="line">n&gt;&amp;- 表示将 n 号输出关闭</span><br></pre></td></tr></table></figure>

<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat &lt;&amp;-           # 关闭标准输入</span></span><br><span class="line">cat: -: Bad file descriptor</span><br><span class="line">cat: closing standard input: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># ls &gt;&amp;-            # 关闭标准输出</span></span><br><span class="line">ls: write error: Bad file descriptor</span><br><span class="line">[root@jz ~]<span class="comment"># ls xxxx 2&gt;&amp;-      # xxxx 文件不存在，关闭标准错误后，错误信息不会输出</span></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="最后，说说怎么恢复到标准输入-标准输出"><a href="#最后，说说怎么恢复到标准输入-标准输出" class="headerlink" title="最后，说说怎么恢复到标准输入/标准输出"></a>最后，说说怎么恢复到标准输入/标准输出</h2><p>其实很简单，上文已经讲了复制文件描述符，只需要把标准输入输出，或标准错误先复制保存，之后恢复即可。</p>
<p>举例脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter to continue ..."</span></span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@jz ~]<span class="comment"># cat file3</span></span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">fd3</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh</span></span><br><span class="line">Enter to <span class="built_in">continue</span> ...</span><br><span class="line">[root@jz ~]<span class="comment"># sh test.sh &lt;file3    # 脚本的输入被重定向到 file3 后，read 命令直接读取了 file3 的行，不再显示 Enter ...</span></span><br><span class="line">[root@jz ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p><strong>那么，怎么把 read 的输入恢复到标准输入，再次询问用户按回车继续呢？</strong></p>
<p>把脚本改成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment"># test.sh</span></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"Enter to continue ..."</span> &lt;&amp;3</span><br></pre></td></tr></table></figure>

<p>然后用如下方式执行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh test.sh 3&lt;&amp;0 &lt;file3</span><br></pre></td></tr></table></figure>

<p>执行脚本时，它的含义是先创建一个新的文件描述符3，fd 3 复制 fd 0 的值，就把 fd 0 保存到 fd 3 了，然后在脚本中 read 命令的标准输入文件描述符从 fd 3 复制回来即可。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://www.gnu.org/software/bash/manual/html_node/Redirections.html" target="_blank" rel="noopener">https://www.gnu.org/software/bash/manual/html_node/Redirections.html</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>Bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用总结 01</title>
    <url>/2018/12/21/pro-git-summary-1.html</url>
    <content><![CDATA[<h2 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h2><blockquote>
<p>下文的所有命令都在普通用户下执行，因此有些命令前会有 <code>$</code> 号，系统是 <code>Debian 9.6</code>，Git 版本是 <code>git version 2.11.0</code>。本文参考：<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Pro Git v2 CHS</a> 的第1章，第2章。</p>
</blockquote>
<h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>已提交（committed）、已修改（modified）、已暂存（staged）</p>
<h3 id="工作区的三个概念"><a href="#工作区的三个概念" class="headerlink" title="工作区的三个概念"></a>工作区的三个概念</h3><p>有三种状态，相应的就有三个概念：Git 仓库、工作目录、暂存区域</p>
<p>已提交对应 Git 仓库，已修改对应工作目录，已暂存对应暂存区域。</p>
<h3 id="Git-的基本工作流程"><a href="#Git-的基本工作流程" class="headerlink" title="Git 的基本工作流程"></a>Git 的基本工作流程</h3><p>① 修改文件：在工作目录中修改文件。<br>② 暂存文件：将文件的快照放入暂存区域。<br>③ 提交更新：找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
<p>Git 不像其他版本管理系统，比较文件的差异并记录下来，Git 是直接记录文件的快照。因此 Git 更像是一个小型的文件系统，它把数据看作是对小型文件系统的一组快照。文件系统快照可以理解成是，对文件或目录的修改（不论是增，删，改）记录快照，下次就能恢复到原样。它恢复的信息是很全面的，不仅有文件的数据，还可以有文件或目录的元数据，比如创建时间，修改时间等等。</p>
<a id="more"></a>

<h2 id="在-Linux-上安装-Git"><a href="#在-Linux-上安装-Git" class="headerlink" title="在 Linux 上安装 Git"></a>在 Linux 上安装 Git</h2><p>Redhat 系或 Debian 系安装方式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">sudo yum install git</span><br><span class="line">sudo apt-get install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>

<h2 id="Git-的三个配置文件"><a href="#Git-的三个配置文件" class="headerlink" title="Git 的三个配置文件"></a>Git 的三个配置文件</h2><p>① <code>/etc/gitconfig</code>：系统级全局配置文件，对所有用户有效。使用带有 <code>--system</code> 选项的 <code>git config</code> 时，会读写此配置文件。<br>② <code>~/.gitconfig</code> 或 <code>~/.config/git/config</code>：当前用户的配置文件。传递 <code>--global</code> 选项可以读写此文件。<br>③ <code>.git/config</code>：当前仓库 Git 目录中的配置文件，针对该仓库。传递 <code>--local</code> 选项可以读写此文件。</p>
<p>每一个级别覆盖上一级别的配置，所以 <code>.git/config</code> 的配置变量会覆盖 <code>/etc/gitconfig</code> 中的配置变量。</p>
<h2 id="设置-Git-的用户信息和文本编辑器"><a href="#设置-Git-的用户信息和文本编辑器" class="headerlink" title="设置 Git 的用户信息和文本编辑器"></a>设置 Git 的用户信息和文本编辑器</h2><p>相关命令：<code>git config</code></p>
<p>安装完 Git 的第一件事是设置用户名和邮件地址。每个 Git 提交都会使用这些信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置用户名和邮件地址</span></span><br><span class="line">git config --global user.name <span class="string">"JasonZh"</span></span><br><span class="line">git config --global user.email <span class="string">"example@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 git 默认使用的文本编辑器</span></span><br><span class="line">git config --global core.editor vim</span><br></pre></td></tr></table></figure>

<p>查看 Git 的配置信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认会依次读取 /etc/ 下，~/ 下的配置文件</span></span><br><span class="line"><span class="comment"># 如果处于 Git 仓库目录中，还会读取 .git/ 下的配置文件</span></span><br><span class="line"><span class="comment"># 所以配置的生效优先级是 ".git/" &gt; "~/" &gt; "/etc/"</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某一项配置</span></span><br><span class="line">git config user.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定配置文件的配置项</span></span><br><span class="line"><span class="comment"># 仅查看全局配置项</span></span><br><span class="line">git config --system --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 仅查看当前用户配置项</span></span><br><span class="line">git config --global --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处于特定仓库目录内时</span></span><br><span class="line"><span class="comment"># 仅查看特定仓库的配置项</span></span><br><span class="line">git config --<span class="built_in">local</span> --list</span><br></pre></td></tr></table></figure>

<h2 id="获取-Git-帮助"><a href="#获取-Git-帮助" class="headerlink" title="获取 Git 帮助"></a>获取 Git 帮助</h2><p>有三种获取 Git 帮助的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">help</span> config</span><br><span class="line">git config --<span class="built_in">help</span></span><br><span class="line">man git-config</span><br></pre></td></tr></table></figure>

<h2 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h2><p>相关命令：<code>git init</code>, <code>git clone</code></p>
<p>有两种方法可以获取 Git 仓库：</p>
<p>① 初始化一个仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 假设把目录 test 当作 Git 仓库，先进入 test 目录，然后执行，完了会在目录里生成 .git 子目录，这是 Git 仓库的骨干目录</span></span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>② 克隆现有仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库克隆</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆并且重命名仓库名为 mylibgit</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure>

<h2 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h2><p>命令：<code>git status</code></p>
<p>下面以 libgit2 仓库为例。如果克隆仓库后，进入该仓库目录，立即运行如下命令，会看到：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新加一个文件，默认它处于 未跟踪（Untracked files） 状态，Git 不会自动跟踪新添加的文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次检查当前文件状态，新加的文件处于 未跟踪 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">    README</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">"git add"</span> to track)</span><br></pre></td></tr></table></figure>

<h2 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h2><p>把新添加的文件加到 Git 跟踪，使用 <code>git add</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个时候文件会处于 被跟踪（Changes to be committed） 状态，并且处于暂存状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br></pre></td></tr></table></figure>

<h3 id="注意-和-的区别"><a href="#注意-和-的区别" class="headerlink" title="注意 * 和 . 的区别"></a>注意 <code>*</code> 和 <code>.</code> 的区别</h3><p>① <code>git add *</code>：</p>
<p>添加所有文件到暂存区域。包括当前工作目录内所有子孙目录内的 . 开头的隐藏文件。但是不包括当前工作目录下的 . 开头的隐藏文件。</p>
<p>② <code>git add .</code>：</p>
<p>添加所有文件到暂存区域。同时包括当前工作目录下的隐藏文件。也就是说，用 <code>.</code> 号可以包含所有未暂存的文件。</p>
<h2 id="暂存已修改文件"><a href="#暂存已修改文件" class="headerlink" title="暂存已修改文件"></a>暂存已修改文件</h2><p>如果修改一个已被跟踪的文件，怎么暂存它呢，运行如下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如修改文件 README.md，这个文件之前处于已跟踪状态</span></span><br><span class="line"><span class="comment"># 修改后，这个文件处于 未暂存（Changes not staged for commit） 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>

<p>暂存已经修改的被跟踪的文件，还是运行 <code>git add</code> 命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看状态，此时文件 README.md 处于 已暂存（Changes to be commited） 状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   README</span><br><span class="line">    modified:   README.md</span><br></pre></td></tr></table></figure>

<h2 id="Git-状态预览"><a href="#Git-状态预览" class="headerlink" title="Git 状态预览"></a>Git 状态预览</h2><p>上面用的 <code>git status</code> 命令会显示比较详细的信息，加 <code>-s</code> 或 <code>--short</code> 选项可以显示简短的文件状态：</p>
<img src="/2018/12/21/pro-git-summary-1/git-status-s.PNG" class="" title="git-status-s">

<h3 id="简短格式显示状态时，有6种情况"><a href="#简短格式显示状态时，有6种情况" class="headerlink" title="简短格式显示状态时，有6种情况"></a>简短格式显示状态时，有6种情况</h3><p>① <code>??</code> 开头：新添加的，但未跟踪的文件；或者是移出暂存区变成未跟踪状态的文件<br>② <code>A</code> 开头：新添加的，且已加到暂存区中的文件，即新添加且已跟踪的文件<br>③ <code>M_</code>：左侧的 M，已被跟踪的文件，修改过，且已加入到暂存区<br>④ <code>_M</code>：右侧的 M，已被跟踪的文件，修改过，但还未加到暂存区<br>⑤ <code>MM</code>：已被跟踪的文件，修改过并且已加到暂存区，但之后又修改了<br>⑥ <code>AM</code>：新添加的文件，已加到暂存区，但之后又修改了</p>
<p>正常格式 vs 简短格式：</p>
<img src="/2018/12/21/pro-git-summary-1/git-status.PNG" class="" title="git-status">

<h3 id="正常格式显示状态时，有-3-大类情况"><a href="#正常格式显示状态时，有-3-大类情况" class="headerlink" title="正常格式显示状态时，有 3 大类情况"></a>正常格式显示状态时，有 3 大类情况</h3><p>① Changes to be committed：已暂存正等待提交的（即已跟踪，已暂存，等待提交的）<br>② Changes not staged for commit：已跟踪，但未暂存的（这种情况不会提交）<br>③ Untracked files：未跟踪的文件（可以是新建的文件，或把已跟踪的文件设为未跟踪，这种情况不会提交）</p>
<p>注意：<br>1、一个文件可以同时处于 情况① 与 情况② 下面。<br>2、一个文件的三大类情况组合起来的所有情况就是简短格式的6种情况。</p>
<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>如果需要忽略一些文件，不想加入 Git 的管理，比如编译程序产生的一些中间文件，就没必要提交到 Git。可以创建 <code>.gitignore</code> 文件排除这些文件。Git 仓库创建之初，就创建一个 .gitignore 文件是个很好的习惯。</p>
<p>文件 <code>.gitignore</code> 的格式：<br>1、以 <code>#</code> 开头都是注释<br>2、可以使用通配符 <code>*</code>, <code>?</code>, <code>[]</code>, <code>**</code><br>3、以 <code>/</code> 开头防止递归<br>4、以 <code>/</code> 结尾用于指定目录<br>5、以 <code>!</code> 开头指定例外文件或目录，即强制不被忽略的文件或目录</p>
<p>看看 .gitignore 文件的实际例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># * 匹配零个或多个任意字符</span></span><br><span class="line"><span class="comment"># 即以 ~ 结尾的文件都被忽略</span></span><br><span class="line"><span class="comment"># 默认会递归地排除仓库目录内所有子孙目录内的文件</span></span><br><span class="line">*~</span><br><span class="line"></span><br><span class="line"><span class="comment"># [oa] 匹配字符 o 或者字符 a</span></span><br><span class="line"><span class="comment"># 即 *.o 或 *.a 文件都被忽略</span></span><br><span class="line">*.[oa]</span><br><span class="line"></span><br><span class="line"><span class="comment"># no .a files</span></span><br><span class="line">*.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># but do track lib.a, even though you're ignoring .a files above</span></span><br><span class="line"><span class="comment"># 添加例外，上面规则排除了 *.a，但 lib.a 不会被排除</span></span><br><span class="line">!lib.a</span><br><span class="line"></span><br><span class="line"><span class="comment"># only ignore the TODO file in the current directory, not subdir/TODO</span></span><br><span class="line"><span class="comment"># 仅排除直接子目录下的 TODO 文件，不递归子孙目录</span></span><br><span class="line">/TODO</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all files in the build/ directory</span></span><br><span class="line"><span class="comment"># 这个目录是仓库目录内的直接子目录，这个目录被排除，则这个目录内的全部内容也就被排除了</span></span><br><span class="line">build/</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore doc/notes.txt, but not doc/server/arch.txt</span></span><br><span class="line">doc/*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># ignore all .pdf files in the doc/ directory</span></span><br><span class="line"><span class="comment"># ** 表示任意中间目录，包括空字符串</span></span><br><span class="line"><span class="comment"># 比如 a/**/z 可以匹配 a/z, a/b/z 或 a/b/c/z 等文件</span></span><br><span class="line">doc/**/*.pdf</span><br></pre></td></tr></table></figure>

<h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看未暂存的文件修改的部分</span></span><br><span class="line"><span class="comment"># 此命令比较当前未暂存文件和暂存区域快照之间的差异</span></span><br><span class="line"><span class="comment"># 注意 diff 命令都是以 "行" 作为文件修改的最小单位</span></span><br><span class="line">git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前已暂存文件与已提交文件之间的差异</span></span><br><span class="line">git diff --cached</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他差异比较工具</span></span><br><span class="line">git difftool</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统支持的 diff 工具</span></span><br><span class="line">git difftool --tool-help</span><br></pre></td></tr></table></figure>

<h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意提交之前先把未暂存的文件暂存起来</span></span><br><span class="line"><span class="comment"># git add &lt;file&gt;</span></span><br><span class="line"><span class="comment"># 然后看看当前的文件状态</span></span><br><span class="line"><span class="comment"># git status</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式提交</span></span><br><span class="line"><span class="comment"># 这种方式会启动文本编辑器以便输入本次提交的说明</span></span><br><span class="line"><span class="comment"># 执行 git config --global core.editor &lt;editor&gt; 设定文本编辑器</span></span><br><span class="line">git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接命令行提交</span></span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面的提交命令会提交所有已暂存但未提交的文件</span></span><br><span class="line"><span class="comment"># 也可以提交指定的文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意提交指定文件会跳过 git add 步骤</span></span><br><span class="line"><span class="comment"># 比如 README 是已跟踪但未提交的文件，就会把 README 文件也一并提交</span></span><br><span class="line">git commit -m <span class="string">"message"</span> COPYING README</span><br></pre></td></tr></table></figure>

<h2 id="跳过暂存步骤直接提交"><a href="#跳过暂存步骤直接提交" class="headerlink" title="跳过暂存步骤直接提交"></a>跳过暂存步骤直接提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -a 选项告诉 commit 命令自动把已跟踪过的文件暂存起来一并提交，从而跳过 git add 步骤</span></span><br><span class="line">git commit -a -m <span class="string">'message'</span></span><br></pre></td></tr></table></figure>

<h2 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h2><p>① 移除并删除：<br>移出暂存区域，并从当前仓库目录中删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移除已暂存的文件，并从仓库目录中删除此文件，此文件就不会出现在未跟踪列表里了</span></span><br><span class="line">git rm README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果移除已暂存并且之后又修改过的文件，需要用 -f 强制删除</span></span><br><span class="line"><span class="comment"># 这样强制删除的数据不能被 Git 恢复，因为修改的部分没有提交，所以不建议这样做！</span></span><br><span class="line">git rm -f README.md</span><br></pre></td></tr></table></figure>

<p>② 仅移除：<br>仅仅移出暂存区域，但不删除文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 仅仅移出暂存区域，让文件变成未跟踪状态，但文件还留在当前工作目录中</span></span><br><span class="line">git rm --cached package.json</span><br></pre></td></tr></table></figure>

<p>③ 使用通配符：<br>注意 Git 有自己的模式扩展匹配方式，为了防止 shell 干扰，用反斜杠转义或用单引号括起来。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除 log 目录下的所有 *.log 文件（递归地删除 log 目录内所有子孙目录内的 *.log）</span></span><br><span class="line">git rm <span class="string">'log/*.log'</span></span><br></pre></td></tr></table></figure>

<h2 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h2><p>不像其它的 VCS 系统，Git 并不显式跟踪文件移动操作。所以，应该用 Git 的移动命令 <code>git mv</code>。与 <code>git rm</code> 一样，<code>git mv</code> 只能操作（重命名）已暂存的文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动已暂存的文件，实际上是重命名</span></span><br><span class="line">git mv COPYING COPYING1</span><br></pre></td></tr></table></figure>

<p>执行 <code>git mv</code> 等价于执行如下三个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv COPYING COPYING1</span><br><span class="line">git rm COPYING</span><br><span class="line">git add COPYING1</span><br></pre></td></tr></table></figure>

<p>你可能会奇怪，Git 是怎么知道文件被移动了，别忘了 Git 跟踪的是文件内容的哈希，不是简单的文件名，而且 Git 的工作原理更像是小型的文件系统。</p>
<h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>命令 <code>git log</code> 用于查看提交历史，接下来的例子用 simplegit-progit 项目演示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆演示仓库</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看历史，不加任何选项的话，会列出项目的所有提交，最新的在最前面</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line">commit a11bef06a3f659402fe7563abf99ad00de2209e6</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure>

<p>命令 <code>git log</code> 有许多选项定制输出的内容，比如：<br>① <code>git log -p 2</code> 显示每次提交的内容差异（选项 <code>-p</code> 即 <code>--patch</code>），且仅仅显示最近两次提交<br>② <code>git log --stat</code> 显示每次提交的简略统计信息，比如几个文件被修改等等<br>③ <code>git log --pretty=OPT</code> 定制输出格式，OPT 可以是 <code>oneline</code>, <code>short</code>, <code>format</code> 等，详见 <code>git help log</code> 选项 <code>--pretty</code></p>
<p>定制输出格式举例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span> -1</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line"> Rakefile | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">"%h - %an, %ar : %s"</span></span><br><span class="line">ca82a6d - Scott Chacon, 11 years ago : changed the verison number</span><br><span class="line">085bb3b - Scott Chacon, 11 years ago : removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef0 - Scott Chacon, 11 years ago : first commit</span><br></pre></td></tr></table></figure>

<p>选项 <code>--pretty=formt</code> 常用格式占位符如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; <code>Table 1. git log --pretty=format 常用的选项</code></p>
<p>命令 <code>git log</code> 常用选项如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; Table 2. git log 的常用选项</p>
<h3 id="限制输出长度"><a href="#限制输出长度" class="headerlink" title="限制输出长度"></a>限制输出长度</h3><p>之前你已经看到过 -2 了，它只显示最近的两条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。</p>
<p>使用 <code>--since</code> ( <code>--after</code> ) 和 <code>--until</code> ( <code>--before</code> ) 选项，基于时间来限制输出长度，查看提交内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示最近的 2条 提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -2</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示指定时间之后的提交</span></span><br><span class="line"><span class="comment"># --since= 后的时间格式可以是 "2008-01-15", "2 years 2 days 1 minute ago" 等等</span></span><br><span class="line">$ git <span class="built_in">log</span> --since=<span class="string">"2008-03-17"</span></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Sat Mar 15 16:40:33 2008 -0700</span><br><span class="line"></span><br><span class="line">    removed unnecessary <span class="built_in">test</span> code</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匹配提交说明中有 version 关键字的所有提交</span></span><br><span class="line">git <span class="built_in">log</span> --grep=<span class="string">'version'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只查看特定目录或文件的历史提交</span></span><br><span class="line"><span class="comment"># 特定目录或文件名放在最后，并用 -- 隔开</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定文件的提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">'%h - %cd'</span> -- README</span><br><span class="line">a11bef0 - Sat Mar 15 10:31:28 2008 -0700</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定目录的提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=format:<span class="string">'%h - %cd'</span> -- lib/</span><br><span class="line">085bb3b - Fri Apr 17 21:55:53 2009 -0700</span><br><span class="line">a11bef0 - Sat Mar 15 10:31:28 2008 -0700</span><br></pre></td></tr></table></figure>

<p>命令 <code>git log</code> 的限制输出的常用选项如下表：</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%9F%A5%E7%9C%8B%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2" target="_blank" rel="noopener">这里</a> –&gt; Table 3. 限制 git log 输出的选项</p>
<h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>在任何一个阶段，你都有可能想要撤消某些操作。有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这个命令会把暂存区中的文件提交</span></span><br><span class="line"><span class="comment"># 如果这次提交与上次提交之间没有修改过文件，那么快照保持不变，仅仅是最后一次提交的提交说明发生变化</span></span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>如果提交后，忘记暂存修改过的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 运行如下命令提交</span></span><br><span class="line"><span class="comment"># 最终只会有一个提交，第二次提交将代替第一次提交的结果</span></span><br><span class="line">git commit -m <span class="string">'initial commit'</span></span><br><span class="line">git add another_file</span><br><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<h3 id="取消暂存的文件"><a href="#取消暂存的文件" class="headerlink" title="取消暂存的文件"></a>取消暂存的文件</h3><p>如果不小心暂存了不需要的文件。应该如何取消暂存呢。使用命令 <code>git reset</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改文件并且暂存，然后查看当前文件状态</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'My Project'</span> &gt; README</span><br><span class="line">$ git add README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看状态中已经有提示如何移除暂存状态了</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移出暂存状态</span></span><br><span class="line">$ git reset HEAD README</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M    README</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看状态</span></span><br><span class="line"><span class="comment"># 状态中给出了如何添加文件到暂存，以及如何撤销对文件的修改</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   README</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">"git add"</span> and/or <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>

<h3 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h3><p>如果不想保留对文件的修改，如何撤销呢。使用 <code>git checkout</code> 命令。</p>
<p>但是，注意，撤销操作是对已暂存（或者是对已提交，反正最低要求是已暂存）的文件而言的。如果文件已经暂存，之后又修改了，这个修改才可以被撤销。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文件内容</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件状态为已暂存</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">'NEW LINE'</span> &gt;&gt; NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的文件内容</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line">NEW LINE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改后的文件状态</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">"git add &lt;file&gt;..."</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">"git checkout -- &lt;file&gt;..."</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">    modified:   NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销对已暂存文件的修改</span></span><br><span class="line">$ git checkout -- NEWFILE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销后文件内容恢复原样</span></span><br><span class="line">$ cat NEWFILE</span><br><span class="line">New File</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销后文件状态恢复原样</span></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">'origin/master'</span>.</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">"git reset HEAD &lt;file&gt;..."</span> to unstage)</span><br><span class="line"></span><br><span class="line">    new file:   NEWFILE</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>命令 <code>git checkout -- &lt;file&gt;</code> 很危险。撤销后，你对那个文件的任何修改都会消失，Git 会拷贝另个文件来覆盖它。除非你十分清楚想要撤销的是什么，否则不要使用这个命令！</p>
<p>最后，如果你仍然想保留对那个文件做出的修改，但是现在仍然需要撤消，我们将会在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 介绍保存进度与分支，这些通常是更好的做法。</p>
<h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>远程仓库是指托管在因特网或其他网络中的你的项目的版本库。你可以有好几个远程仓库，通常有些仓库对你只读，有些则可以读写。与他人协作涉及管理远程仓库以及根据需要推送或拉取数据。</p>
<h3 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h3><p>如果想查看你已经配置的远程仓库服务器，可以运行 <code>git remote</code> 命令。它会列出你指定的每一个远程服务器的简写。如果你已经克隆了自己的仓库，那么至少应该能看到 <code>origin</code>，这是 Git 给你克隆的仓库服务器的默认名字：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 克隆远程仓库</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/schacon/ticgit</span><br><span class="line">Cloning into <span class="string">'ticgit'</span>...</span><br><span class="line">remote: Enumerating objects: 1857, <span class="keyword">done</span>.</span><br><span class="line">remote: Total 1857 (delta 0), reused 0 (delta 0), pack-reused 1857</span><br><span class="line">Receiving objects: 100% (1857/1857), 334.04 KiB | 242.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (837/837), <span class="keyword">done</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看远程仓库</span></span><br><span class="line">$ <span class="built_in">cd</span> ticgit/</span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 -v 选项会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL</span></span><br><span class="line"><span class="comment"># 如果远程仓库不止一个，该命令会把他们全部列出来</span></span><br><span class="line"><span class="comment"># 这里的意思是 ticgit 仓库可以关联到多个远程 Git 仓库，这样就方便多人协作</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br></pre></td></tr></table></figure>

<h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><p>运行命令 <code>git remote add &lt;shortname&gt; &lt;url&gt;</code> 添加一个新的远程 Git 仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 还是以上面的 ticgit 仓库为例，进入 ticgit 目录，执行</span></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面 pb 是远程服务器的简写，后面是服务器 URL</span></span><br><span class="line">$ git remote add pb https://github.com/paulboone/ticgit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/schacon/ticgit (fetch)</span><br><span class="line">origin  https://github.com/schacon/ticgit (push)</span><br><span class="line">pb  https://github.com/paulboone/ticgit (fetch)</span><br><span class="line">pb  https://github.com/paulboone/ticgit (push)</span><br></pre></td></tr></table></figure>

<p>拉取新添加的远程仓库的内容，可以使用服务器简写 <code>pb</code> 代替 URL：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拉取后，paulboone 的 master 分支就能在本地通过 pb/master 访问</span></span><br><span class="line"><span class="comment"># 注意这里的 pb/master 代表分支，不是本地的 pb/master 目录</span></span><br><span class="line">$ git fetch pb</span><br><span class="line">remote: Enumerating objects: 22, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (22/22), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 43 (delta 22), reused 22 (delta 22), pack-reused 21</span><br><span class="line">Unpacking objects: 100% (43/43), <span class="keyword">done</span>.</span><br><span class="line">From https://github.com/paulboone/ticgit</span><br><span class="line"> * [new branch]      master     -&gt; pb/master</span><br><span class="line"> * [new branch]      ticgit     -&gt; pb/ticgit</span><br></pre></td></tr></table></figure>

<p>关于分支的内容，将在 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 中详细介绍。</p>
<h3 id="从远程仓库中抓取与拉取"><a href="#从远程仓库中抓取与拉取" class="headerlink" title="从远程仓库中抓取与拉取"></a>从远程仓库中抓取与拉取</h3><p>如上文所示，从远程仓库获取数据，执行命令 <code>git fetch [remote-name]</code>。</p>
<p>这个命令会访问远程仓库，从中拉取所有 <em>你还没有的</em> 数据。执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。</p>
<p>如果你使用 <code>clone</code> 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。所以，<code>git fetch origin</code> 会抓取克隆（或上一次抓取）后新推送的所有工作。必须注意 <code>git fetch</code> 命令会将数据拉取到你的本地仓库，但它并不会自动合并或修改你当前的工作。当准备好时你必须手动将其合并入你的工作。</p>
<p>如果你有一个分支设置为跟踪一个远程分支（阅读下一节与 <a href="https://git-scm.com/book/zh/v2/ch00/ch03-git-branching" target="_blank" rel="noopener">Git 分支</a> 了解更多信息），可以使用 <code>git pull</code> 命令来自动地抓取然后合并远程分支到当前分支。这对你来说可能是一个更简单或更舒服的工作流程。默认情况下，<code>git clone</code> 命令会自动设置本地 <code>master</code> 分支跟踪克隆的远程仓库的 <code>master</code> 分支（或不管是什么名字的默认分支）。运行 <code>git pull</code> 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。</p>
<h3 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h3><p>推送命令 <code>git push [remote-name] [branch-name]</code>。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 比如你想要将 master 分支推送到 origin 服务器</span></span><br><span class="line"><span class="comment"># 再次说明，克隆时通常会自动帮你设置好那两个名字</span></span><br><span class="line"><span class="comment"># 即上文 git remote -v 命令显示的 origin 的 fetch 和 push</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。</p>
<h3 id="查看远程仓库的更多信息"><a href="#查看远程仓库的更多信息" class="headerlink" title="查看远程仓库的更多信息"></a>查看远程仓库的更多信息</h3><p>使用命令 <code>git remote show [remote-name]</code>。</p>
<p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8" target="_blank" rel="noopener">这里</a> –&gt; 查看远程仓库 小节 –&gt; 如果想要查看某一个远程仓库的更多信息 …</p>
<h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>使用命令 <code>git remote rename</code>。比如，想要把 <code>pb</code> 重命名为 <code>paul</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rename pb paul</span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br><span class="line">paul</span><br></pre></td></tr></table></figure>

<p>值得注意的是这同样也会修改你的远程分支名字。那些过去引用 pb/master 的现在会引用 paul/master。</p>
<p>使用命令 <code>git remote rm</code> 移除远程仓库。比如，你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote rm paul</span><br><span class="line"></span><br><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><p>像其他版本控制系统（VCS）一样，Git 可以给历史中的某一个提交打上标签，以示重要。比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这次以 libgit2 仓库为例</span></span><br><span class="line"><span class="built_in">cd</span> libgit2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列标签</span></span><br><span class="line"><span class="comment"># 这个命令以字母顺序列出标签，但是它们出现的顺序并不重要</span></span><br><span class="line">$ git tag</span><br><span class="line">v0.1.0</span><br><span class="line">v0.10.0</span><br><span class="line">v0.11.0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用特定模式查找标签</span></span><br><span class="line"><span class="comment"># 这个模式就是 shell 的通配符 *, ?, []</span></span><br><span class="line"><span class="comment"># 详见 git help tag 的 --list 选项</span></span><br><span class="line">$ git tag --list <span class="string">'v0.10*'</span></span><br><span class="line">v0.10.0</span><br></pre></td></tr></table></figure>

<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>Git 使用两种主要类型的标签：轻量标签（lightweight）与附注标签（annotated）。</p>
<p>轻量标签很像一个不会改变的分支，它只是一个特定提交的引用。</p>
<p>附注标签是存储在 Git 数据库中的一个完整对象。它们是可以被校验的，其中包含打标签者的名字、电子邮件地址、日期时间；还有一个标签信息（即标签说明，跟提交说明一个道理）；并且可以使用 <code>GnuPG</code> (GPG) 签名与验证。通常建议创建附注标签，这样你可以拥有以上所有信息，但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<h4 id="附注标签"><a href="#附注标签" class="headerlink" title="附注标签"></a>附注标签</h4><p>运行命令 <code>git tag -a</code> 创建附注标签。<code>-s</code> 和 <code>-u</code> 可以打 GPG 签名标签，详见 <code>git help tag</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这次还是以 simplegit-progit 仓库为例</span></span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/schacon/simplegit-progit</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> simplegit-progit/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加附注标签</span></span><br><span class="line"><span class="comment"># 默认是给最后一次提交加标签</span></span><br><span class="line"><span class="comment"># 选项 -m 与 git commit 的类似</span></span><br><span class="line">$ git tag -a v1.4 -m <span class="string">'my version 1.4'</span></span><br></pre></td></tr></table></figure>

<p>运行命令 <code>git show</code> 查看标签信息与对应的提交信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看标签详细信息</span></span><br><span class="line">$ git show v1.4</span><br><span class="line">tag v1.4</span><br><span class="line">Tagger: JasonZh &lt;jasonz666@qq.com&gt;</span><br><span class="line">Date:   Sun Dec 23 01:27:02 2018 +0800</span><br><span class="line"></span><br><span class="line">my version 1.4</span><br><span class="line"></span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   <span class="string">"simplegit"</span></span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br><span class="line">     s.email     =   <span class="string">"schacon@gmail.com"</span></span><br><span class="line">     s.summary   =   <span class="string">"A simple gem for using Git in Ruby code."</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认给最后一次提交打了附注标签</span></span><br><span class="line">$ git <span class="built_in">log</span> -1</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br></pre></td></tr></table></figure>

<h4 id="轻量标签"><a href="#轻量标签" class="headerlink" title="轻量标签"></a>轻量标签</h4><p>直接运行命令 <code>git tag &lt;tag-name&gt;</code> 而不加选项可以添加轻量标签。轻量标签本质上是将提交校验和存储到一个文件中，并没有保存任何其他信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打轻量标签</span></span><br><span class="line">$ git tag v1.4-lw</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这次的标签详情只是显示了提交信息</span></span><br><span class="line">$ git show v1.4-lw</span><br><span class="line">commit ca82a6dff817ec66f44342007202690a93763949</span><br><span class="line">Author: Scott Chacon &lt;schacon@gmail.com&gt;</span><br><span class="line">Date:   Mon Mar 17 21:52:11 2008 -0700</span><br><span class="line"></span><br><span class="line">    changed the verison number</span><br><span class="line"></span><br><span class="line">diff --git a/Rakefile b/Rakefile</span><br><span class="line">index a874b73..8f94139 100644</span><br><span class="line">--- a/Rakefile</span><br><span class="line">+++ b/Rakefile</span><br><span class="line">@@ -5,7 +5,7 @@ require <span class="string">'rake/gempackagetask'</span></span><br><span class="line"> spec = Gem::Specification.new <span class="keyword">do</span> |s|</span><br><span class="line">     s.platform  =   Gem::Platform::RUBY</span><br><span class="line">     s.name      =   <span class="string">"simplegit"</span></span><br><span class="line">-    s.version   =   <span class="string">"0.1.0"</span></span><br><span class="line">+    s.version   =   <span class="string">"0.1.1"</span></span><br><span class="line">     s.author    =   <span class="string">"Scott Chacon"</span></span><br><span class="line">     s.email     =   <span class="string">"schacon@gmail.com"</span></span><br><span class="line">     s.summary   =   <span class="string">"A simple gem for using Git in Ruby code."</span></span><br></pre></td></tr></table></figure>

<h4 id="后期打标签"><a href="#后期打标签" class="headerlink" title="后期打标签"></a>后期打标签</h4><p>运行命令 <code>git tag -a &lt;tag-name&gt; &lt;commit-hash&gt;</code>。其中，<code>&lt;commit-hash&gt;</code> 表示提交的校验和（或部分校验和）。</p>
<p>也就是给指定的提交打标签。比如，之前的一个提交忘记打标签了，就属于这种情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看提交</span></span><br><span class="line">$ git <span class="built_in">log</span> --pretty=oneline</span><br><span class="line">ca82a6dff817ec66f44342007202690a93763949 changed the verison number</span><br><span class="line">085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary <span class="built_in">test</span> code</span><br><span class="line">a11bef06a3f659402fe7563abf99ad00de2209e6 first commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 给第二个提交打标签</span></span><br><span class="line">$ git tag -a v1.2 085bb3b -m <span class="string">"my version 1.2"</span></span><br></pre></td></tr></table></figure>

<h4 id="共享标签"><a href="#共享标签" class="headerlink" title="共享标签"></a>共享标签</h4><p>运行命令 <code>git push origin [tagname]</code> 或命令 <code>git push origin --tags</code>。</p>
<p>默认情况下，<code>git push</code> 命令并不会传送标签到远程仓库服务器上。在创建完标签后你必须显式地推送标签到共享服务器上。这个过程就像共享远程分支一样。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.5</span><br><span class="line">Counting objects: 14, <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 8 threads.</span><br><span class="line">Compressing objects: 100% (12/12), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (14/14), 2.05 KiB | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 14 (delta 3), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.5 -&gt; v1.5</span><br></pre></td></tr></table></figure>

<p>推送多个标签。这将会把所有不在远程仓库服务器上的标签全部传送到那里。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Counting objects: 1, <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (1/1), 160 bytes | 0 bytes/s, <span class="keyword">done</span>.</span><br><span class="line">Total 1 (delta 0), reused 0 (delta 0)</span><br><span class="line">To git@github.com:schacon/simplegit.git</span><br><span class="line"> * [new tag]         v1.4 -&gt; v1.4</span><br><span class="line"> * [new tag]         v1.4-lw -&gt; v1.4-lw</span><br></pre></td></tr></table></figure>

<h4 id="检出标签"><a href="#检出标签" class="headerlink" title="检出标签"></a>检出标签</h4><p>详见 <a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%89%93%E6%A0%87%E7%AD%BE" target="_blank" rel="noopener">这里</a> –&gt; 检出标签 –&gt; 在 Git 中你并不能真的检出一个标签 …</p>
<h2 id="Git-别名"><a href="#Git-别名" class="headerlink" title="Git 别名"></a>Git 别名</h2><p>使用命令 <code>git config</code> 可以为 Git 设置别名，避免每次都输入长长的命令。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.co checkout</span><br><span class="line">git config --global alias.br branch</span><br><span class="line">git config --global alias.ci commit</span><br><span class="line">git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p>这样，使用 <code>git commit</code> 时只需要输入 <code>git ci</code>。Git 的子命令可以设置别名，当然也可以把选项包括进来。比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.unstage <span class="string">'reset HEAD --'</span></span><br><span class="line">git config --global alias.last <span class="string">'log -1 HEAD'</span></span><br></pre></td></tr></table></figure>

<p>这样，运行 <code>git unstage fileA</code> 就能取消暂存 fileA 文件了。第二个命令设置了查看最后一次提交的别名。</p>
<p>其实 Git 只是简单地将别名替换为对应的命令。所以为了方便，还可以把外部命令绑定成 <code>git &lt;command&gt;</code> 的形式，只需要在命令前加 <code>!</code>号。比如把 <code>git ls</code> 定义成 <code>ls -a</code> 的别名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global alias.ls <span class="string">'!ls -a'</span></span><br></pre></td></tr></table></figure>

<p>(完毕)</p>
]]></content>
      <tags>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title>UEFI 启动：实际工作原理</title>
    <url>/2019/01/02/uefi-boot-principle.html</url>
    <content><![CDATA[<p>原文：<a href="https://www.cnblogs.com/mahocon/p/5691348.html" target="_blank" rel="noopener">https://www.cnblogs.com/mahocon/p/5691348.html</a><br>本文翻译自：<a href="https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/" target="_blank" rel="noopener">https://www.happyassassin.net/2014/01/25/uefi-boot-how-does-that-actually-work-then/</a></p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p>首先，我们了解一些术语。BIOS 和 UEFI 都是计算机的 <code>固件</code> 类型。BIOS 固件（主要）用于 IBM PC 兼容计算机。UEFI 的通用性更强，可用在非“IBM PC 兼容”系列的计算机上。</p>
<p>不存在“UEFI BIOS”。没有任何一台计算机会有“UEFI BIOS”。BIOS 不是所有 PC 固件的通用术语，它只是 PC 固件的一种特定类型。计算机中包含固件。如果你有一台 IBM PC 兼容计算机，那么固件几乎肯定就是 BIOS 或 UEFI。如果你运行的是 <code>Coreboot</code>，那么恭喜，你是个例外，引以为傲吧。</p>
<p>安全启动 (Secure Boot) 与 UEFI 不是同一个概念。请不要将这些术语混淆使用。安全启动 (Secure Boot) 实际上是 UEFI 规范的一项可选功能，于 UEFI 规范版本 2.2 引入。我们稍后会详细讨论安全启动 (Secure Boot) 到底是什么，但是目前而言，只需要记住它和 UEFI 不同即可。</p>
<p>UEFI 不是由微软开发的，也从来不受微软控制。它的前身和基础——EFI，是由 Intel 开发和发布的。UEFI 由 UEFI 论坛 进行管理。微软是 UEFI 论坛的成员之一。</p>
<a id="more"></a>

<h2 id="UEFI-启动：背景"><a href="#UEFI-启动：背景" class="headerlink" title="UEFI 启动：背景"></a>UEFI 启动：背景</h2><p>我们现在来看看 UEFI 计算机上的启动原理。即使未掌握本文的细节，也请记住这一点：UEFI 与 BIOS 完全不同。UEFI 启动原理与 BIOS 绝对不同。你不能把 BIOS 启动的原理直接套用到原生 UEFI 启动上。你不能把专为 BIOS 启动设计的工具应用到原生 UEFI 启动的系统上。</p>
<p>还需要了解一个重点：许多 UEFI 固件实现了某种 BIOS 兼容模式（有时候称为 <code>CSM</code>）。许多 UEFI 固件可以像 BIOS 固件一样启动系统，它们可以查找磁盘上的 MBR，然后从 MBR 中执行启动装载程序，接着将后续工作完全交给启动装载程序。有时候，其他人误将此功能称为“禁用 UEFI”，从语言学角度而言，这种说法是荒谬的。他们讨论的是通过 UEFI 固件的一项功能，以“BIOS 风格”启动系统，而不是采用原生 UEFI 方式启动系统。</p>
<p>我想解释一下原生 UEFI 启动。如果你有一台基于 UEFI 的计算机，其固件具有 BIOS 兼容功能，并且你打算一直使用这项兼容功能，在启动过程中，你的计算机看起来就是基于 BIOS 的。你只需要像 BIOS 启动一样进行所需操作即可。如果你确实有此打算，那么就不要中途变卦。对于你日常使用的操作系统，<strong>强烈建议不要混合使用原生 UEFI 启动和 BIOS 兼容启动</strong>，尤其不要在同一块磁盘上混用。这么做的话，你会痛不欲生。如果你决定混合使用原生 UEFI 启动和 BIOS 兼容启动，到时候就别找我哭诉。</p>
<p>为了理清头绪，我将假设磁盘采用 GPT ，并且包含用于 EFI 的 <code>FAT32 EFI 系统分区(ESP)</code>。根据你对这些知识的深入程度，你可能发现，在进行原生 UEFI 启动时，GPT 磁盘和 EFI FAT32 ESP 并不是必要条件。但是 UEFI 规范和 GPT 磁盘以及 <code>EFI FAT32 ESP</code> 的联系程度相当密切。在99%的情况下，你要处理的也正是这样的组合。除非你在使用 Mac（老实说，Mac 混乱不堪）。</p>
<h2 id="UEFI-原生启动：实际工作原理"><a href="#UEFI-原生启动：实际工作原理" class="headerlink" title="UEFI 原生启动：实际工作原理"></a>UEFI 原生启动：实际工作原理</h2><p>言归正传。本节将解释原生 UEFI 启动的实际工作原理。如果已掌握一定程度的背景知识，可能更容易深入理解本节内容。</p>
<p>在固件层，UEFI 的基础架构更丰富，可用于处理系统启动。UEFI 远不像 BIOS 那么简单。与 BIOS 不同，UEFI 确实可以（不同程度上）理解“磁盘分区”、“启动装载程序”以及“操作系统”的概念。你可以稍微看看 BIOS 启动过程，然后再看看 UEFI 启动过程，了解 UEFI 启动过程如何采用多种措施来解决特定问题。</p>
<p>在思考启动过程时，你会发现 BIOS/MBR 查找启动装载程序的方法实在不怎么样。BIOS/MBR 非常奇葩：位于磁盘起始位置的这一小段空间包含 <code>神奇代码 (magic code)</code>，而这段神奇代码只作用于系统固件和写入此神奇代码的工具。这种方法有许多问题。</p>
<ul>
<li><p>处理不便——你需要特殊工具来写入 MBR，如果要查看 MBR 中包含的内容，唯一的方法几乎就是把 MBR <code>dd</code> 出来，然后进行检查。</p>
</li>
<li><p>如上所述，MBR 本身不足以容纳许多现代启动装载程序。这些启动装载程序会将自身的一小部分安装在 MBR 中，而将其他部分安装到磁盘上的可用空间中。这段可用空间位于常规 MBR 末尾和第一个分区的起始位置之间。这就会造成很大的问题（其实这整个设计就是个大问题，不过无所谓）。对于第一个分区的起始位置，并没有成文的可靠规定，因此难以确保空间足够。只有一件事情是肯定的：这段空间不足以容纳某些启动装载程序的配置。</p>
</li>
<li><p>如果要选择其他启动目标（除磁盘以外），这种设计没有提供任何标准化层或标准化机制，但是用户希望选择除磁盘以外的启动目标。也就是说，他们希望实现多重可启动对象——通常是操作系统。在 BIOS/MBR 组合中，实现这种目的的唯一方法是由启动装载程序进行处理；至于如何实现，并没有进行获得广泛认可的规定。虽然实现的方法非常多，但是它们无法彼此协作，而且也都不是获得广泛认可的标准或规定。而在操作系统/操作系统安装层编写工具的难度很大，无法干净利落地处理多重启动。因此这种设计非常混乱。</p>
</li>
<li><p>这种设计没有提供标准方法，让用户可以从除磁盘以外的目标进行启动。本文不会就此问题进行详细讨论，但是请注意，UEFI 启动的另一优势为：它提供了进行启动（例如，从远程服务器进行启动）的标准方法。</p>
</li>
<li><p>固件层以上的其他层无法配置固件的启动行为，BIOS 没有提供相应机制。</p>
</li>
</ul>
<p>可以想象，在 UEFI 设计之初，开发人员思考过这些问题，并最终提出解决方案。UEFI 固件并不仅仅可以识别磁盘，它也知道启动装载程序代码在每个磁盘上所处的位置，而且在固件层，UEFI 的基础架构更丰富，可用于处理启动装载。接下来，我们讨论下 UEFI 规范中定义的相关内容。</p>
<h2 id="EFI-可执行文件"><a href="#EFI-可执行文件" class="headerlink" title="EFI 可执行文件"></a>EFI 可执行文件</h2><p>UEFI 规范定义了一种可执行文件格式，并要求所有 UEFI 固件能够执行此格式的代码。当开发人员为原生 UEFI 编写启动装载程序时，就必须按照这种格式编写。这种设计非常简洁直观，也无需进一步解释：对于固件可以执行的代码，固件规范真正定义了其通用格式，这是件好事。</p>
<h2 id="GPT（GUID-分区表）格式"><a href="#GPT（GUID-分区表）格式" class="headerlink" title="GPT（GUID 分区表）格式"></a>GPT（GUID 分区表）格式</h2><p>GUID 分区表格式与 UEFI 规范具有密切联系，而且，它并不特别复杂，无需多加解释。GPT 是 UEFI 规范提供的良好基础架构之一。GPT 仅仅是分区表的一种标准——磁盘起始位置的信息定义了磁盘所包含的分区。相比 MBR/MS-DOS 分区表，这种分区表对分区的定义要好得多，并且 UEFI 规范要求 UEFI 兼容固件必须能识别 GPT（也要求固件能识别 MBR，以保证向后兼容）。所有这些规范都是相当实用的基础架构：UEFI 规范正建立某些功能，固件层上的一切都可依靠固件本身来实现这些功能。</p>
<h2 id="EFI-系统分区"><a href="#EFI-系统分区" class="headerlink" title="EFI 系统分区"></a>EFI 系统分区</h2><p>在修订本文时，我才真正思考 EFI 系统分区的概念，让我有如醍醐灌顶。实际上，“EFI 系统分区”的概念可以解决“奇葩”的 MBR 空间所产生的问题。在磁盘起始位置留出自由空间，用于存放启动装载程序代码，但又不定义其容量，这种设计糟糕透顶。这一点在上文已经讨论过了。EFI 系统分区是 UEFI 用于解决这种问题的解决方案。</p>
<p>具体的解决方案如下：我们要求固件层能够读取某些特定的文件系统类型。UEFI 规范要求兼容固件必须能读取 FAT 格式的变种（包括 <code>FAT12</code>、<code>FAT16</code> 和 <code>FAT32</code>）。UEFI 规范实际扮演的角色就是编纂整理 FAT 文件系统格式的现有解释，确保在采用 UEFI 时可以使用那些格式，并规定 UEFI 兼容固件必须能够读取那些格式。UEFI 规范针对这方面的具体规定如下：</p>
<p>可扩展固件接口 (EFI) 支持的文件系统基于 FAT 文件系统。EFI 定义了可以明确记录和测试的具体 FAT 版本。FAT 的唯一定义必须符合 EFI 规范及关联参考文档，对 FAT 唯一定义的实现必须支持 EFI。为区分 EFI 文件系统与纯 FAT，定义了新的分区文件系统类型。</p>
<p>EFI 系统分区 是采用 FAT 变种（UEFI 规范定义的变种之一）格式化的任意分区，该分区被赋予特定 GPT 分区类型，以帮助固件识别该分区。此分区的目的如上所述：固件层确实可以读取“普通”磁盘分区中的数据。希望我已明确解释为何这种设计更佳：操作系统可以创建、格式化和挂载分区（采用广泛理解的格式），并将启动装载程序的代码和固件可能需要读取的所有其他内容放到这个分区中，而不用像 MBR 磁盘一样，将启动装载程序的代码写入磁盘的起始位置空间。</p>
<p>刚开始的时候，对我而言，整个 ESP 的设计看起来有点匪夷所思且令人困惑，因此我希望本节可以解释为何 ESP 实际上是非常优秀的设计——真正匪夷所思和令人困惑的设计是 BIOS/MBR。若要从操作系统层写入某些内容，唯一的方法是将这些内容写入磁盘起始位置的某部分（但不知道是多少）空间，而并没有具体规定其中的具体实现。如果回过头再看，这种设计并不明智，且难以理解。</p>
<p>正如我们稍后会强调的那样，UEFI 规范试图采用更直观严格的方法——它很少禁止固件执行其他操作。UEFI 规范并不反对编写固件，用于执行以其他格式写成的代码、读取其他类型的分区表，以及读取用 UEFI 变种文件系统（非 FAT）格式化的分区。但是 UEFI 兼容固件必须至少能够实现执行 EFI 可执行文件、读取 GPT 分区表、以及读取 ESP，因此如果你正编写操作系统或其他东西，并且想要在 UEFI 兼容固件上运行的话，你也得遵循 UEFI 规范，这就是 EFI 系统分区的概念非常重要的原因：它允许（至少理论上）将 EFI 可执行文件放在以 UEFI FAT 格式化且 GPT 分区类型正确无误的分区上，另外，系统固件要能够读取该分区。这种机制非常严谨，等价于 BIOS 中的“固件能够执行放置在 MBR 空间中的启动装载程序代码”。</p>
<p>UEFI 规范为我们提供了三大重要基础，这些重要基础是上层架构正常运行的立足之本：</p>
<ul>
<li><p>读取分区表</p>
</li>
<li><p>访问某些特定文件系统中的文件</p>
</li>
<li><p>执行特定格式的代码</p>
</li>
</ul>
<p>相比 BIOS 固件所提供的功能，UEFI 的功能要丰富得多。但是，为了完成固件层可以处理多重目标（而不仅仅是磁盘）启动的愿景，我们需要其他基础：需要建立一种机制，通过这种机制，固件可以查找各种可能的启动目标，并提供相应的配置方法。</p>
<h2 id="UEFI-启动管理器"><a href="#UEFI-启动管理器" class="headerlink" title="UEFI 启动管理器"></a>UEFI 启动管理器</h2><p>UEFI 规范定义了名为 UEFI 启动管理器的一项功能（Linux 发行版包含名为 <code>efibootmgr</code> 的工具，可用于更改 UEFI 启动管理器的配置）。如果你确实阅读过 UEFI 规范，那么就会发现，UEFI 规范对 UEFI 启动管理器作出了如下规定：</p>
<p>UEFI 启动管理器是一种固件策略引擎，可通过修改固件架构中定义的全局 NVRAM 变量来进行配置。启动管理器将尝试按全局 NVRAM 变量定义的顺序依次加载 UEFI 驱动和 UEFI 应用程序（包括 UEFI 操作系统启动装载程序）。</p>
<p>好，既然已经明确了这一概念，那我们就继续吧。不，先等等。我来先把那一项规定解释清楚，便于理解。<strong>简单来说，你可以把 UEFI 启动管理器视为启动菜单</strong>。在 BIOS 固件上，固件层的“启动菜单”（当然）是，启动时连接到计算机的各个磁盘——不多不少。但是对于 UEFI 固件而言，情况有所不同。</p>
<p>UEFI 启动管理器可以进行配置——简言之，你可以向“启动菜单”添加项或者从中删除项。固件也可以（事实上， UEFI 规范也有此要求）根据连接到计算机的磁盘或根据某些固件配置，在此启动菜单中“生成”有效项。你也可以检查启动菜单，确保正确无误。</p>
<p>UEFI 提供了一种非常优秀的机制，可以从上层架构执行此操作：你可以从已启动的操作系统中配置系统启动行为。如果已通过 UEFI 启动 Linux，就可以使用 <code>efibootmgr</code> 工具来完成所有这些操作。Windows 也有相应的工具，但是我对 Windows 下的工具非常不熟悉。我们不妨看一些典型的 efibootmgr 输出，这些是我从 Fedora 论坛转过来的，稍微进行了调整：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@system directory]<span class="comment"># efibootmgr -v</span></span><br><span class="line">BootCurrent: 0002</span><br><span class="line">Timeout: 3 seconds</span><br><span class="line">BootOrder: 0003,0002,0000,0004</span><br><span class="line">Boot0000* CD/DVD Drive BIOS(3,0,00)</span><br><span class="line">Boot0001* Hard Drive HD(2,0,00)</span><br><span class="line">Boot0002* Fedora HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\EFI\fedora\grubx64.efi)</span><br><span class="line">Boot0003* opensuse HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d)File(\EFI\opensuse\grubx64.efi)</span><br><span class="line">Boot0004* Hard Drive BIOS(2,0,00)P0: ST1500DM003-9YN16G .</span><br><span class="line">[root@system directory]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>这个示例非常清晰。我们可以从中观察细节。</p>
<p>第一行表示，目前你从“启动菜单”的哪个项进行了启动。第二行非常明显（如果固件的 UEFI 启动管理器显示了类似启动菜单的界面，那么这一行表示继续启动默认项之前的超时）。BootOrder 是列表中启动项的尝试顺序。其余输出显示了实际的启动项。我们稍后会说明每一个启动项具体作用。</p>
<p>如果完全正常启动 UEFI 固件，而不进行任何调整（我们稍后会讨论），UEFI 固件将按照BootOrder 中列出的顺序，尝试从“启动菜单”中的每个“项”进行启动。因此，在这台计算机上，UEFI 固件将尝试启动名为“opensuse”的项，如果启动失败，然后再尝试启动名为“Fedora”的项，然后再是“CD/DVD Drive”，接着是第二项“Hard Drive”。</p>
<h2 id="UEFI原生启动：启动管理器项"><a href="#UEFI原生启动：启动管理器项" class="headerlink" title="UEFI原生启动：启动管理器项"></a>UEFI原生启动：启动管理器项</h2><p>那么，这些项的实际含义是什么？实际上，UEFI 规范之所以显得复杂，很大程度上是因为其中的不确定因素太多。如果你正在阅读 UEFI 规范，那么先做好心理准备，然后前往 EFI_DEVICE_PATH_PROTOCOL 一节。但是请注意，这个协议是通用的，虽然这个协议不涉及启动过程，但是有其他作用——这实际上就是 UEFI 官方的设备标识方法，这种标识方法可用于启动管理器项以及各种其他用途。出于各种原因，并不是每一种潜在的 EFI 设备都像 UEFI 启动管理器项一样起作用（如果你想从视频适配器启动，很可能不会成功）。但是启动菜单中显然可以包含指向 PXE 服务器（而不是磁盘分区）的项。UEFI 规范进行了多项规定，可以向 UEFI 启动管理器配置中添加除磁盘以外的启动目标。</p>
<p>但是对我们而言，只需要考虑连接到计算机的一般磁盘即可。既然这样，我们来讨论下可能遇到的三种启动项类型。</p>
<h2 id="BIOS-兼容启动项"><a href="#BIOS-兼容启动项" class="headerlink" title="BIOS 兼容启动项"></a>BIOS 兼容启动项</h2><p>在本示例中，Boot0000 和 Boot0004 实际上是 BIOS 兼容模式启动项，而不是原生 UEFI 启动项。这些启动项不是通过外部工具添加到 UEFI 启动管理器配置中的，而是由固件本身生成的——这也是 UEFI 固件实现 BIOS 兼容启动的常见方式，通过生成 UEFI 启动管理器项，可触发指定设备的 BIOS 启动。至于 UEFI 启动管理器如何呈现给用户，这是另一个问题，我们稍后讨论。根据具体固件及其配置，其中有些项可能无法显示。每一项只会具有一个名称（“CD/DVD Drive”、“Hard Drive”），这表示“如果选中此项，那么就以 BIOS 兼容模式启动本磁盘”（其中，对于 Boot0000，“本磁盘”为 3,0,00，对于 Boot0004，“本磁盘”为 2,0,00）。</p>
<h2 id="回退路径-Fallback-path-UEFI-原生启动项"><a href="#回退路径-Fallback-path-UEFI-原生启动项" class="headerlink" title="回退路径 (Fallback path) UEFI 原生启动项"></a>回退路径 (Fallback path) UEFI 原生启动项</h2><p>Boot0001 项（我虚构的，实际操作中可能不存在，这里只是为了举例说明）用于通知固件尝试从特定磁盘启动（以 UEFI 模式而不是 BIOS 兼容模式），但是并没有向固件提供其他信息。它没有指定磁盘上的具体启动目标，而只是让固件启动磁盘。</p>
<p>UEFI 规范定义了一种“回退”路径 (Fallback path)，用于启动此类启动管理器项，其工作原理类似于 BIOS 驱动器启动：它会在标准位置查找某些启动装载程序代码。但是其中的细节和 BIOS 不同。</p>
<p>当尝试以这种方式启动时，固件真正执行的操作相当简单。固件会遍历磁盘上的每个 EFI 系统分区（按照磁盘上的分区顺序）。在 ESP 内，固件将查找位于特定位置的具有特定名称的文件。在 x86-64 PC 上，固件会查找文件 <code>\EFI\BOOT\BOOTx64.EFI</code>。固件实际查找的是 <code>\EFI\BOOT\BOOT{计算机类型简称}.EFI</code>，其中，“x64”是 x86-64 PC 的“计算机类型简称”。文件名还有可能是 <code>BOOTIA32.EFI</code> (x86-32)、<code>BOOTIA64.EFI</code> (Itanium)、<code>BOOTARM.EFI</code>（AArch32，即32位ARM）和 <code>BOOTAA64.EFI</code>（AArch64，即64位ARM）。然后，固件将执行找到的第一个有效文件（当然，文件需要符合UEFI规范中定义的可执行格式）。</p>
<p>这种机制的设计目的不在于启动日常使用的操作系统。它的设计目的更像是为了启动可热插拔、与设备无关的介质（如 Live 映像和操作系统介质）。这也是这种机制的常见用途。如果查看 Linux 或其他操作系统的 UEFI 兼容 Live 或安装介质，你会发现其中包含 GPT，以及位于（或靠近）设备起始位置的 FAT 分区，该分区的 GPT 分区类型标识为 EFI 系统分区。在那个分区中，会有一个 <code>\EFI\BOOT</code> 目录，目录中至少包含上述特殊命名的文件之一。当以原生 UEFI 模式启动 Fedora Live 或安装介质时，就会采用这种机制。BOOTx64.EFI（或其他）文件将处理剩余启动过程，从而启动介质上包含的真正操作系统。</p>
<h2 id="完全原生-UEFI-启动项"><a href="#完全原生-UEFI-启动项" class="headerlink" title="完全原生 UEFI 启动项"></a>完全原生 UEFI 启动项</h2><p>Boot0002 和 Boot0003 是存储设备上所安装操作系统的“典型”项。这些项显示了 UEFI 启动机制的全部优势，不仅仅是“从此磁盘启动”，而是“启动此特定磁盘上此特定位置中的这一特定启动装载程序”。</p>
<p>Boot0002 是由原生 UEFI Fedora 安装生成的启动项。Boot0003 是由原生 UEFI OpenSUSE安装生成的启动项。按照字面意思，这些启动项表示“从此分区加载这一文件”。分区指的是 HD(1,800,61800,6d98f360-cb3e-4727-8fed-5ce0c040365d) 这个东西：表示某一特定分区（使用 EFI_DEVICE_PATH_PROTOCOL，我不打算对此进行详细介绍。如果你通过固件界面和 efibootmgr 与启动管理器进行交互，你也不需要知道其中的细节）。文件指的是 (\EFI\opensuse\grubx64.efi) 这个东西：它仅表示“加载所述分区上此位置中的文件”。这里所指的分区基本上始终指的就是充当 EFI 系统分区的那个分区，因此：可以放心地让固件访问 EFI 系统分区。</p>
<p>UEFI 规范提供这一机制，以便操作系统可启动：操作系统将启动装载程序（作用为加载操作系统内核等）安装到 EFI 系统分区中，并使用某一名称（显然，这一名称通常来源于操作系统名称）以及启动装载程序（EFI 可执行格式，用于加载操作系统）的位置向 UEFI 启动管理器配置中添加启动项。</p>
<p>Linux 发行版使用 <code>efibootmgr</code> 工具处理 UEFI 启动管理器。进行原生 UEFI 安装时，有关启动装载方面，Linux 发行版实际进行的操作相当简单：它会创建一个 EFI 系统分区（如果不存在此分区），使用相应配置将 EFI 启动装载程序（通常为 <code>grub2-efi</code>，但是也有例外）安装到 EFI 系统分区中的正确路径下，然后调用 efibootmgr 添加相应的 UEFI 启动管理器项（指向其启动装载程序）。如果已存在 EFI 系统分区，大部分发行版会使用现有分区（尽管完全可以创建新的 EFI 系统分区并使用这个新分区）：我们已经提到过，UEFI 是一种宽松规范，只要在逻辑上遵循其设计，那么有多少个 EFI 系统分区都没问题。</p>
<h2 id="配置启动过程（固件-UI）"><a href="#配置启动过程（固件-UI）" class="headerlink" title="配置启动过程（固件 UI）"></a>配置启动过程（固件 UI）</h2><p>上文描述了 UEFI 规范定义的基本机制，用于管理 UEFI 启动过程。固件用户界面可能不会明确遵循这一机制，了解这一点非常重要。不幸的是，UEFI 规范有意未限制启动过程的呈现方式或用户配置启动过程的方式，这表示——由于我们也从事 固件工程——每个固件会有不同的实现方法，并且其中某些固件的实现方法较疯狂。</p>
<p>许多固件的启动配置界面较直观。优秀的固件设计至少会显示启动顺序以及其中的各个启动项，允许用户添加/删除项、更改启动顺序或在某次特定启动中忽略原有启动顺序（仅针对那次启动生效，或直接让固件启动特定菜单项，甚至可以选择让固件以 <code>BIOS 兼容模式</code> 或 <code>UEFI“回退 (Fallback)”模式</code> “启动这块磁盘”，我的固件就可以这么操作）。此类界面通常可以仅按名称显示完整的原生 UEFI 启动项（例如我们上文提到的 Fedora 和 OpenSUSE 示例）；你需要检查 efibootmgr -v 的输出，以详细了解在调用这些项时，它们具体会尝试并执行哪些操作。</p>
<p>某些固件会尝试对配置进行抽象和简化，最终结果良莠不齐。例如，如果可以选择“启用或禁用”BIOS 兼容模式，固件很有可能会为已连接驱动器的 UEFI 启动管理器配置添加或删除 BIOS 兼容项。如果可以选择“启用或禁用”原生 UEFI 启动，那么在用户“禁用”原生 UEFI 启动时，固件很有可能更改 UEFI 启动管理器配置，从 BootOrder 中删除所有原生UEFI启动项。</p>
<p>请谨记，固件界面中的所有配置选项所执行的操作就是在后台配置 UEFI 启动管理器的行为。如果你能理解以上所有内容，那么当你更改固件界面中的选项时，你会更容易理解其背后的本质。</p>
<p>在 BIOS 中，系统不会始终尝试优先从可移动驱动器（CD、USB）进行启动，然后再从驱动器启动。根据实际情况，结果可能有所不同。有些 BIOS 固件会优先尝试从 CD 启动，然后再尝试从硬盘启动（而不是 USB）。试图安装新的操作系统时，用户已习惯于时常检查 BIOS 配置，以确保启动顺序“正确无误”。</p>
<p>UEFI 也是如此，但是由于 UEFI 启动管理器机制的灵活性/复杂性，这一过程看起来可能显得陌生而可怕。</p>
<p>在系统尝试启动固定启动项之前，如果想要确保系统使用“回退(Fallback)”机制优先从可移动设备启动（例如，在安装 Fedora 时），需要将可移动设备作为固件的默认启动项，或需要相应设置固件。根据具体固件界面，可能发现每个连接的可移动设备都有对应的“菜单项”，你只需要调整启动顺序，把你想要的可移动设备放在首位即可，有时候你也会发现可以直接请求“对此特定磁盘进行 UEFI 恢复启动”，另外你还可能发现固件会尝试将配置进行抽象。我们不知道具体的固件界面是什么样，因此难以编写说明。但是既然你已了解背后的工作原理，那么就可能更容易理解固件用户界面配置的含义。</p>
<h2 id="配置启动过程（通过操作系统）"><a href="#配置启动过程（通过操作系统）" class="headerlink" title="配置启动过程（通过操作系统）"></a>配置启动过程（通过操作系统）</h2><p>如上所述，与 BIOS 机制不同，你可以从操作系统层面配置 UEFI 启动过程。如果你的固件比较令人恶心，你可能需要执行此操作才能达成目的。</p>
<p>你可以使用之前提过的 efibootmgr 工具来添加、删除和修改 UEFI 启动管理器配置中的项，这一工具也具有其他丰富功能。你可以更改启动顺序。你可以更改下次启动时的首要启动项，而不需要使用 BootOrder 列表（如果你或其他某些工具已经进行过配置，efibootmgr -v 的输出将包括 BootNext 项，说明下一次启动将加载的菜单项）。Windows 下也有类似的工具。因此如果你难以从固件界面配置 UEFI 启动，但是你可以启动某种原生 UEFI 操作系统，那么你可以考虑从操作系统（而不是固件 UI）进行启动配置。</p>
<h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ul>
<li><p>UEFI 固件包含某些非常类似于启动菜单的内容。</p>
</li>
<li><p>可以使用 <code>efibootmgr -v</code> 从任何原生 UEFI 启动的 Linux 操作系统中查询 UEFI 启动配置，也可以使用 efibootmgr 更改配置（有关详细信息，请参阅 man 页面）。</p>
</li>
<li><p>“启动菜单”可以包含表示“以 BIOS 兼容模式启动此磁盘”，“通过回退路径 (Fallback path) 以原生 UEFI 模式启动此磁盘”（将使用上文所述的“寻找 BOOT(某字符串).EFI”方式），或“启动此特定位置（几乎始终为 EFI 系统分区）中的特定 EFI 格式的可执行文件”等含义的项。</p>
</li>
<li><p>UEFI 规范尝试一种优秀、简洁的设计，让所有操作系统都将其自身的启动装载程序安装到 EFI 系统分区中，然后在“启动菜单”中添加指向这些启动装载程序的项，同时不得干涉其他目标的启动过程。</p>
</li>
<li><p>你的固件 UI 可以自由实现此机制，虽然具体的实现结果良莠不齐。</p>
</li>
</ul>
<h2 id="在-UEFI-计算机上安装操作系统"><a href="#在-UEFI-计算机上安装操作系统" class="headerlink" title="在 UEFI 计算机上安装操作系统"></a>在 UEFI 计算机上安装操作系统</h2><p>我们快速浏览下上文中与在 UEFI 计算机上安装操作系统相关的具体结果。</p>
<h3 id="原生-UEFI-启动和-BIOS-兼容启动"><a href="#原生-UEFI-启动和-BIOS-兼容启动" class="headerlink" title="原生 UEFI 启动和 BIOS 兼容启动"></a>原生 UEFI 启动和 BIOS 兼容启动</h3><p>用户有时会忽略以下事项：</p>
<ul>
<li><p>如果以“原生 UEFI”模式启动安装介质，安装介质将以原生 UEFI 模式安装操作系统：它将尝试向 EFI 系统分区写入 EFI 格式的启动装载程序，并尝试向 UEFI 启动管理器的“启动菜单”中添加启动项，用于启动该启动装载程序。</p>
</li>
<li><p>如果以“BIOS 兼容”模式启动安装介质，安装介质将以 BIOS 兼容模式安装操作系统：它将尝试向磁盘上的 MBR 空间写入 MBR 类型的启动装载程序。</p>
</li>
</ul>
<p>这适用于（现在暂时忽略其中的无关警告）我接触过的所有操作系统。因此你可能确实想了解，如何在固件层选择以原生 UEFI 模式启动可移动设备，以及如何在固件层选择以 BIOS 兼容模式启动可移动设备，确保在安装时可以随意选择需要使用的模式。</p>
<p>如果以 BIOS 兼容模式启动安装介质，那么你绝对无法成功进行操作系统的原生 UEFI 安装，因为安装程序无法配置 UEFI 启动管理器（除非以原生 UEFI 模式启动安装介质）。</p>
<p>理论上，在以原生 UEFI 模式启动之后，操作系统的安装程序可通过 BIOS 模式安装该操作系统，即，将启动装载程序写入磁盘 MBR，但是大部分安装程序无法执行此操作，这种做法比较可取。</p>
<h3 id="确定启动模式"><a href="#确定启动模式" class="headerlink" title="确定启动模式"></a>确定启动模式</h3><p>有时候，在启动操作系统安装程序之后，你不确定启动模式为原生 UEFI 模式还是 BIOS 兼容模式。别担心。有几种简单方法可以确定启动模式。最简单的方法之一是尝试读取 UEFI 启动管理器。如果你启动了 Linux 安装程序或环境，并且可以运行 shell（例如，在 Fedora 安装程序中是 Ctrl-Alt-F2），请运行 <code>efibootmgr -v</code>。如果你启动的是原生 UEFI 模式，那么就可以看到上文所示的 UEFI启动管理器配置。如果你启动的是 BIOS 兼容模式，那么会看到类似以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Fatal: Couldn<span class="string">'t open either sysfs or procfs directories for accessing EFI variables.</span></span><br><span class="line"><span class="string">Try '</span>modprobe efivars<span class="string">' as root.</span></span><br></pre></td></tr></table></figure>

<p>如果启动了其他操作系统，你可以尝试运行该操作系统的内置实用程序，读取 UEFI 启动管理器，并查看是否显示了明确输出或类似错误。或者你可以检查系统日志并搜索“efi”和/或“uefi”，从中可能发现蛛丝马迹。</p>
<h3 id="启用原生-UEFI-启动"><a href="#启用原生-UEFI-启动" class="headerlink" title="启用原生 UEFI 启动"></a>启用原生 UEFI 启动</h3><p>若要启用原生 UEFI 模式的启动，那么操作系统安装介质必须明确符合我们刚刚说明的所有规范：具有 GUID 分区表，和 EFI 系统分区，启动装载程序位于正确的“回退”路径 (Fallback path) 中——\EFI\BOOT\BOOTx64.EFI（其他平台可能会有其他名称）。如果无法以原生 UEFI 模式启动安装介质，并且无法查出原因，那么请检查安装介质是否满足上述条件。显然，当使用 livecd-iso-to-disk 工具将 Fedora 映像写入 USB 存储器时，你必须传递 <code>--efi</code> 参数，才能将存储器配置为可用 UEFI 模式启动。</p>
<h3 id="强制使用-BIOS-兼容启动"><a href="#强制使用-BIOS-兼容启动" class="headerlink" title="强制使用 BIOS 兼容启动"></a>强制使用 BIOS 兼容启动</h3><p>如果你的固件难以通过 BIOS 兼容模式从可移动介质启动，但是你又确实想通过这种方式启动，那么可以使用一些小把戏：完全禁用该介质的原生 UEFI 启动模式。可以通过清除所有 EFI 系统分区来轻松执行此操作（或者，如果使用 livecd-iso-to-disk 从 Fedora 映像创建 USB存储器，那么只需去掉 <code>--efi</code> 参数，存储器就会变为不可通过 UEFI 模式启动）。如果执行完此操作以后，你的固件仍然无法以 BIOS 兼容模式启动介质，那么就去吐槽你的固件供应商吧（如果还没吐槽过）。</p>
<h3 id="磁盘格式（MBR-vs-GPT）"><a href="#磁盘格式（MBR-vs-GPT）" class="headerlink" title="磁盘格式（MBR vs. GPT）"></a>磁盘格式（MBR vs. GPT）</h3><p>其他注意事项如下：</p>
<ul>
<li><p>如果想执行“BIOS 兼容”类型的安装，那么需要安装到 MBR 格式的磁盘。</p>
</li>
<li><p>如果想执行原生 UEFI 安装，那么需要安装到 GPT 格式的磁盘。</p>
</li>
</ul>
<p>当然，为了给用户找不自在，许多固件可以通过 BIOS 模式从 GPT 格式的磁盘启动。事实上，从技术层面而言，也要求 UEFI 固件能从 MBR 格式的磁盘以 UEFI 模式启动（虽然无法保证）。但是你应当尽可能避免这种情况。这些注意事项非常重要，因为许多用户都曾深受其害。例如，以原生 UEFI 模式启动操作系统安装程序，然后试图直接安装到 MBR 格式的磁盘是非常不明智的。很有可能失败。多数现代操作系统安装程序将把磁盘自动重新格式化为正确格式（如果你允许安装程序彻底清除磁盘数据），但是，如果你尝试让安装程序“对此 MBR 格式的磁盘执行原生 UEFI 安装，并且不要重新格式化这块磁盘，因为上面有重要数据”，那么就很有可能失败，尽管技术层面而言，UEFI 规范提到了这种配置。具体而言，至少 Windows 和 Fedora 会明确禁止这种配置。</p>
<h3 id="检查磁盘格式"><a href="#检查磁盘格式" class="headerlink" title="检查磁盘格式"></a>检查磁盘格式</h3><p>你可以使用 parted 实用程序检查给定磁盘的格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[adamw@adam Downloads]$ sudo parted /dev/sda</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/sda</span><br><span class="line">Welcome to GNU Parted! Type <span class="string">'help'</span> to view a list of commands.</span><br><span class="line">(parted) p</span><br><span class="line">Model: ATA C300-CTFDDAC128M (scsi)</span><br><span class="line">Disk /dev/sda: 128GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: msdos</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number Start End Size Type File system Flags</span><br><span class="line">1 1049kB 525MB 524MB primary ext4 boot</span><br><span class="line">2 525MB 128GB 128GB primary lvm</span><br><span class="line"></span><br><span class="line">(parted)</span><br></pre></td></tr></table></figure>

<p>注意到 <code>Partition table: msdos</code> 那一行了吗？这是一块 MBR/MS-DOS 格式的磁盘。如果是 GPT 格式的磁盘，会显示 gpt。你可以从 parted 中通过执行 mklabel gpt 或 mklabel msdos 将磁盘重新格式化为其他类型分区表。这会破坏磁盘内容。</p>
<p>对于多数操作系统的安装程序而言，如果你采用的磁盘配置会清空目标磁盘的所有内容，那么根据执行的安装类型，安装程序就会自动使用最合适的配置重新格式化磁盘。但是如果你想使用现有磁盘而不格式化，那么你需要检查该磁盘的格式并三思而后行。</p>
<h3 id="执行手动分区时处理-EFI-系统分区"><a href="#执行手动分区时处理-EFI-系统分区" class="headerlink" title="执行手动分区时处理 EFI 系统分区"></a>执行手动分区时处理 EFI 系统分区</h3><p>我只能针对 Fedora 给出权威建议，但是其中的主要内容可能也适用于其他发行版/操作系统。</p>
<p>执行原生 UEFI 安装，并且采用 GPT 格式的磁盘时，或者允许 Fedora 重新格式化磁盘（通过删除所有现有分区）时，如果允许 Fedora 自动处理分区，那么 Fedora 就会自动处理 EFI 系统分区。</p>
<p>但是，如果使用自定义分区，Fedora 会要求指定 EFI 系统分区，以供安装程序使用。如果不执行此步骤，安装程序会报错（错误消息的含义不明）并拒绝启动安装。</p>
<p>因此，如果执行原生 UEFI 安装并使用自定义分区，需要确保类型为“EFI 系统分区”的分区已挂载到 /boot/efi（这是 Fedora 查找 EFI 系统分区的路径）。如果系统上存在现有 EFI 系统分区，那么仅需将其挂载点设置为 /boot/efi 即可。如果还没有 EFI 系统分区，那么请创建一个分区，将其类型设置为 EFI 系统分区，大小至少为 <code>200MB</code>（建议 <code>500MB</code>），然后将其挂载点设置为 <code>/boot/efi</code>。</p>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>上文解释了 UEFI 的启动原理(至少解释得差不多了)。我这种描述方法应该还可以吧？</p>
<p>但是，UEFI 并不完美，也有许多问题。</p>
<p>细心的读者可能已经留意，我曾经提到过，UEFI 规范提供了一种机制。这种说法很严谨，也很重要。由于 UEFI 规范是一种“广泛共识”，因此其主要缺点之一（就特定方面而言）是并未提供具体实现。</p>
<p>如果仔细阅读 UEFI 规范，就会发现 UEFI 规范的基本方式是定义 UEFI 兼容固件必须支持的一系列功能。但是 UEFI 规范并没有严格规定这些功能的具体实现方法。</p>
<p>因此，UEFI 规范只要求系统固件必须遵循其中描述的所有内容，以便满足 UEFI 兼容固件的要求。但是，规范本身未规定操作系统“应该”或“必须”怎么做，并且 UEFI 规范也没有规定固件不得支持（或者不期望支持）的功能。换言之，在制定 UEFI 固件时，需要支持 GPT 格式的磁盘和 FAT 格式的 EFI 系统分区，并且必须以标准格式读取 UEFI 启动管理器项等等——但是也可以随意添加其他未规定的功能。</p>
<p>从 UEFI 规范中不难发现其中的隐喻——UEFI 规范仔细设置了一种良好机制，用于在固件层处理操作系统（或其他启动项）选择。但是 UEFI 规范并不要求一定要这么做，其他广受赞誉的规范也没有类似规定。</p>
<p>因此，在实际使用时，我们可能遇到各种复杂情况。例如，Apple Mac 的 HFS+ 分区中随附了某些启动装载程序。UEFI 规范提到，UEFI 兼容固件必须支持特定 GPT 分区类型的 UEFI FAT 分区（标识为“EFI 系统分区”），但是 UEFI 规范并没有提到固件不能识别其他文件系统类型并从中加载启动装载程序。（此类分区是否应视为“EFI 系统分区”，这很难回答，在此不做探讨。）</p>
<p>要是所有厂商都能按照 UEFI 规范严格使用 EFI 系统分区，那就不会有这么多问题了。但是 Apple 毕竟是 Apple，它的产品设计领先于其他厂商，率先设计出了可以从 HFS+ 分区读取和加载代码的固件，导致现在其他厂商不得不紧随 Apple 的脚步，除非他们不打算支持 Mac。在启动过程设计中，Apple 进行的工作远超出 UEFI 规范的范围，因此，如果你想让其他操作系统以美观的图标或其他形式显示在 Mac 的图形启动菜单上，你所要做的操作将超出 UEFI 规范的建议范围。</p>
<h2 id="安全启动-Secure-Boot"><a href="#安全启动-Secure-Boot" class="headerlink" title="安全启动 (Secure Boot)"></a>安全启动 (Secure Boot)</h2><p>我们最后要介绍的，就是安全启动 (Secure Boot)。</p>
<p>安全启动 (Secure Boot) 并不神奇，也不复杂。才怪。安全启动 (Secure Boot) 复杂得要命，但是其理论并不复杂。安全启动 (Secure Boot) 本身也并不邪恶。事实就是如此，你也应当认同这一事实，除非你认为GPG也有恶意。</p>
<p>在 UEFI 规范（2.4A 版本）的第 28 章对安全启动 (Secure Boot) 进行了定义。这种机制事实上非常明智。但是其原理却非常简单。<code>UEFI 规范规定固件可以包含一系列签名，并拒绝运行未签名或签名与固件中包含的签名不一致的 EFI 可执行文件</code>。</p>
<h2 id="实际使用安全启动-Secure-Boot"><a href="#实际使用安全启动-Secure-Boot" class="headerlink" title="实际使用安全启动 (Secure Boot)"></a>实际使用安全启动 (Secure Boot)</h2><p>有关安全启动 (Secure Boot) 的所有不满并不针对安全启动 (Secure Boot) 机制本身——虽然发出这些不满的人可能不这么认为——而是针对安全启动 (Secure Boot) 在实际操作中的特定实现方式。</p>
<p>我们唯一在意的是，对于预装 Windows 8 或更高版本 Windows 的 PC 而言，安全启动 (Secure Boot) 是默认开启的。</p>
<p>微软将这些称为“Windows 硬件认证要求”。这些要求并不是什么绝密内容，所有人都可以在互联网上阅读。</p>
<p>你最好读一遍，但是我对其内容进行了总结。</p>
<p>符合微软认证要求的计算机必须满足以下条件：</p>
<ul>
<li><p>默认启用安全启动 (Secure Boot)（服务器除外）</p>
</li>
<li><p>在其信任密钥列表中包含微软的密钥</p>
</li>
<li><p>启用安全启动 (Secure Boot) 时，必须禁用 BIOS 兼容模式（如果没记错的话，UEFI 规范也有此要求）</p>
</li>
<li><p>支持签名黑名单</p>
</li>
</ul>
<p>符合微软认证要求的 x86 计算机 还必须满足以下附加条件：</p>
<ul>
<li><p>允许 自然人禁用安全启动 (Secure Boot)</p>
</li>
<li><p>允许 自然人启用自定义模式，以及修改固件的信任密钥列表</p>
</li>
</ul>
<p>符合微软认证要求的 ARM 计算机 还必须满足以下附加条件：</p>
<ul>
<li><p>不允许 自然人禁用安全启动 (Secure Boot)</p>
</li>
<li><p>不允许 自然人启用自定义模式，以及修改固件的信任密钥列表</p>
</li>
</ul>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>以下内容是我在管理系统启动方面的一般建议，不保证其准确性、可靠性或安全性。</p>
<ul>
<li><p>如果可以的话，每台计算机只安装一个操作系统。如果你需要一个以上操作系统，那就多买几台计算机，或使用虚拟机。这么做的话，事情就简单多了，而且无论你的固件是 BIOS 或 UEFI，或在 UEFI 系统上使用 BIOS 兼容启动，都没什么关系了。你在使用计算机时也会轻松许多。</p>
</li>
<li><p>如果你确实需要在每台计算机上安装多个操作系统，那么请在每块磁盘上至少安装一个操作系统。如果你比较熟悉 BIOS 启动，而且也不需要安全启动 (Secure Boot) 功能，在这种情况下，对于 UEFI 系统，请优先使用 BIOS 兼容启动。这样一来，可能不会有那么多麻烦，也不会造成数据丢失。如果每块磁盘只安装一个操作系统，那么你也可以混合使用原生 UEFI 和 BIOS 兼容模式。</p>
</li>
<li><p>如果你坚持要在每块磁盘上安装多个操作系统，那么请先理解本文所写内容。这么做无异于自作孽，不可活，出了问题可别责怪操作系统供应商。另外，在这种情况下，也不要混用原生 UEFI 和 BIOS 兼容模式，否则就是雪上加霜。</p>
</li>
<li><p>如果你在使用 UEFI 原生启动，并且不打算自己编译内核/内核模块或在 Linux 上使用 NVIDIA/ATI 私有驱动程序，那么最好启用安全启动 (Secure Boot)。这不会有什么副作用，反而可以带来额外的安全性，用以应对某些卑鄙的攻击类型（尽管目前很少被利用）。</p>
</li>
<li><p>如果打算编译内核/内核模块或使用 NVIDIA/ATI 私有驱动程序，那就最好禁用安全启动 (Secure Boot)。或者你可以启用安全启动 (Secure Boot)，然后阅读有关配置信任链和对内核/内核模块签名的说明。但是这一过程至少需要好几天。</p>
</li>
<li><p>不要在 MBR 格式的磁盘上进行原生 UEFI 安装，也不要在 GPT 格式的磁盘上进行 BIOS 兼容安装（如果没记错的话，除非你的磁盘大小大于 2.2TB，因为 MBR 格式无法识别那么大的磁盘。如果想在那么大的磁盘上进行 BIOS 兼容安装，那么你可能会卡在 BIOS+GPT 的组合上。虽然这种组合可以正常运行，但是有点不靠谱，而且会牵涉到臭名昭著的“BIOS Boot 分区”）。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>UEFI</tag>
        <tag>MBR</tag>
      </tags>
  </entry>
</search>
